(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_bootstrap-tagsinput_dist_bootstrap-tagsinput_js-node_modules_bootstrap4--1b7f1d"],{

/***/ "./node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
(function ($) {
  "use strict";

  var defaultOptions = {
    tagClass: function(item) {
      return 'label label-info';
    },
    itemValue: function(item) {
      return item ? item.toString() : item;
    },
    itemText: function(item) {
      return this.itemValue(item);
    },
    itemTitle: function(item) {
      return null;
    },
    freeInput: true,
    addOnBlur: true,
    maxTags: undefined,
    maxChars: undefined,
    confirmKeys: [13, 44],
    delimiter: ',',
    delimiterRegex: null,
    cancelConfirmKeysOnEmpty: false,
    onTagExists: function(item, $tag) {
      $tag.hide().fadeIn();
    },
    trimValue: false,
    allowDuplicates: false
  };

  /**
   * Constructor function
   */
  function TagsInput(element, options) {
    this.isInit = true;
    this.itemsArray = [];

    this.$element = $(element);
    this.$element.hide();

    this.isSelect = (element.tagName === 'SELECT');
    this.multiple = (this.isSelect && element.hasAttribute('multiple'));
    this.objectItems = options && options.itemValue;
    this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
    this.inputSize = Math.max(1, this.placeholderText.length);

    this.$container = $('<div class="bootstrap-tagsinput"></div>');
    this.$input = $('<input type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);

    this.$element.before(this.$container);

    this.build(options);
    this.isInit = false;
  }

  TagsInput.prototype = {
    constructor: TagsInput,

    /**
     * Adds the given item as a new tag. Pass true to dontPushVal to prevent
     * updating the elements val()
     */
    add: function(item, dontPushVal, options) {
      var self = this;

      if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
        return;

      // Ignore falsey values, except false
      if (item !== false && !item)
        return;

      // Trim value
      if (typeof item === "string" && self.options.trimValue) {
        item = $.trim(item);
      }

      // Throw an error when trying to add an object while the itemValue option was not set
      if (typeof item === "object" && !self.objectItems)
        throw("Can't add objects when itemValue option is not set");

      // Ignore strings only containg whitespace
      if (item.toString().match(/^\s*$/))
        return;

      // If SELECT but not multiple, remove current tag
      if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
        self.remove(self.itemsArray[0]);

      if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
        var delimiter = (self.options.delimiterRegex) ? self.options.delimiterRegex : self.options.delimiter;
        var items = item.split(delimiter);
        if (items.length > 1) {
          for (var i = 0; i < items.length; i++) {
            this.add(items[i], true);
          }

          if (!dontPushVal)
            self.pushVal();
          return;
        }
      }

      var itemValue = self.options.itemValue(item),
          itemText = self.options.itemText(item),
          tagClass = self.options.tagClass(item),
          itemTitle = self.options.itemTitle(item);

      // Ignore items allready added
      var existing = $.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];
      if (existing && !self.options.allowDuplicates) {
        // Invoke onTagExists
        if (self.options.onTagExists) {
          var $existingTag = $(".tag", self.$container).filter(function() { return $(this).data("item") === existing; });
          self.options.onTagExists(item, $existingTag);
        }
        return;
      }

      // if length greater than limit
      if (self.items().toString().length + item.length + 1 > self.options.maxInputLength)
        return;

      // raise beforeItemAdd arg
      var beforeItemAddEvent = $.Event('beforeItemAdd', { item: item, cancel: false, options: options});
      self.$element.trigger(beforeItemAddEvent);
      if (beforeItemAddEvent.cancel)
        return;

      // register item in internal array and map
      self.itemsArray.push(item);

      // add a tag element

      var $tag = $('<span class="tag ' + htmlEncode(tagClass) + (itemTitle !== null ? ('" title="' + itemTitle) : '') + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
      $tag.data('item', item);
      self.findInputWrapper().before($tag);
      $tag.after(' ');

      // Check to see if the tag exists in its raw or uri-encoded form
      var optionExists = (
        $('option[value="' + encodeURIComponent(itemValue) + '"]', self.$element).length ||
        $('option[value="' + htmlEncode(itemValue) + '"]', self.$element).length
      );

      // add <option /> if item represents a value not present in one of the <select />'s options
      if (self.isSelect && !optionExists) {
        var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
        $option.data('item', item);
        $option.attr('value', itemValue);
        self.$element.append($option);
      }

      if (!dontPushVal)
        self.pushVal();

      // Add class when reached maxTags
      if (self.options.maxTags === self.itemsArray.length || self.items().toString().length === self.options.maxInputLength)
        self.$container.addClass('bootstrap-tagsinput-max');

      // If using typeahead, once the tag has been added, clear the typeahead value so it does not stick around in the input.
      if ($('.typeahead, .twitter-typeahead', self.$container).length) {
        self.$input.typeahead('val', '');
      }

      if (this.isInit) {
        self.$element.trigger($.Event('itemAddedOnInit', { item: item, options: options }));
      } else {
        self.$element.trigger($.Event('itemAdded', { item: item, options: options }));
      }
    },

    /**
     * Removes the given item. Pass true to dontPushVal to prevent updating the
     * elements val()
     */
    remove: function(item, dontPushVal, options) {
      var self = this;

      if (self.objectItems) {
        if (typeof item === "object")
          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } );
        else
          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } );

        item = item[item.length-1];
      }

      if (item) {
        var beforeItemRemoveEvent = $.Event('beforeItemRemove', { item: item, cancel: false, options: options });
        self.$element.trigger(beforeItemRemoveEvent);
        if (beforeItemRemoveEvent.cancel)
          return;

        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();
        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();
        if($.inArray(item, self.itemsArray) !== -1)
          self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
      }

      if (!dontPushVal)
        self.pushVal();

      // Remove class when reached maxTags
      if (self.options.maxTags > self.itemsArray.length)
        self.$container.removeClass('bootstrap-tagsinput-max');

      self.$element.trigger($.Event('itemRemoved',  { item: item, options: options }));
    },

    /**
     * Removes all items
     */
    removeAll: function() {
      var self = this;

      $('.tag', self.$container).remove();
      $('option', self.$element).remove();

      while(self.itemsArray.length > 0)
        self.itemsArray.pop();

      self.pushVal();
    },

    /**
     * Refreshes the tags so they match the text/value of their corresponding
     * item.
     */
    refresh: function() {
      var self = this;
      $('.tag', self.$container).each(function() {
        var $tag = $(this),
            item = $tag.data('item'),
            itemValue = self.options.itemValue(item),
            itemText = self.options.itemText(item),
            tagClass = self.options.tagClass(item);

          // Update tag's class and inner text
          $tag.attr('class', null);
          $tag.addClass('tag ' + htmlEncode(tagClass));
          $tag.contents().filter(function() {
            return this.nodeType == 3;
          })[0].nodeValue = htmlEncode(itemText);

          if (self.isSelect) {
            var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });
            option.attr('value', itemValue);
          }
      });
    },

    /**
     * Returns the items added as tags
     */
    items: function() {
      return this.itemsArray;
    },

    /**
     * Assembly value by retrieving the value of each item, and set it on the
     * element.
     */
    pushVal: function() {
      var self = this,
          val = $.map(self.items(), function(item) {
            return self.options.itemValue(item).toString();
          });

      self.$element.val(val, true).trigger('change');
    },

    /**
     * Initializes the tags input behaviour on the element
     */
    build: function(options) {
      var self = this;

      self.options = $.extend({}, defaultOptions, options);
      // When itemValue is set, freeInput should always be false
      if (self.objectItems)
        self.options.freeInput = false;

      makeOptionItemFunction(self.options, 'itemValue');
      makeOptionItemFunction(self.options, 'itemText');
      makeOptionFunction(self.options, 'tagClass');

      // Typeahead Bootstrap version 2.3.2
      if (self.options.typeahead) {
        var typeahead = self.options.typeahead || {};

        makeOptionFunction(typeahead, 'source');

        self.$input.typeahead($.extend({}, typeahead, {
          source: function (query, process) {
            function processItems(items) {
              var texts = [];

              for (var i = 0; i < items.length; i++) {
                var text = self.options.itemText(items[i]);
                map[text] = items[i];
                texts.push(text);
              }
              process(texts);
            }

            this.map = {};
            var map = this.map,
                data = typeahead.source(query);

            if ($.isFunction(data.success)) {
              // support for Angular callbacks
              data.success(processItems);
            } else if ($.isFunction(data.then)) {
              // support for Angular promises
              data.then(processItems);
            } else {
              // support for functions and jquery promises
              $.when(data)
               .then(processItems);
            }
          },
          updater: function (text) {
            self.add(this.map[text]);
            return this.map[text];
          },
          matcher: function (text) {
            return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
          },
          sorter: function (texts) {
            return texts.sort();
          },
          highlighter: function (text) {
            var regex = new RegExp( '(' + this.query + ')', 'gi' );
            return text.replace( regex, "<strong>$1</strong>" );
          }
        }));
      }

      // typeahead.js
      if (self.options.typeaheadjs) {
          var typeaheadConfig = null;
          var typeaheadDatasets = {};

          // Determine if main configurations were passed or simply a dataset
          var typeaheadjs = self.options.typeaheadjs;
          if ($.isArray(typeaheadjs)) {
            typeaheadConfig = typeaheadjs[0];
            typeaheadDatasets = typeaheadjs[1];
          } else {
            typeaheadDatasets = typeaheadjs;
          }

          self.$input.typeahead(typeaheadConfig, typeaheadDatasets).on('typeahead:selected', $.proxy(function (obj, datum) {
            if (typeaheadDatasets.valueKey)
              self.add(datum[typeaheadDatasets.valueKey]);
            else
              self.add(datum);
            self.$input.typeahead('val', '');
          }, self));
      }

      self.$container.on('click', $.proxy(function(event) {
        if (! self.$element.attr('disabled')) {
          self.$input.removeAttr('disabled');
        }
        self.$input.focus();
      }, self));

        if (self.options.addOnBlur && self.options.freeInput) {
          self.$input.on('focusout', $.proxy(function(event) {
              // HACK: only process on focusout when no typeahead opened, to
              //       avoid adding the typeahead text as tag
              if ($('.typeahead, .twitter-typeahead', self.$container).length === 0) {
                self.add(self.$input.val());
                self.$input.val('');
              }
          }, self));
        }


      self.$container.on('keydown', 'input', $.proxy(function(event) {
        var $input = $(event.target),
            $inputWrapper = self.findInputWrapper();

        if (self.$element.attr('disabled')) {
          self.$input.attr('disabled', 'disabled');
          return;
        }

        switch (event.which) {
          // BACKSPACE
          case 8:
            if (doGetCaretPosition($input[0]) === 0) {
              var prev = $inputWrapper.prev();
              if (prev.length) {
                self.remove(prev.data('item'));
              }
            }
            break;

          // DELETE
          case 46:
            if (doGetCaretPosition($input[0]) === 0) {
              var next = $inputWrapper.next();
              if (next.length) {
                self.remove(next.data('item'));
              }
            }
            break;

          // LEFT ARROW
          case 37:
            // Try to move the input before the previous tag
            var $prevTag = $inputWrapper.prev();
            if ($input.val().length === 0 && $prevTag[0]) {
              $prevTag.before($inputWrapper);
              $input.focus();
            }
            break;
          // RIGHT ARROW
          case 39:
            // Try to move the input after the next tag
            var $nextTag = $inputWrapper.next();
            if ($input.val().length === 0 && $nextTag[0]) {
              $nextTag.after($inputWrapper);
              $input.focus();
            }
            break;
         default:
             // ignore
         }

        // Reset internal input's size
        var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
        $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      self.$container.on('keypress', 'input', $.proxy(function(event) {
         var $input = $(event.target);

         if (self.$element.attr('disabled')) {
            self.$input.attr('disabled', 'disabled');
            return;
         }

         var text = $input.val(),
         maxLengthReached = self.options.maxChars && text.length >= self.options.maxChars;
         if (self.options.freeInput && (keyCombinationInList(event, self.options.confirmKeys) || maxLengthReached)) {
            // Only attempt to add a tag if there is data in the field
            if (text.length !== 0) {
               self.add(maxLengthReached ? text.substr(0, self.options.maxChars) : text);
               $input.val('');
            }

            // If the field is empty, let the event triggered fire as usual
            if (self.options.cancelConfirmKeysOnEmpty === false) {
                event.preventDefault();
            }
         }

         // Reset internal input's size
         var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
         $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      // Remove icon clicked
      self.$container.on('click', '[data-role=remove]', $.proxy(function(event) {
        if (self.$element.attr('disabled')) {
          return;
        }
        self.remove($(event.target).closest('.tag').data('item'));
      }, self));

      // Only add existing value as tags when using strings as tags
      if (self.options.itemValue === defaultOptions.itemValue) {
        if (self.$element[0].tagName === 'INPUT') {
            self.add(self.$element.val());
        } else {
          $('option', self.$element).each(function() {
            self.add($(this).attr('value'), true);
          });
        }
      }
    },

    /**
     * Removes all tagsinput behaviour and unregsiter all event handlers
     */
    destroy: function() {
      var self = this;

      // Unbind events
      self.$container.off('keypress', 'input');
      self.$container.off('click', '[role=remove]');

      self.$container.remove();
      self.$element.removeData('tagsinput');
      self.$element.show();
    },

    /**
     * Sets focus on the tagsinput
     */
    focus: function() {
      this.$input.focus();
    },

    /**
     * Returns the internal input element
     */
    input: function() {
      return this.$input;
    },

    /**
     * Returns the element which is wrapped around the internal input. This
     * is normally the $container, but typeahead.js moves the $input element.
     */
    findInputWrapper: function() {
      var elt = this.$input[0],
          container = this.$container[0];
      while(elt && elt.parentNode !== container)
        elt = elt.parentNode;

      return $(elt);
    }
  };

  /**
   * Register JQuery plugin
   */
  $.fn.tagsinput = function(arg1, arg2, arg3) {
    var results = [];

    this.each(function() {
      var tagsinput = $(this).data('tagsinput');
      // Initialize a new tags input
      if (!tagsinput) {
          tagsinput = new TagsInput(this, arg1);
          $(this).data('tagsinput', tagsinput);
          results.push(tagsinput);

          if (this.tagName === 'SELECT') {
              $('option', $(this)).attr('selected', 'selected');
          }

          // Init tags from $(this).val()
          $(this).val($(this).val());
      } else if (!arg1 && !arg2) {
          // tagsinput already exists
          // no function, trying to init
          results.push(tagsinput);
      } else if(tagsinput[arg1] !== undefined) {
          // Invoke function on existing tags input
            if(tagsinput[arg1].length === 3 && arg3 !== undefined){
               var retVal = tagsinput[arg1](arg2, null, arg3);
            }else{
               var retVal = tagsinput[arg1](arg2);
            }
          if (retVal !== undefined)
              results.push(retVal);
      }
    });

    if ( typeof arg1 == 'string') {
      // Return the results from the invoked function calls
      return results.length > 1 ? results : results[0];
    } else {
      return results;
    }
  };

  $.fn.tagsinput.Constructor = TagsInput;

  /**
   * Most options support both a string or number as well as a function as
   * option value. This function makes sure that the option with the given
   * key in the given options is wrapped in a function
   */
  function makeOptionItemFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var propertyName = options[key];
      options[key] = function(item) { return item[propertyName]; };
    }
  }
  function makeOptionFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var value = options[key];
      options[key] = function() { return value; };
    }
  }
  /**
   * HtmlEncodes the given value
   */
  var htmlEncodeContainer = $('<div />');
  function htmlEncode(value) {
    if (value) {
      return htmlEncodeContainer.text(value).html();
    } else {
      return '';
    }
  }

  /**
   * Returns the position of the caret in the given input field
   * http://flightschool.acylt.com/devnotes/caret-position-woes/
   */
  function doGetCaretPosition(oField) {
    var iCaretPos = 0;
    if (document.selection) {
      oField.focus ();
      var oSel = document.selection.createRange();
      oSel.moveStart ('character', -oField.value.length);
      iCaretPos = oSel.text.length;
    } else if (oField.selectionStart || oField.selectionStart == '0') {
      iCaretPos = oField.selectionStart;
    }
    return (iCaretPos);
  }

  /**
    * Returns boolean indicates whether user has pressed an expected key combination.
    * @param object keyPressEvent: JavaScript event object, refer
    *     http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    * @param object lookupList: expected key combinations, as in:
    *     [13, {which: 188, shiftKey: true}]
    */
  function keyCombinationInList(keyPressEvent, lookupList) {
      var found = false;
      $.each(lookupList, function (index, keyCombination) {
          if (typeof (keyCombination) === 'number' && keyPressEvent.which === keyCombination) {
              found = true;
              return false;
          }

          if (keyPressEvent.which === keyCombination.which) {
              var alt = !keyCombination.hasOwnProperty('altKey') || keyPressEvent.altKey === keyCombination.altKey,
                  shift = !keyCombination.hasOwnProperty('shiftKey') || keyPressEvent.shiftKey === keyCombination.shiftKey,
                  ctrl = !keyCombination.hasOwnProperty('ctrlKey') || keyPressEvent.ctrlKey === keyCombination.ctrlKey;
              if (alt && shift && ctrl) {
                  found = true;
                  return false;
              }
          }
      });

      return found;
  }

  /**
   * Initialize tagsinput behaviour on inputs and selects which have
   * data-role=tagsinput
   */
  $(function() {
    $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
  });
})(__webpack_provided_window_dot_jQuery);


/***/ }),

/***/ "./node_modules/bootstrap4-duallistbox/dist/jquery.bootstrap-duallistbox.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/bootstrap4-duallistbox/dist/jquery.bootstrap-duallistbox.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  Bootstrap Duallistbox - v4.0.2
 *  A responsive dual listbox widget optimized for Twitter Bootstrap. It works on all modern browsers and on touch devices.
 *  http://www.virtuosoft.eu/code/bootstrap-duallistbox/
 *
 *  Made by István Ujj-Mészáros
 *  Under Apache License v2.0 License
 */
(function(factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(function($) {
  // Create the defaults once
  var pluginName = 'bootstrapDualListbox',
    defaults = {
      filterTextClear: 'show all',
      filterPlaceHolder: 'Filter',
      moveSelectedLabel: 'Move selected',
      moveAllLabel: 'Move all',
      removeSelectedLabel: 'Remove selected',
      removeAllLabel: 'Remove all',
      moveOnSelect: true,                                                                 // true/false (forced true on androids, see the comment later)
      moveOnDoubleClick: true,                                                            // true/false (forced false on androids, cause moveOnSelect is forced to true)
      preserveSelectionOnMove: false,                                                     // 'all' / 'moved' / false
      selectedListLabel: false,                                                           // 'string', false
      nonSelectedListLabel: false,                                                        // 'string', false
      helperSelectNamePostfix: '_helper',                                                 // 'string_of_postfix' / false
      selectorMinimalHeight: 100,
      showFilterInputs: true,                                                             // whether to show filter inputs
      nonSelectedFilter: '',                                                              // string, filter the non selected options
      selectedFilter: '',                                                                 // string, filter the selected options
      infoText: 'Showing all {0}',                                                        // text when all options are visible / false for no info text
      infoTextFiltered: '<span class="badge badge-warning">Filtered</span> {0} from {1}', // when not all of the options are visible due to the filter
      infoTextEmpty: 'Empty list',                                                        // when there are no options present in the list
      filterOnValues: false,                                                              // filter by selector's values, boolean
      sortByInputOrder: false,
      eventMoveOverride: false,                                                           // boolean, allows user to unbind default event behaviour and run their own instead
      eventMoveAllOverride: false,                                                        // boolean, allows user to unbind default event behaviour and run their own instead
      eventRemoveOverride: false,                                                         // boolean, allows user to unbind default event behaviour and run their own instead
      eventRemoveAllOverride: false,                                                      // boolean, allows user to unbind default event behaviour and run their own instead
      btnClass: 'btn-outline-secondary',                                                  // sets the button style class for all the buttons
      btnMoveText: '&gt;',                                                                // string, sets the text for the "Move" button
      btnRemoveText: '&lt;',                                                              // string, sets the text for the "Remove" button
      btnMoveAllText: '&gt;&gt;',                                                         // string, sets the text for the "Move All" button
      btnRemoveAllText: '&lt;&lt;'                                                        // string, sets the text for the "Remove All" button
    },
    // Selections are invisible on android if the containing select is styled with CSS
    // http://code.google.com/p/android/issues/detail?id=16922
    isBuggyAndroid = /android/i.test(navigator.userAgent.toLowerCase());

  // The actual plugin constructor
  function BootstrapDualListbox(element, options) {
    this.element = $(element);
    // jQuery has an extend method which merges the contents of two or
    // more objects, storing the result in the first object. The first object
    // is generally empty as we don't want to alter the default options for
    // future instances of the plugin
    this.settings = $.extend({}, defaults, options);
    this._defaults = defaults;
    this._name = pluginName;
    this.init();
  }

  function triggerChangeEvent(dualListbox) {
    dualListbox.element.trigger('change');
  }

  function updateSelectionStates(dualListbox) {
    dualListbox.element.find('option').each(function(index, item) {
      var $item = $(item);
      if (typeof($item.data('original-index')) === 'undefined') {
        $item.data('original-index', dualListbox.elementCount++);
      }
      if (typeof($item.data('_selected')) === 'undefined') {
        $item.data('_selected', false);
      }
    });
  }

  function changeSelectionState(dualListbox, original_index, selected) {
    dualListbox.element.find('option').each(function(index, item) {
      var $item = $(item);
      if ($item.data('original-index') === original_index) {
        $item.prop('selected', selected);
        if(selected){
          $item.attr('data-sortindex', dualListbox.sortIndex);
          dualListbox.sortIndex++;
        } else {
          $item.removeAttr('data-sortindex');
        }
      }
    });
  }

  function formatString(s, args) {
    console.log(s, args);
    return s.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : match;
    });
  }

  function refreshInfo(dualListbox) {
    if (!dualListbox.settings.infoText) {
      return;
    }

    var visible1 = dualListbox.elements.select1.find('option').length,
      visible2 = dualListbox.elements.select2.find('option').length,
      all1 = dualListbox.element.find('option').length - dualListbox.selectedElements,
      all2 = dualListbox.selectedElements,
      content = '';

    if (all1 === 0) {
      content = dualListbox.settings.infoTextEmpty;
    } else if (visible1 === all1) {
      content = formatString(dualListbox.settings.infoText, [visible1, all1]);
    } else {
      content = formatString(dualListbox.settings.infoTextFiltered, [visible1, all1]);
    }

    dualListbox.elements.info1.html(content);
    dualListbox.elements.box1.toggleClass('filtered', !(visible1 === all1 || all1 === 0));

    if (all2 === 0) {
      content = dualListbox.settings.infoTextEmpty;
    } else if (visible2 === all2) {
      content = formatString(dualListbox.settings.infoText, [visible2, all2]);
    } else {
      content = formatString(dualListbox.settings.infoTextFiltered, [visible2, all2]);
    }

    dualListbox.elements.info2.html(content);
    dualListbox.elements.box2.toggleClass('filtered', !(visible2 === all2 || all2 === 0));
  }

  function refreshSelects(dualListbox) {
    dualListbox.selectedElements = 0;

    dualListbox.elements.select1.empty();
    dualListbox.elements.select2.empty();

    dualListbox.element.find('option').each(function(index, item) {
      var $item = $(item);
      if ($item.prop('selected')) {
        dualListbox.selectedElements++;
        dualListbox.elements.select2.append($item.clone(true).prop('selected', $item.data('_selected')));
      } else {
        dualListbox.elements.select1.append($item.clone(true).prop('selected', $item.data('_selected')));
      }
    });

    if (dualListbox.settings.showFilterInputs) {
      filter(dualListbox, 1);
      filter(dualListbox, 2);
    }
    refreshInfo(dualListbox);
  }

  function filter(dualListbox, selectIndex) {
    if (!dualListbox.settings.showFilterInputs) {
      return;
    }

    saveSelections(dualListbox, selectIndex);

    dualListbox.elements['select'+selectIndex].empty().scrollTop(0);
    var regex,
      allOptions = dualListbox.element.find('option'),
      options = dualListbox.element;

    if (selectIndex === 1) {
      options = allOptions.not(':selected');
    } else  {
      options = options.find('option:selected');
    }

    try {
      regex = new RegExp($.trim(dualListbox.elements['filterInput'+selectIndex].val()), 'gi');
    }
    catch(e) {
      // a regex to match nothing
      regex = new RegExp('/a^/', 'gi');
    }

    options.each(function(index, item) {
      var $item = $(item),
        isFiltered = true;
      if (item.text.match(regex) || (dualListbox.settings.filterOnValues && $item.attr('value').match(regex) ) ) {
        isFiltered = false;
        dualListbox.elements['select'+selectIndex].append($item.clone(true).prop('selected', $item.data('_selected')));
      }
      allOptions.eq($item.data('original-index')).data('filtered'+selectIndex, isFiltered);
    });

    refreshInfo(dualListbox);
  }

  function saveSelections(dualListbox, selectIndex) {
    var options = dualListbox.element.find('option');
    dualListbox.elements['select'+selectIndex].find('option').each(function(index, item) {
      var $item = $(item);
      options.eq($item.data('original-index')).data('_selected', $item.prop('selected'));
    });
  }

  function sortOptionsByInputOrder(select){
    var selectopt = select.children('option');

    selectopt.sort(function(a,b){
      var an = parseInt(a.getAttribute('data-sortindex')),
          bn = parseInt(b.getAttribute('data-sortindex'));

          if(an > bn) {
             return 1;
          }
          if(an < bn) {
            return -1;
          }
          return 0;
    });

    selectopt.detach().appendTo(select);
  }

  function sortOptions(select, dualListbox) {
    select.find('option').sort(function(a, b) {
      return ($(a).data('original-index') > $(b).data('original-index')) ? 1 : -1;
    }).appendTo(select);

    // workaround for chromium bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1072475
    refreshSelects(dualListbox);
  }

  function clearSelections(dualListbox) {
    dualListbox.elements.select1.find('option').each(function() {
      dualListbox.element.find('option').data('_selected', false);
    });
  }

  function move(dualListbox) {
    if (dualListbox.settings.preserveSelectionOnMove === 'all' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
      saveSelections(dualListbox, 2);
    } else if (dualListbox.settings.preserveSelectionOnMove === 'moved' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
    }

    dualListbox.elements.select1.find('option:selected').each(function(index, item) {
      var $item = $(item);
      if (!$item.data('filtered1')) {
        changeSelectionState(dualListbox, $item.data('original-index'), true);
      }
    });

    refreshSelects(dualListbox);
    triggerChangeEvent(dualListbox);
    if(dualListbox.settings.sortByInputOrder){
        sortOptionsByInputOrder(dualListbox.elements.select2);
    } else {
        sortOptions(dualListbox.elements.select2, dualListbox);
    }
  }

  function remove(dualListbox) {
    if (dualListbox.settings.preserveSelectionOnMove === 'all' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
      saveSelections(dualListbox, 2);
    } else if (dualListbox.settings.preserveSelectionOnMove === 'moved' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 2);
    }

    dualListbox.elements.select2.find('option:selected').each(function(index, item) {
      var $item = $(item);
      if (!$item.data('filtered2')) {
        changeSelectionState(dualListbox, $item.data('original-index'), false);
      }
    });

    refreshSelects(dualListbox);
    triggerChangeEvent(dualListbox);
    sortOptions(dualListbox.elements.select1, dualListbox);
    if(dualListbox.settings.sortByInputOrder){
        sortOptionsByInputOrder(dualListbox.elements.select2);
    }
  }

  function moveAll(dualListbox) {
    if (dualListbox.settings.preserveSelectionOnMove === 'all' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
      saveSelections(dualListbox, 2);
    } else if (dualListbox.settings.preserveSelectionOnMove === 'moved' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
    }

    dualListbox.element.find('option').each(function(index, item) {
      var $item = $(item);
      if (!$item.data('filtered1')) {
        $item.prop('selected', true);
        $item.attr('data-sortindex', dualListbox.sortIndex);
        dualListbox.sortIndex++;
      }
    });

    refreshSelects(dualListbox);
    triggerChangeEvent(dualListbox);
  }

  function removeAll(dualListbox) {
    if (dualListbox.settings.preserveSelectionOnMove === 'all' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 1);
      saveSelections(dualListbox, 2);
    } else if (dualListbox.settings.preserveSelectionOnMove === 'moved' && !dualListbox.settings.moveOnSelect) {
      saveSelections(dualListbox, 2);
    }

    dualListbox.element.find('option').each(function(index, item) {
      var $item = $(item);
      if (!$item.data('filtered2')) {
        $item.prop('selected', false);
        $item.removeAttr('data-sortindex');
      }
    });

    refreshSelects(dualListbox);
    triggerChangeEvent(dualListbox);
  }

  function bindEvents(dualListbox) {
    dualListbox.elements.form.submit(function(e) {
      if (dualListbox.elements.filterInput1.is(':focus')) {
        e.preventDefault();
        dualListbox.elements.filterInput1.focusout();
      } else if (dualListbox.elements.filterInput2.is(':focus')) {
        e.preventDefault();
        dualListbox.elements.filterInput2.focusout();
      }
    });

    dualListbox.element.on('bootstrapDualListbox.refresh', function(e, mustClearSelections){
      dualListbox.refresh(mustClearSelections);
    });

    dualListbox.elements.filterClear1.on('click', function() {
      dualListbox.setNonSelectedFilter('', true);
    });

    dualListbox.elements.filterClear2.on('click', function() {
      dualListbox.setSelectedFilter('', true);
    });

    if (dualListbox.settings.eventMoveOverride === false) {
      dualListbox.elements.moveButton.on('click', function() {
        move(dualListbox);
      });
    }

    if (dualListbox.settings.eventMoveAllOverride === false) {
      dualListbox.elements.moveAllButton.on('click', function() {
        moveAll(dualListbox);
      });
    }

    if (dualListbox.settings.eventRemoveOverride === false) {
      dualListbox.elements.removeButton.on('click', function() {
        remove(dualListbox);
      });
    }

    if (dualListbox.settings.eventRemoveAllOverride === false) {
      dualListbox.elements.removeAllButton.on('click', function() {
        removeAll(dualListbox);
      });
    }

    dualListbox.elements.filterInput1.on('change keyup', function() {
      filter(dualListbox, 1);
    });

    dualListbox.elements.filterInput2.on('change keyup', function() {
      filter(dualListbox, 2);
    });
  }

  BootstrapDualListbox.prototype = {
    init: function () {
      // Add the custom HTML template
      this.container = $('' +
        '<div class="bootstrap-duallistbox-container row">' +
        ' <div class="box1 col-md-6">' +
        '   <label></label>' +
        '   <span class="info-container">' +
        '     <span class="info"></span>' +
        '     <button type="button" class="btn btn-sm clear1" style="float:right!important;"></button>' +
        '   </span>' +
        '   <input class="form-control filter" type="text">' +
        '   <div class="btn-group buttons">' +
        '     <button type="button" class="btn moveall"></button>' +
        '     <button type="button" class="btn move"></button>' +
        '   </div>' +
        '   <select multiple="multiple"></select>' +
        ' </div>' +
        ' <div class="box2 col-md-6">' +
        '   <label></label>' +
        '   <span class="info-container">' +
        '     <span class="info"></span>' +
        '     <button type="button" class="btn btn-sm clear2" style="float:right!important;"></button>' +
        '   </span>' +
        '   <input class="form-control filter" type="text">' +
        '   <div class="btn-group buttons">' +
        '     <button type="button" class="btn remove"></button>' +
        '     <button type="button" class="btn removeall"></button>' +
        '   </div>' +
        '   <select multiple="multiple"></select>' +
        ' </div>' +
        '</div>')
        .insertBefore(this.element);

      // Cache the inner elements
      this.elements = {
        originalSelect: this.element,
        box1: $('.box1', this.container),
        box2: $('.box2', this.container),
        filterInput1: $('.box1 .filter', this.container),
        filterInput2: $('.box2 .filter', this.container),
        filterClear1: $('.box1 .clear1', this.container),
        filterClear2: $('.box2 .clear2', this.container),
        label1: $('.box1 > label', this.container),
        label2: $('.box2 > label', this.container),
        info1: $('.box1 .info', this.container),
        info2: $('.box2 .info', this.container),
        select1: $('.box1 select', this.container),
        select2: $('.box2 select', this.container),
        moveButton: $('.box1 .move', this.container),
        removeButton: $('.box2 .remove', this.container),
        moveAllButton: $('.box1 .moveall', this.container),
        removeAllButton: $('.box2 .removeall', this.container),
        form: $($('.box1 .filter', this.container)[0].form)
      };

      // Set select IDs
      this.originalSelectName = this.element.attr('name') || '';
      var select1Id = 'bootstrap-duallistbox-nonselected-list_' + this.originalSelectName,
        select2Id = 'bootstrap-duallistbox-selected-list_' + this.originalSelectName;
      this.elements.select1.attr('id', select1Id);
      this.elements.select2.attr('id', select2Id);
      this.elements.label1.attr('for', select1Id);
      this.elements.label2.attr('for', select2Id);

      // Apply all settings
      this.selectedElements = 0;
      this.sortIndex = 0;
      this.elementCount = 0;
      this.setFilterTextClear(this.settings.filterTextClear);
      this.setFilterPlaceHolder(this.settings.filterPlaceHolder);
      this.setMoveSelectedLabel(this.settings.moveSelectedLabel);
      this.setMoveAllLabel(this.settings.moveAllLabel);
      this.setRemoveSelectedLabel(this.settings.removeSelectedLabel);
      this.setRemoveAllLabel(this.settings.removeAllLabel);
      this.setMoveOnSelect(this.settings.moveOnSelect);
      this.setMoveOnDoubleClick(this.settings.moveOnDoubleClick);
      this.setPreserveSelectionOnMove(this.settings.preserveSelectionOnMove);
      this.setSelectedListLabel(this.settings.selectedListLabel);
      this.setNonSelectedListLabel(this.settings.nonSelectedListLabel);
      this.setHelperSelectNamePostfix(this.settings.helperSelectNamePostfix);
      this.setSelectOrMinimalHeight(this.settings.selectorMinimalHeight);

      updateSelectionStates(this);

      this.setShowFilterInputs(this.settings.showFilterInputs);
      this.setNonSelectedFilter(this.settings.nonSelectedFilter);
      this.setSelectedFilter(this.settings.selectedFilter);
      this.setInfoText(this.settings.infoText);
      this.setInfoTextFiltered(this.settings.infoTextFiltered);
      this.setInfoTextEmpty(this.settings.infoTextEmpty);
      this.setFilterOnValues(this.settings.filterOnValues);
      this.setSortByInputOrder(this.settings.sortByInputOrder);
      this.setEventMoveOverride(this.settings.eventMoveOverride);
      this.setEventMoveAllOverride(this.settings.eventMoveAllOverride);
      this.setEventRemoveOverride(this.settings.eventRemoveOverride);
      this.setEventRemoveAllOverride(this.settings.eventRemoveAllOverride);
      this.setBtnClass(this.settings.btnClass);
      this.setBtnMoveText(this.settings.btnMoveText);
      this.setBtnRemoveText(this.settings.btnRemoveText);
      this.setBtnMoveAllText(this.settings.btnMoveAllText);
      this.setBtnRemoveAllText(this.settings.btnRemoveAllText);

      // Hide the original select
      this.element.hide();

      bindEvents(this);
      refreshSelects(this);

      return this.element;
    },
    setFilterTextClear: function(value, refresh) {
      this.settings.filterTextClear = value;
      this.elements.filterClear1.html(value);
      this.elements.filterClear2.html(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setFilterPlaceHolder: function(value, refresh) {
      this.settings.filterPlaceHolder = value;
      this.elements.filterInput1.attr('placeholder', value);
      this.elements.filterInput2.attr('placeholder', value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setMoveSelectedLabel: function(value, refresh) {
      this.settings.moveSelectedLabel = value;
      this.elements.moveButton.attr('title', value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setMoveAllLabel: function(value, refresh) {
      this.settings.moveAllLabel = value;
      this.elements.moveAllButton.attr('title', value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setRemoveSelectedLabel: function(value, refresh) {
      this.settings.removeSelectedLabel = value;
      this.elements.removeButton.attr('title', value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setRemoveAllLabel: function(value, refresh) {
      this.settings.removeAllLabel = value;
      this.elements.removeAllButton.attr('title', value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setMoveOnSelect: function(value, refresh) {
      if (isBuggyAndroid) {
        value = true;
      }
      this.settings.moveOnSelect = value;
      if (this.settings.moveOnSelect) {
        this.container.addClass('moveonselect');
        var self = this;
        this.elements.select1.on('change', function() {
          move(self);
        });
        this.elements.select2.on('change', function() {
          remove(self);
        });
        this.elements.moveButton.detach();
        this.elements.removeButton.detach();
      } else {
        this.container.removeClass('moveonselect');
        this.elements.select1.off('change');
        this.elements.select2.off('change');
        this.elements.moveButton.insertAfter(this.elements.moveAllButton);
        this.elements.removeButton.insertBefore(this.elements.removeAllButton);
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setMoveOnDoubleClick: function(value, refresh) {
      if (isBuggyAndroid) {
        value = false;
      }
      this.settings.moveOnDoubleClick = value;
      if (this.settings.moveOnDoubleClick) {
        this.container.addClass('moveondoubleclick');
        var self = this;
        this.elements.select1.on('dblclick', function() {
          move(self);
        });
        this.elements.select2.on('dblclick', function() {
          remove(self);
        });
      } else {
        this.container.removeClass('moveondoubleclick');
        this.elements.select1.off('dblclick');
        this.elements.select2.off('dblclick');
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setPreserveSelectionOnMove: function(value, refresh) {
      // We are forcing to move on select and disabling preserveSelectionOnMove on Android
      if (isBuggyAndroid) {
        value = false;
      }
      this.settings.preserveSelectionOnMove = value;
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setSelectedListLabel: function(value, refresh) {
      this.settings.selectedListLabel = value;
      if (value) {
        this.elements.label2.show().html(value);
      } else {
        this.elements.label2.hide().html(value);
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setNonSelectedListLabel: function(value, refresh) {
      this.settings.nonSelectedListLabel = value;
      if (value) {
        this.elements.label1.show().html(value);
      } else {
        this.elements.label1.hide().html(value);
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setHelperSelectNamePostfix: function(value, refresh) {
      this.settings.helperSelectNamePostfix = value;
      if (value) {
        this.elements.select1.attr('name', this.originalSelectName + value + '1');
        this.elements.select2.attr('name', this.originalSelectName + value + '2');
      } else {
        this.elements.select1.removeAttr('name');
        this.elements.select2.removeAttr('name');
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setSelectOrMinimalHeight: function(value, refresh) {
      this.settings.selectorMinimalHeight = value;
      var height = this.element.height();
      if (this.element.height() < value) {
        height = value;
      }
      this.elements.select1.height(height);
      this.elements.select2.height(height);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setShowFilterInputs: function(value, refresh) {
      if (!value) {
        this.setNonSelectedFilter('');
        this.setSelectedFilter('');
        refreshSelects(this);
        this.elements.filterInput1.hide();
        this.elements.filterInput2.hide();
      } else {
        this.elements.filterInput1.show();
        this.elements.filterInput2.show();
      }
      this.settings.showFilterInputs = value;
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setNonSelectedFilter: function(value, refresh) {
      if (this.settings.showFilterInputs) {
        this.settings.nonSelectedFilter = value;
        this.elements.filterInput1.val(value);
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
      }
    },
    setSelectedFilter: function(value, refresh) {
      if (this.settings.showFilterInputs) {
        this.settings.selectedFilter = value;
        this.elements.filterInput2.val(value);
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
      }
    },
    setInfoText: function(value, refresh) {
      this.settings.infoText = value;
      if (value) {
        this.elements.info1.show();
        this.elements.info2.show();
      } else {
        this.elements.info1.hide();
        this.elements.info2.hide();
      }
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setInfoTextFiltered: function(value, refresh) {
      this.settings.infoTextFiltered = value;
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setInfoTextEmpty: function(value, refresh) {
      this.settings.infoTextEmpty = value;
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setFilterOnValues: function(value, refresh) {
      this.settings.filterOnValues = value;
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setSortByInputOrder: function(value, refresh){
        this.settings.sortByInputOrder = value;
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
    },
    setEventMoveOverride: function(value, refresh) {
        this.settings.eventMoveOverride = value;
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
    },
    setEventMoveAllOverride: function(value, refresh) {
        this.settings.eventMoveAllOverride = value;
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
    },
    setEventRemoveOverride: function(value, refresh) {
        this.settings.eventRemoveOverride = value;
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
    },
    setEventRemoveAllOverride: function(value, refresh) {
        this.settings.eventRemoveAllOverride = value;
        if (refresh) {
          refreshSelects(this);
        }
        return this.element;
    },
    setBtnClass: function(value, refresh) {
      this.settings.btnClass = value;
      this.elements.moveButton.attr('class', 'btn move').addClass(value);
      this.elements.removeButton.attr('class', 'btn remove').addClass(value);
      this.elements.moveAllButton.attr('class', 'btn moveall').addClass(value);
      this.elements.removeAllButton.attr('class', 'btn removeall').addClass(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setBtnMoveText: function(value, refresh) {
      this.settings.btnMoveText = value;
      this.elements.moveButton.html(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setBtnRemoveText: function(value, refresh) {
      this.settings.btnMoveText = value;
      this.elements.removeButton.html(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setBtnMoveAllText: function(value, refresh) {
      this.settings.btnMoveText = value;
      this.elements.moveAllButton.html(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    setBtnRemoveAllText: function(value, refresh) {
      this.settings.btnMoveText = value;
      this.elements.removeAllButton.html(value);
      if (refresh) {
        refreshSelects(this);
      }
      return this.element;
    },
    getContainer: function() {
      return this.container;
    },
    refresh: function(mustClearSelections) {
      updateSelectionStates(this);

      if (!mustClearSelections) {
        saveSelections(this, 1);
        saveSelections(this, 2);
      } else {
        clearSelections(this);
      }

      refreshSelects(this);
    },
    destroy: function() {
      this.container.remove();
      this.element.show();
      $.data(this, 'plugin_' + pluginName, null);
      return this.element;
    }
  };

  // A really lightweight plugin wrapper around the constructor,
  // preventing against multiple instantiations
  $.fn[ pluginName ] = function (options) {
    var args = arguments;

    // Is the first parameter an object (options), or was omitted, instantiate a new instance of the plugin.
    if (options === undefined || typeof options === 'object') {
      return this.each(function () {
        // If this is not a select
        if (!$(this).is('select')) {
          $(this).find('select').each(function(index, item) {
            // For each nested select, instantiate the Dual List Box
            $(item).bootstrapDualListbox(options);
          });
        } else if (!$.data(this, 'plugin_' + pluginName)) {
          // Only allow the plugin to be instantiated once so we check that the element has no plugin instantiation yet

          // if it has no instance, create a new one, pass options to our plugin constructor,
          // and store the plugin instance in the elements jQuery data object.
          $.data(this, 'plugin_' + pluginName, new BootstrapDualListbox(this, options));
        }
      });
      // If the first parameter is a string and it doesn't start with an underscore or "contains" the `init`-function,
      // treat this as a call to a public method.
    } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {

      // Cache the method call to make it possible to return a value
      var returns;

      this.each(function () {
        var instance = $.data(this, 'plugin_' + pluginName);
        // Tests that there's already a plugin-instance and checks that the requested public method exists
        if (instance instanceof BootstrapDualListbox && typeof instance[options] === 'function') {
          // Call the method of our plugin instance, and pass it the supplied arguments.
          returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
        }
      });

      // If the earlier cached method gives a value back return the value,
      // otherwise return this to preserve chainability.
      return returns !== undefined ? returns : this;
    }

  };

}));


/***/ }),

/***/ "./node_modules/eonasdan-bootstrap-datetimepicker/src/js/bootstrap-datetimepicker.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/eonasdan-bootstrap-datetimepicker/src/js/bootstrap-datetimepicker.js ***!
  \*******************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  * Bootstrap Datetime Picker v4.17.49
  * Copyright 2015-2020 Jonathan Peterson
  * Licensed under MIT (https://github.com/Eonasdan/bootstrap-datetimepicker/blob/master/LICENSE)
  */
/*global define:false */
/*global exports:false */
/*global require:false */
/*global jQuery:false */
/*global moment:false */
(function (factory) {
    'use strict';
    if (true) {
        // AMD is used - Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(function ($, moment) {
    'use strict';
    if (!moment) {
        throw new Error('bootstrap-datetimepicker requires Moment.js to be loaded first');
    }

    var dateTimePicker = function (element, options) {
        var picker = {},
            date,
            viewDate,
            unset = true,
            input,
            component = false,
            widget = false,
            use24Hours,
            minViewModeNumber = 0,
            actualFormat,
            parseFormats,
            currentViewMode,
            datePickerModes = [
                {
                    clsName: 'days',
                    navFnc: 'M',
                    navStep: 1
                },
                {
                    clsName: 'months',
                    navFnc: 'y',
                    navStep: 1
                },
                {
                    clsName: 'years',
                    navFnc: 'y',
                    navStep: 10
                },
                {
                    clsName: 'decades',
                    navFnc: 'y',
                    navStep: 100
                }
            ],
            viewModes = ['days', 'months', 'years', 'decades'],
            verticalModes = ['top', 'bottom', 'auto'],
            horizontalModes = ['left', 'right', 'auto'],
            toolbarPlacements = ['default', 'top', 'bottom'],
            keyMap = {
                'up': 38,
                38: 'up',
                'down': 40,
                40: 'down',
                'left': 37,
                37: 'left',
                'right': 39,
                39: 'right',
                'tab': 9,
                9: 'tab',
                'escape': 27,
                27: 'escape',
                'enter': 13,
                13: 'enter',
                'pageUp': 33,
                33: 'pageUp',
                'pageDown': 34,
                34: 'pageDown',
                'shift': 16,
                16: 'shift',
                'control': 17,
                17: 'control',
                'space': 32,
                32: 'space',
                't': 84,
                84: 't',
                'delete': 46,
                46: 'delete'
            },
            keyState = {},

            /********************************************************************************
             *
             * Private functions
             *
             ********************************************************************************/

            hasTimeZone = function () {
                return moment.tz !== undefined && options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== '';
            },

            getMoment = function (d) {
                var returnMoment;

                if (d === undefined || d === null) {
                    returnMoment = moment(); //TODO should this use format? and locale?
                } else if (moment.isDate(d) || moment.isMoment(d)) {
                    // If the date that is passed in is already a Date() or moment() object,
                    // pass it directly to moment.
                    returnMoment = moment(d);
                } else if (hasTimeZone()) { // There is a string to parse and a default time zone
                    // parse with the tz function which takes a default time zone if it is not in the format string
                    returnMoment = moment.tz(d, parseFormats, options.useStrict, options.timeZone);
                } else {
                    returnMoment = moment(d, parseFormats, options.useStrict);
                }

                if (hasTimeZone()) {
                    returnMoment.tz(options.timeZone);
                }

                return returnMoment;
            },

            isEnabled = function (granularity) {
                if (typeof granularity !== 'string' || granularity.length > 1) {
                    throw new TypeError('isEnabled expects a single character string parameter');
                }
                switch (granularity) {
                    case 'y':
                        return actualFormat.indexOf('Y') !== -1;
                    case 'M':
                        return actualFormat.indexOf('M') !== -1;
                    case 'd':
                        return actualFormat.toLowerCase().indexOf('d') !== -1;
                    case 'h':
                    case 'H':
                        return actualFormat.toLowerCase().indexOf('h') !== -1;
                    case 'm':
                        return actualFormat.indexOf('m') !== -1;
                    case 's':
                        return actualFormat.indexOf('s') !== -1;
                    default:
                        return false;
                }
            },

            hasTime = function () {
                return (isEnabled('h') || isEnabled('m') || isEnabled('s'));
            },

            hasDate = function () {
                return (isEnabled('y') || isEnabled('M') || isEnabled('d'));
            },

            getDatePickerTemplate = function () {
                var headTemplate = $('<thead>')
                        .append($('<tr>')
                            .append($('<th>').addClass('prev').attr('data-action', 'previous')
                                .append($('<span>').addClass(options.icons.previous))
                                )
                            .append($('<th>').addClass('picker-switch').attr('data-action', 'pickerSwitch').attr('colspan', (options.calendarWeeks ? '6' : '5')))
                            .append($('<th>').addClass('next').attr('data-action', 'next')
                                .append($('<span>').addClass(options.icons.next))
                                )
                            ),
                    contTemplate = $('<tbody>')
                        .append($('<tr>')
                            .append($('<td>').attr('colspan', (options.calendarWeeks ? '8' : '7')))
                            );

                return [
                    $('<div>').addClass('datepicker-days')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate)
                            .append($('<tbody>'))
                            ),
                    $('<div>').addClass('datepicker-months')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            ),
                    $('<div>').addClass('datepicker-years')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            ),
                    $('<div>').addClass('datepicker-decades')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            )
                ];
            },

            getTimePickerMainTemplate = function () {
                var topRow = $('<tr>'),
                    middleRow = $('<tr>'),
                    bottomRow = $('<tr>');

                if (isEnabled('h')) {
                    topRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementHour }).addClass('btn').attr('data-action', 'incrementHours').append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-hour').attr({ 'data-time-component': 'hours', 'title': options.tooltips.pickHour }).attr('data-action', 'showHours')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementHour }).addClass('btn').attr('data-action', 'decrementHours').append($('<span>').addClass(options.icons.down))));
                }
                if (isEnabled('m')) {
                    if (isEnabled('h')) {
                        topRow.append($('<td>').addClass('separator'));
                        middleRow.append($('<td>').addClass('separator').html(':'));
                        bottomRow.append($('<td>').addClass('separator'));
                    }
                    topRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementMinute }).addClass('btn').attr('data-action', 'incrementMinutes')
                            .append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-minute').attr({ 'data-time-component': 'minutes', 'title': options.tooltips.pickMinute }).attr('data-action', 'showMinutes')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementMinute }).addClass('btn').attr('data-action', 'decrementMinutes')
                            .append($('<span>').addClass(options.icons.down))));
                }
                if (isEnabled('s')) {
                    if (isEnabled('m')) {
                        topRow.append($('<td>').addClass('separator'));
                        middleRow.append($('<td>').addClass('separator').html(':'));
                        bottomRow.append($('<td>').addClass('separator'));
                    }
                    topRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementSecond }).addClass('btn').attr('data-action', 'incrementSeconds')
                            .append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-second').attr({ 'data-time-component': 'seconds', 'title': options.tooltips.pickSecond }).attr('data-action', 'showSeconds')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementSecond }).addClass('btn').attr('data-action', 'decrementSeconds')
                            .append($('<span>').addClass(options.icons.down))));
                }

                if (!use24Hours) {
                    topRow.append($('<td>').addClass('separator'));
                    middleRow.append($('<td>')
                        .append($('<button>').addClass('btn btn-primary').attr({ 'data-action': 'togglePeriod', tabindex: '-1', 'title': options.tooltips.togglePeriod })));
                    bottomRow.append($('<td>').addClass('separator'));
                }

                return $('<div>').addClass('timepicker-picker')
                    .append($('<table>').addClass('table-condensed')
                        .append([topRow, middleRow, bottomRow]));
            },

            getTimePickerTemplate = function () {
                var hoursView = $('<div>').addClass('timepicker-hours')
                        .append($('<table>').addClass('table-condensed')),
                    minutesView = $('<div>').addClass('timepicker-minutes')
                        .append($('<table>').addClass('table-condensed')),
                    secondsView = $('<div>').addClass('timepicker-seconds')
                        .append($('<table>').addClass('table-condensed')),
                    ret = [getTimePickerMainTemplate()];

                if (isEnabled('h')) {
                    ret.push(hoursView);
                }
                if (isEnabled('m')) {
                    ret.push(minutesView);
                }
                if (isEnabled('s')) {
                    ret.push(secondsView);
                }

                return ret;
            },

            getToolbar = function () {
                var row = [];
                if (options.showTodayButton) {
                    row.push($('<td>').append($('<a>').attr({ 'data-action': 'today', 'title': options.tooltips.today }).append($('<span>').addClass(options.icons.today))));
                }
                if (!options.sideBySide && hasDate() && hasTime()) {
                    row.push($('<td>').append($('<a>').attr({ 'data-action': 'togglePicker', 'title': options.tooltips.selectTime }).append($('<span>').addClass(options.icons.time))));
                }
                if (options.showClear) {
                    row.push($('<td>').append($('<a>').attr({ 'data-action': 'clear', 'title': options.tooltips.clear }).append($('<span>').addClass(options.icons.clear))));
                }
                if (options.showClose) {
                    row.push($('<td>').append($('<a>').attr({ 'data-action': 'close', 'title': options.tooltips.close }).append($('<span>').addClass(options.icons.close))));
                }
                return $('<table>').addClass('table-condensed').append($('<tbody>').append($('<tr>').append(row)));
            },

            getTemplate = function () {
                var template = $('<div>').addClass('bootstrap-datetimepicker-widget dropdown-menu'),
                    dateView = $('<div>').addClass('datepicker').append(getDatePickerTemplate()),
                    timeView = $('<div>').addClass('timepicker').append(getTimePickerTemplate()),
                    content = $('<ul>').addClass('list-unstyled'),
                    toolbar = $('<li>').addClass('picker-switch' + (options.collapse ? ' accordion-toggle' : '')).append(getToolbar());

                if (options.inline) {
                    template.removeClass('dropdown-menu');
                }

                if (use24Hours) {
                    template.addClass('usetwentyfour');
                }

                if (isEnabled('s') && !use24Hours) {
                    template.addClass('wider');
                }

                if (options.sideBySide && hasDate() && hasTime()) {
                    template.addClass('timepicker-sbs');
                    if (options.toolbarPlacement === 'top') {
                        template.append(toolbar);
                    }
                    template.append(
                        $('<div>').addClass('row')
                            .append(dateView.addClass('col-md-6'))
                            .append(timeView.addClass('col-md-6'))
                    );
                    if (options.toolbarPlacement === 'bottom') {
                        template.append(toolbar);
                    }
                    return template;
                }

                if (options.toolbarPlacement === 'top') {
                    content.append(toolbar);
                }
                if (hasDate()) {
                    content.append($('<li>').addClass((options.collapse && hasTime() ? 'collapse in' : '')).append(dateView));
                }
                if (options.toolbarPlacement === 'default') {
                    content.append(toolbar);
                }
                if (hasTime()) {
                    content.append($('<li>').addClass((options.collapse && hasDate() ? 'collapse' : '')).append(timeView));
                }
                if (options.toolbarPlacement === 'bottom') {
                    content.append(toolbar);
                }
                return template.append(content);
            },

            dataToOptions = function () {
                var eData,
                    dataOptions = {};

                if (element.is('input') || options.inline) {
                    eData = element.data();
                } else {
                    eData = element.find('input').data();
                }

                if (eData.dateOptions && eData.dateOptions instanceof Object) {
                    dataOptions = $.extend(true, dataOptions, eData.dateOptions);
                }

                $.each(options, function (key) {
                    var attributeName = 'date' + key.charAt(0).toUpperCase() + key.slice(1);
                    if (eData[attributeName] !== undefined) {
                        dataOptions[key] = eData[attributeName];
                    }
                });
                return dataOptions;
            },

            place = function () {
                var position = (component || element).position(),
                    offset = (component || element).offset(),
                    vertical = options.widgetPositioning.vertical,
                    horizontal = options.widgetPositioning.horizontal,
                    parent;

                if (options.widgetParent) {
                    parent = options.widgetParent.append(widget);
                } else if (element.is('input')) {
                    parent = element.after(widget).parent();
                } else if (options.inline) {
                    parent = element.append(widget);
                    return;
                } else {
                    parent = element;
                    element.children().first().after(widget);
                }

                // Top and bottom logic
                if (vertical === 'auto') {
                    if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() &&
                        widget.height() + element.outerHeight() < offset.top) {
                        vertical = 'top';
                    } else {
                        vertical = 'bottom';
                    }
                }

                // Left and right logic
                if (horizontal === 'auto') {
                    if (parent.width() < offset.left + widget.outerWidth() / 2 &&
                        offset.left + widget.outerWidth() > $(window).width()) {
                        horizontal = 'right';
                    } else {
                        horizontal = 'left';
                    }
                }

                if (vertical === 'top') {
                    widget.addClass('top').removeClass('bottom');
                } else {
                    widget.addClass('bottom').removeClass('top');
                }

                if (horizontal === 'right') {
                    widget.addClass('pull-right');
                } else {
                    widget.removeClass('pull-right');
                }

                // find the first parent element that has a non-static css positioning
                if (parent.css('position') === 'static') {
                    parent = parent.parents().filter(function () {
                        return $(this).css('position') !== 'static';
                    }).first();
                }

                if (parent.length === 0) {
                    throw new Error('datetimepicker component should be placed within a non-static positioned container');
                }

                widget.css({
                    top: vertical === 'top' ? 'auto' : position.top + element.outerHeight(),
                    bottom: vertical === 'top' ? parent.outerHeight() - (parent === element ? 0 : position.top) : 'auto',
                    left: horizontal === 'left' ? (parent === element ? 0 : position.left) : 'auto',
                    right: horizontal === 'left' ? 'auto' : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
                });
            },

            notifyEvent = function (e) {
                if (e.type === 'dp.change' && ((e.date && e.date.isSame(e.oldDate)) || (!e.date && !e.oldDate))) {
                    return;
                }
                element.trigger(e);
            },

            viewUpdate = function (e) {
                if (e === 'y') {
                    e = 'YYYY';
                }
                notifyEvent({
                    type: 'dp.update',
                    change: e,
                    viewDate: viewDate.clone()
                });
            },

            showMode = function (dir) {
                if (!widget) {
                    return;
                }
                if (dir) {
                    currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
                }
                widget.find('.datepicker > div').hide().filter('.datepicker-' + datePickerModes[currentViewMode].clsName).show();
            },

            fillDow = function () {
                var row = $('<tr>'),
                    currentDate = viewDate.clone().startOf('w').startOf('d');

                if (options.calendarWeeks === true) {
                    row.append($('<th>').addClass('cw').text('#'));
                }

                while (currentDate.isBefore(viewDate.clone().endOf('w'))) {
                    row.append($('<th>').addClass('dow').text(currentDate.format('dd')));
                    currentDate.add(1, 'd');
                }
                widget.find('.datepicker-days thead').append(row);
            },

            isInDisabledDates = function (testDate) {
                return options.disabledDates[testDate.format('YYYY-MM-DD')] === true;
            },

            isInEnabledDates = function (testDate) {
                return options.enabledDates[testDate.format('YYYY-MM-DD')] === true;
            },

            isInDisabledHours = function (testDate) {
                return options.disabledHours[testDate.format('H')] === true;
            },

            isInEnabledHours = function (testDate) {
                return options.enabledHours[testDate.format('H')] === true;
            },

            isValid = function (targetMoment, granularity) {
                if (!targetMoment.isValid()) {
                    return false;
                }
                if (options.disabledDates && granularity === 'd' && isInDisabledDates(targetMoment)) {
                    return false;
                }
                if (options.enabledDates && granularity === 'd' && !isInEnabledDates(targetMoment)) {
                    return false;
                }
                if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) {
                    return false;
                }
                if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) {
                    return false;
                }
                if (options.daysOfWeekDisabled && granularity === 'd' && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) {
                    return false;
                }
                if (options.disabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && isInDisabledHours(targetMoment)) {
                    return false;
                }
                if (options.enabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && !isInEnabledHours(targetMoment)) {
                    return false;
                }
                if (options.disabledTimeIntervals && (granularity === 'h' || granularity === 'm' || granularity === 's')) {
                    var found = false;
                    $.each(options.disabledTimeIntervals, function () {
                        if (targetMoment.isBetween(this[0], this[1])) {
                            found = true;
                            return false;
                        }
                    });
                    if (found) {
                        return false;
                    }
                }
                return true;
            },

            fillMonths = function () {
                var spans = [],
                    monthsShort = viewDate.clone().startOf('y').startOf('d');
                while (monthsShort.isSame(viewDate, 'y')) {
                    spans.push($('<span>').attr('data-action', 'selectMonth').addClass('month').text(monthsShort.format('MMM')));
                    monthsShort.add(1, 'M');
                }
                widget.find('.datepicker-months td').empty().append(spans);
            },

            updateMonths = function () {
                var monthsView = widget.find('.datepicker-months'),
                    monthsViewHeader = monthsView.find('th'),
                    months = monthsView.find('tbody').find('span');

                monthsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevYear);
                monthsViewHeader.eq(1).attr('title', options.tooltips.selectYear);
                monthsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextYear);

                monthsView.find('.disabled').removeClass('disabled');

                if (!isValid(viewDate.clone().subtract(1, 'y'), 'y')) {
                    monthsViewHeader.eq(0).addClass('disabled');
                }

                monthsViewHeader.eq(1).text(viewDate.year());

                if (!isValid(viewDate.clone().add(1, 'y'), 'y')) {
                    monthsViewHeader.eq(2).addClass('disabled');
                }

                months.removeClass('active');
                if (date.isSame(viewDate, 'y') && !unset) {
                    months.eq(date.month()).addClass('active');
                }

                months.each(function (index) {
                    if (!isValid(viewDate.clone().month(index), 'M')) {
                        $(this).addClass('disabled');
                    }
                });
            },

            updateYears = function () {
                var yearsView = widget.find('.datepicker-years'),
                    yearsViewHeader = yearsView.find('th'),
                    startYear = viewDate.clone().subtract(5, 'y'),
                    endYear = viewDate.clone().add(6, 'y'),
                    html = '';

                yearsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevDecade);
                yearsViewHeader.eq(1).attr('title', options.tooltips.selectDecade);
                yearsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextDecade);

                yearsView.find('.disabled').removeClass('disabled');

                if (options.minDate && options.minDate.isAfter(startYear, 'y')) {
                    yearsViewHeader.eq(0).addClass('disabled');
                }

                yearsViewHeader.eq(1).text(startYear.year() + '-' + endYear.year());

                if (options.maxDate && options.maxDate.isBefore(endYear, 'y')) {
                    yearsViewHeader.eq(2).addClass('disabled');
                }

                while (!startYear.isAfter(endYear, 'y')) {
                    html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, 'y') && !unset ? ' active' : '') + (!isValid(startYear, 'y') ? ' disabled' : '') + '">' + startYear.year() + '</span>';
                    startYear.add(1, 'y');
                }

                yearsView.find('td').html(html);
            },

            updateDecades = function () {
                var decadesView = widget.find('.datepicker-decades'),
                    decadesViewHeader = decadesView.find('th'),
                    startDecade = moment({ y: viewDate.year() - (viewDate.year() % 100) - 1 }),
                    endDecade = startDecade.clone().add(100, 'y'),
                    startedAt = startDecade.clone(),
                    minDateDecade = false,
                    maxDateDecade = false,
                    endDecadeYear,
                    html = '';

                decadesViewHeader.eq(0).find('span').attr('title', options.tooltips.prevCentury);
                decadesViewHeader.eq(2).find('span').attr('title', options.tooltips.nextCentury);

                decadesView.find('.disabled').removeClass('disabled');

                if (startDecade.isSame(moment({ y: 1900 })) || (options.minDate && options.minDate.isAfter(startDecade, 'y'))) {
                    decadesViewHeader.eq(0).addClass('disabled');
                }

                decadesViewHeader.eq(1).text(startDecade.year() + '-' + endDecade.year());

                if (startDecade.isSame(moment({ y: 2000 })) || (options.maxDate && options.maxDate.isBefore(endDecade, 'y'))) {
                    decadesViewHeader.eq(2).addClass('disabled');
                }

                while (!startDecade.isAfter(endDecade, 'y')) {
                    endDecadeYear = startDecade.year() + 12;
                    minDateDecade = options.minDate && options.minDate.isAfter(startDecade, 'y') && options.minDate.year() <= endDecadeYear;
                    maxDateDecade = options.maxDate && options.maxDate.isAfter(startDecade, 'y') && options.maxDate.year() <= endDecadeYear;
                    html += '<span data-action="selectDecade" class="decade' + (date.isAfter(startDecade) && date.year() <= endDecadeYear ? ' active' : '') +
                        (!isValid(startDecade, 'y') && !minDateDecade && !maxDateDecade ? ' disabled' : '') + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() + 1) + ' - ' + (startDecade.year() + 12) + '</span>';
                    startDecade.add(12, 'y');
                }
                html += '<span></span><span></span><span></span>'; //push the dangling block over, at least this way it's even

                decadesView.find('td').html(html);
                decadesViewHeader.eq(1).text((startedAt.year() + 1) + '-' + (startDecade.year()));
            },

            fillDate = function () {
                var daysView = widget.find('.datepicker-days'),
                    daysViewHeader = daysView.find('th'),
                    currentDate,
                    html = [],
                    row,
                    clsNames = [],
                    i;

                if (!hasDate()) {
                    return;
                }

                daysViewHeader.eq(0).find('span').attr('title', options.tooltips.prevMonth);
                daysViewHeader.eq(1).attr('title', options.tooltips.selectMonth);
                daysViewHeader.eq(2).find('span').attr('title', options.tooltips.nextMonth);

                daysView.find('.disabled').removeClass('disabled');
                daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));

                if (!isValid(viewDate.clone().subtract(1, 'M'), 'M')) {
                    daysViewHeader.eq(0).addClass('disabled');
                }
                if (!isValid(viewDate.clone().add(1, 'M'), 'M')) {
                    daysViewHeader.eq(2).addClass('disabled');
                }

                currentDate = viewDate.clone().startOf('M').startOf('w').startOf('d');

                for (i = 0; i < 42; i++) { //always display 42 days (should show 6 weeks)
                    if (currentDate.weekday() === 0) {
                        row = $('<tr>');
                        if (options.calendarWeeks) {
                            row.append('<td class="cw">' + currentDate.week() + '</td>');
                        }
                        html.push(row);
                    }
                    clsNames = ['day'];
                    if (currentDate.isBefore(viewDate, 'M')) {
                        clsNames.push('old');
                    }
                    if (currentDate.isAfter(viewDate, 'M')) {
                        clsNames.push('new');
                    }
                    if (currentDate.isSame(date, 'd') && !unset) {
                        clsNames.push('active');
                    }
                    if (!isValid(currentDate, 'd')) {
                        clsNames.push('disabled');
                    }
                    if (currentDate.isSame(getMoment(), 'd')) {
                        clsNames.push('today');
                    }
                    if (currentDate.day() === 0 || currentDate.day() === 6) {
                        clsNames.push('weekend');
                    }
                    notifyEvent({
                        type: 'dp.classify',
                        date: currentDate,
                        classNames: clsNames
                    });
                    row.append('<td data-action="selectDay" data-day="' + currentDate.format('L') + '" class="' + clsNames.join(' ') + '">' + currentDate.date() + '</td>');
                    currentDate.add(1, 'd');
                }

                daysView.find('tbody').empty().append(html);

                updateMonths();

                updateYears();

                updateDecades();
            },

            fillHours = function () {
                var table = widget.find('.timepicker-hours table'),
                    currentHour = viewDate.clone().startOf('d'),
                    html = [],
                    row = $('<tr>');

                if (viewDate.hour() > 11 && !use24Hours) {
                    currentHour.hour(12);
                }
                while (currentHour.isSame(viewDate, 'd') && (use24Hours || (viewDate.hour() < 12 && currentHour.hour() < 12) || viewDate.hour() > 11)) {
                    if (currentHour.hour() % 4 === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, 'h') ? ' disabled' : '') + '">' + currentHour.format(use24Hours ? 'HH' : 'hh') + '</td>');
                    currentHour.add(1, 'h');
                }
                table.empty().append(html);
            },

            fillMinutes = function () {
                var table = widget.find('.timepicker-minutes table'),
                    currentMinute = viewDate.clone().startOf('h'),
                    html = [],
                    row = $('<tr>'),
                    step = options.stepping === 1 ? 5 : options.stepping;

                while (viewDate.isSame(currentMinute, 'h')) {
                    if (currentMinute.minute() % (step * 4) === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, 'm') ? ' disabled' : '') + '">' + currentMinute.format('mm') + '</td>');
                    currentMinute.add(step, 'm');
                }
                table.empty().append(html);
            },

            fillSeconds = function () {
                var table = widget.find('.timepicker-seconds table'),
                    currentSecond = viewDate.clone().startOf('m'),
                    html = [],
                    row = $('<tr>');

                while (viewDate.isSame(currentSecond, 'm')) {
                    if (currentSecond.second() % 20 === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectSecond" class="second' + (!isValid(currentSecond, 's') ? ' disabled' : '') + '">' + currentSecond.format('ss') + '</td>');
                    currentSecond.add(5, 's');
                }

                table.empty().append(html);
            },

            fillTime = function () {
                var toggle, newDate, timeComponents = widget.find('.timepicker span[data-time-component]');

                if (!use24Hours) {
                    toggle = widget.find('.timepicker [data-action=togglePeriod]');
                    newDate = date.clone().add((date.hours() >= 12) ? -12 : 12, 'h');

                    toggle.text(date.format('A'));

                    if (isValid(newDate, 'h')) {
                        toggle.removeClass('disabled');
                    } else {
                        toggle.addClass('disabled');
                    }
                }
                timeComponents.filter('[data-time-component=hours]').text(date.format(use24Hours ? 'HH' : 'hh'));
                timeComponents.filter('[data-time-component=minutes]').text(date.format('mm'));
                timeComponents.filter('[data-time-component=seconds]').text(date.format('ss'));

                fillHours();
                fillMinutes();
                fillSeconds();
            },

            update = function () {
                if (!widget) {
                    return;
                }
                fillDate();
                fillTime();
            },

            setValue = function (targetMoment) {
                var oldDate = unset ? null : date;

                // case of calling setValue(null or false)
                if (!targetMoment) {
                    unset = true;
                    input.val('');
                    element.data('date', '');
                    notifyEvent({
                        type: 'dp.change',
                        date: false,
                        oldDate: oldDate
                    });
                    update();
                    return;
                }

                targetMoment = targetMoment.clone().locale(options.locale);

                if (hasTimeZone()) {
                    targetMoment.tz(options.timeZone);
                }

                if (options.stepping !== 1) {
                    targetMoment.minutes((Math.round(targetMoment.minutes() / options.stepping) * options.stepping)).seconds(0);

                    while (options.minDate && targetMoment.isBefore(options.minDate)) {
                        targetMoment.add(options.stepping, 'minutes');
                    }
                }

                if (isValid(targetMoment)) {
                    date = targetMoment;
                    viewDate = date.clone();
                    input.val(date.format(actualFormat));
                    element.data('date', date.format(actualFormat));
                    unset = false;
                    update();
                    notifyEvent({
                        type: 'dp.change',
                        date: date.clone(),
                        oldDate: oldDate
                    });
                } else {
                    if (!options.keepInvalid) {
                        input.val(unset ? '' : date.format(actualFormat));
                    } else {
                        notifyEvent({
                            type: 'dp.change',
                            date: targetMoment,
                            oldDate: oldDate
                        });
                    }
                    notifyEvent({
                        type: 'dp.error',
                        date: targetMoment,
                        oldDate: oldDate
                    });
                }
            },

            /**
             * Hides the widget. Possibly will emit dp.hide
             */
            hide = function () {
                var transitioning = false;
                if (!widget) {
                    return picker;
                }
                // Ignore event if in the middle of a picker transition
                widget.find('.collapse').each(function () {
                    var collapseData = $(this).data('collapse');
                    if (collapseData && collapseData.transitioning) {
                        transitioning = true;
                        return false;
                    }
                    return true;
                });
                if (transitioning) {
                    return picker;
                }
                if (component && component.hasClass('btn')) {
                    component.toggleClass('active');
                }
                widget.hide();

                $(window).off('resize', place);
                widget.off('click', '[data-action]');
                widget.off('mousedown', false);

                widget.remove();
                widget = false;

                notifyEvent({
                    type: 'dp.hide',
                    date: date.clone()
                });

                input.blur();

                viewDate = date.clone();

                return picker;
            },

            clear = function () {
                setValue(null);
            },

            parseInputDate = function (inputDate) {
                if (options.parseInputDate === undefined) {
                    if (!moment.isMoment(inputDate) || inputDate instanceof Date) {
                        inputDate = getMoment(inputDate);
                    }
                } else {
                    inputDate = options.parseInputDate(inputDate);
                }
                //inputDate.locale(options.locale);
                return inputDate;
            },

            /********************************************************************************
             *
             * Widget UI interaction functions
             *
             ********************************************************************************/
            actions = {
                next: function () {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
                    fillDate();
                    viewUpdate(navFnc);
                },

                previous: function () {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
                    fillDate();
                    viewUpdate(navFnc);
                },

                pickerSwitch: function () {
                    showMode(1);
                },

                selectMonth: function (e) {
                    var month = $(e.target).closest('tbody').find('span').index($(e.target));
                    viewDate.month(month);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('M');
                },

                selectYear: function (e) {
                    var year = parseInt($(e.target).text(), 10) || 0;
                    viewDate.year(year);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('YYYY');
                },

                selectDecade: function (e) {
                    var year = parseInt($(e.target).data('selection'), 10) || 0;
                    viewDate.year(year);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('YYYY');
                },

                selectDay: function (e) {
                    var day = viewDate.clone();
                    if ($(e.target).is('.old')) {
                        day.subtract(1, 'M');
                    }
                    if ($(e.target).is('.new')) {
                        day.add(1, 'M');
                    }
                    setValue(day.date(parseInt($(e.target).text(), 10)));
                    if (!hasTime() && !options.keepOpen && !options.inline) {
                        hide();
                    }
                },

                incrementHours: function () {
                    var newDate = date.clone().add(1, 'h');
                    if (isValid(newDate, 'h')) {
                        setValue(newDate);
                    }
                },

                incrementMinutes: function () {
                    var newDate = date.clone().add(options.stepping, 'm');
                    if (isValid(newDate, 'm')) {
                        setValue(newDate);
                    }
                },

                incrementSeconds: function () {
                    var newDate = date.clone().add(1, 's');
                    if (isValid(newDate, 's')) {
                        setValue(newDate);
                    }
                },

                decrementHours: function () {
                    var newDate = date.clone().subtract(1, 'h');
                    if (isValid(newDate, 'h')) {
                        setValue(newDate);
                    }
                },

                decrementMinutes: function () {
                    var newDate = date.clone().subtract(options.stepping, 'm');
                    if (isValid(newDate, 'm')) {
                        setValue(newDate);
                    }
                },

                decrementSeconds: function () {
                    var newDate = date.clone().subtract(1, 's');
                    if (isValid(newDate, 's')) {
                        setValue(newDate);
                    }
                },

                togglePeriod: function () {
                    setValue(date.clone().add((date.hours() >= 12) ? -12 : 12, 'h'));
                },

                togglePicker: function (e) {
                    var $this = $(e.target),
                        $parent = $this.closest('ul'),
                        expanded = $parent.find('.in'),
                        closed = $parent.find('.collapse:not(.in)'),
                        collapseData;

                    if (expanded && expanded.length) {
                        collapseData = expanded.data('collapse');
                        if (collapseData && collapseData.transitioning) {
                            return;
                        }
                        if (expanded.collapse) { // if collapse plugin is available through bootstrap.js then use it
                            expanded.collapse('hide');
                            closed.collapse('show');
                        } else { // otherwise just toggle in class on the two views
                            expanded.removeClass('in');
                            closed.addClass('in');
                        }
                        if ($this.is('span')) {
                            $this.toggleClass(options.icons.time + ' ' + options.icons.date);
                        } else {
                            $this.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
                        }

                        // NOTE: uncomment if toggled state will be restored in show()
                        //if (component) {
                        //    component.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
                        //}
                    }
                },

                showPicker: function () {
                    widget.find('.timepicker > div:not(.timepicker-picker)').hide();
                    widget.find('.timepicker .timepicker-picker').show();
                },

                showHours: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-hours').show();
                },

                showMinutes: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-minutes').show();
                },

                showSeconds: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-seconds').show();
                },

                selectHour: function (e) {
                    var hour = parseInt($(e.target).text(), 10);

                    if (!use24Hours) {
                        if (date.hours() >= 12) {
                            if (hour !== 12) {
                                hour += 12;
                            }
                        } else {
                            if (hour === 12) {
                                hour = 0;
                            }
                        }
                    }
                    setValue(date.clone().hours(hour));
                    actions.showPicker.call(picker);
                },

                selectMinute: function (e) {
                    setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker);
                },

                selectSecond: function (e) {
                    setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker);
                },

                clear: clear,

                today: function () {
                    var todaysDate = getMoment();
                    if (isValid(todaysDate, 'd')) {
                        setValue(todaysDate);
                    }
                },

                close: hide
            },

            doAction = function (e) {
                if ($(e.currentTarget).is('.disabled')) {
                    return false;
                }
                actions[$(e.currentTarget).data('action')].apply(picker, arguments);
                return false;
            },

            /**
             * Shows the widget. Possibly will emit dp.show and dp.change
             */
            show = function () {
                var currentMoment,
                    useCurrentGranularity = {
                        'year': function (m) {
                            return m.month(0).date(1).hours(0).seconds(0).minutes(0);
                        },
                        'month': function (m) {
                            return m.date(1).hours(0).seconds(0).minutes(0);
                        },
                        'day': function (m) {
                            return m.hours(0).seconds(0).minutes(0);
                        },
                        'hour': function (m) {
                            return m.seconds(0).minutes(0);
                        },
                        'minute': function (m) {
                            return m.seconds(0);
                        }
                    };

                if (input.prop('disabled') || (!options.ignoreReadonly && input.prop('readonly')) || widget) {
                    return picker;
                }
                if (input.val() !== undefined && input.val().trim().length !== 0) {
                    setValue(parseInputDate(input.val().trim()));
                } else if (unset && options.useCurrent && (options.inline || (input.is('input') && input.val().trim().length === 0))) {
                    currentMoment = getMoment();
                    if (typeof options.useCurrent === 'string') {
                        currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
                    }
                    setValue(currentMoment);
                }
                widget = getTemplate();

                fillDow();
                fillMonths();

                widget.find('.timepicker-hours').hide();
                widget.find('.timepicker-minutes').hide();
                widget.find('.timepicker-seconds').hide();

                update();
                showMode();

                $(window).on('resize', place);
                widget.on('click', '[data-action]', doAction); // this handles clicks on the widget
                widget.on('mousedown', false);

                if (component && component.hasClass('btn')) {
                    component.toggleClass('active');
                }
                place();
                widget.show();
                if (options.focusOnShow && !input.is(':focus')) {
                    input.focus();
                }

                notifyEvent({
                    type: 'dp.show'
                });
                return picker;
            },

            /**
             * Shows or hides the widget
             */
            toggle = function () {
                return (widget ? hide() : show());
            },

            keydown = function (e) {
                var handler = null,
                    index,
                    index2,
                    pressedKeys = [],
                    pressedModifiers = {},
                    currentKey = e.which,
                    keyBindKeys,
                    allModifiersPressed,
                    pressed = 'p';

                keyState[currentKey] = pressed;

                for (index in keyState) {
                    if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
                        pressedKeys.push(index);
                        if (parseInt(index, 10) !== currentKey) {
                            pressedModifiers[index] = true;
                        }
                    }
                }

                for (index in options.keyBinds) {
                    if (options.keyBinds.hasOwnProperty(index) && typeof (options.keyBinds[index]) === 'function') {
                        keyBindKeys = index.split(' ');
                        if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
                            allModifiersPressed = true;
                            for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--) {
                                if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
                                    allModifiersPressed = false;
                                    break;
                                }
                            }
                            if (allModifiersPressed) {
                                handler = options.keyBinds[index];
                                break;
                            }
                        }
                    }
                }

                if (handler) {
                    handler.call(picker, widget);
                    e.stopPropagation();
                    e.preventDefault();
                }
            },

            keyup = function (e) {
                keyState[e.which] = 'r';
                e.stopPropagation();
                e.preventDefault();
            },

            change = function (e) {
                var val = $(e.target).val().trim(),
                    parsedDate = val ? parseInputDate(val) : null;
                setValue(parsedDate);
                e.stopImmediatePropagation();
                return false;
            },

            attachDatePickerElementEvents = function () {
                input.on({
                    'change': change,
                    'blur': options.debug ? '' : hide,
                    'keydown': keydown,
                    'keyup': keyup,
                    'focus': options.allowInputToggle ? show : ''
                });

                if (element.is('input')) {
                    input.on({
                        'focus': show
                    });
                } else if (component) {
                    component.on('click', toggle);
                    component.on('mousedown', false);
                }
            },

            detachDatePickerElementEvents = function () {
                input.off({
                    'change': change,
                    'blur': blur,
                    'keydown': keydown,
                    'keyup': keyup,
                    'focus': options.allowInputToggle ? hide : ''
                });

                if (element.is('input')) {
                    input.off({
                        'focus': show
                    });
                } else if (component) {
                    component.off('click', toggle);
                    component.off('mousedown', false);
                }
            },

            indexGivenDates = function (givenDatesArray) {
                // Store given enabledDates and disabledDates as keys.
                // This way we can check their existence in O(1) time instead of looping through whole array.
                // (for example: options.enabledDates['2014-02-27'] === true)
                var givenDatesIndexed = {};
                $.each(givenDatesArray, function () {
                    var dDate = parseInputDate(this);
                    if (dDate.isValid()) {
                        givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
                    }
                });
                return (Object.keys(givenDatesIndexed).length) ? givenDatesIndexed : false;
            },

            indexGivenHours = function (givenHoursArray) {
                // Store given enabledHours and disabledHours as keys.
                // This way we can check their existence in O(1) time instead of looping through whole array.
                // (for example: options.enabledHours['2014-02-27'] === true)
                var givenHoursIndexed = {};
                $.each(givenHoursArray, function () {
                    givenHoursIndexed[this] = true;
                });
                return (Object.keys(givenHoursIndexed).length) ? givenHoursIndexed : false;
            },

            initFormatting = function () {
                var format = options.format || 'L LT';

                actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput) {
                    var newinput = date.localeData().longDateFormat(formatInput) || formatInput;
                    return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput2) { //temp fix for #740
                        return date.localeData().longDateFormat(formatInput2) || formatInput2;
                    });
                });


                parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
                if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) {
                    parseFormats.push(actualFormat);
                }

                use24Hours = (actualFormat.toLowerCase().indexOf('a') < 1 && actualFormat.replace(/\[.*?\]/g, '').indexOf('h') < 1);

                if (isEnabled('y')) {
                    minViewModeNumber = 2;
                }
                if (isEnabled('M')) {
                    minViewModeNumber = 1;
                }
                if (isEnabled('d')) {
                    minViewModeNumber = 0;
                }

                currentViewMode = Math.max(minViewModeNumber, currentViewMode);

                if (!unset) {
                    setValue(date);
                }
            };

        /********************************************************************************
         *
         * Public API functions
         * =====================
         *
         * Important: Do not expose direct references to private objects or the options
         * object to the outer world. Always return a clone when returning values or make
         * a clone when setting a private variable.
         *
         ********************************************************************************/
        picker.destroy = function () {
            ///<summary>Destroys the widget and removes all attached event listeners</summary>
            hide();
            detachDatePickerElementEvents();
            element.removeData('DateTimePicker');
            element.removeData('date');
        };

        picker.toggle = toggle;

        picker.show = show;

        picker.hide = hide;

        picker.disable = function () {
            ///<summary>Disables the input element, the component is attached to, by adding a disabled="true" attribute to it.
            ///If the widget was visible before that call it is hidden. Possibly emits dp.hide</summary>
            hide();
            if (component && component.hasClass('btn')) {
                component.addClass('disabled');
            }
            input.prop('disabled', true);
            return picker;
        };

        picker.enable = function () {
            ///<summary>Enables the input element, the component is attached to, by removing disabled attribute from it.</summary>
            if (component && component.hasClass('btn')) {
                component.removeClass('disabled');
            }
            input.prop('disabled', false);
            return picker;
        };

        picker.ignoreReadonly = function (ignoreReadonly) {
            if (arguments.length === 0) {
                return options.ignoreReadonly;
            }
            if (typeof ignoreReadonly !== 'boolean') {
                throw new TypeError('ignoreReadonly () expects a boolean parameter');
            }
            options.ignoreReadonly = ignoreReadonly;
            return picker;
        };

        picker.options = function (newOptions) {
            if (arguments.length === 0) {
                return $.extend(true, {}, options);
            }

            if (!(newOptions instanceof Object)) {
                throw new TypeError('options() options parameter should be an object');
            }
            $.extend(true, options, newOptions);
            $.each(options, function (key, value) {
                if (picker[key] !== undefined) {
                    picker[key](value);
                } else {
                    throw new TypeError('option ' + key + ' is not recognized!');
                }
            });
            return picker;
        };

        picker.date = function (newDate) {
            ///<signature helpKeyword="$.fn.datetimepicker.date">
            ///<summary>Returns the component's model current date, a moment object or null if not set.</summary>
            ///<returns type="Moment">date.clone()</returns>
            ///</signature>
            ///<signature>
            ///<summary>Sets the components model current moment to it. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.</summary>
            ///<param name="newDate" locid="$.fn.datetimepicker.date_p:newDate">Takes string, Date, moment, null parameter.</param>
            ///</signature>
            if (arguments.length === 0) {
                if (unset) {
                    return null;
                }
                return date.clone();
            }

            if (newDate !== null && typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError('date() parameter must be one of [null, string, moment or Date]');
            }

            setValue(newDate === null ? null : parseInputDate(newDate));
            return picker;
        };

        picker.format = function (newFormat) {
            ///<summary>test su</summary>
            ///<param name="newFormat">info about para</param>
            ///<returns type="string|boolean">returns foo</returns>
            if (arguments.length === 0) {
                return options.format;
            }

            if ((typeof newFormat !== 'string') && ((typeof newFormat !== 'boolean') || (newFormat !== false))) {
                throw new TypeError('format() expects a string or boolean:false parameter ' + newFormat);
            }

            options.format = newFormat;
            if (actualFormat) {
                initFormatting(); // reinit formatting
            }
            return picker;
        };

        picker.timeZone = function (newZone) {
            if (arguments.length === 0) {
                return options.timeZone;
            }

            if (typeof newZone !== 'string') {
                throw new TypeError('newZone() expects a string parameter');
            }

            options.timeZone = newZone;

            return picker;
        };

        picker.dayViewHeaderFormat = function (newFormat) {
            if (arguments.length === 0) {
                return options.dayViewHeaderFormat;
            }

            if (typeof newFormat !== 'string') {
                throw new TypeError('dayViewHeaderFormat() expects a string parameter');
            }

            options.dayViewHeaderFormat = newFormat;
            return picker;
        };

        picker.extraFormats = function (formats) {
            if (arguments.length === 0) {
                return options.extraFormats;
            }

            if (formats !== false && !(formats instanceof Array)) {
                throw new TypeError('extraFormats() expects an array or false parameter');
            }

            options.extraFormats = formats;
            if (parseFormats) {
                initFormatting(); // reinit formatting
            }
            return picker;
        };

        picker.disabledDates = function (dates) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledDates">
            ///<summary>Returns an array with the currently set disabled dates on the component.</summary>
            ///<returns type="array">options.disabledDates</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.disabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates);
            }

            if (!dates) {
                options.disabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError('disabledDates() expects an array parameter');
            }
            options.disabledDates = indexGivenDates(dates);
            options.enabledDates = false;
            update();
            return picker;
        };

        picker.enabledDates = function (dates) {
            ///<signature helpKeyword="$.fn.datetimepicker.enabledDates">
            ///<summary>Returns an array with the currently set enabled dates on the component.</summary>
            ///<returns type="array">options.enabledDates</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.enabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates);
            }

            if (!dates) {
                options.enabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError('enabledDates() expects an array parameter');
            }
            options.enabledDates = indexGivenDates(dates);
            options.disabledDates = false;
            update();
            return picker;
        };

        picker.daysOfWeekDisabled = function (daysOfWeekDisabled) {
            if (arguments.length === 0) {
                return options.daysOfWeekDisabled.splice(0);
            }

            if ((typeof daysOfWeekDisabled === 'boolean') && !daysOfWeekDisabled) {
                options.daysOfWeekDisabled = false;
                update();
                return picker;
            }

            if (!(daysOfWeekDisabled instanceof Array)) {
                throw new TypeError('daysOfWeekDisabled() expects an array parameter');
            }
            options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function (previousValue, currentValue) {
                currentValue = parseInt(currentValue, 10);
                if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) {
                    return previousValue;
                }
                if (previousValue.indexOf(currentValue) === -1) {
                    previousValue.push(currentValue);
                }
                return previousValue;
            }, []).sort();
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'd')) {
                    date.add(1, 'd');
                    if (tries === 31) {
                        throw 'Tried 31 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };

        picker.maxDate = function (maxDate) {
            if (arguments.length === 0) {
                return options.maxDate ? options.maxDate.clone() : options.maxDate;
            }

            if ((typeof maxDate === 'boolean') && maxDate === false) {
                options.maxDate = false;
                update();
                return picker;
            }

            if (typeof maxDate === 'string') {
                if (maxDate === 'now' || maxDate === 'moment') {
                    maxDate = getMoment();
                }
            }

            var parsedDate = parseInputDate(maxDate);

            if (!parsedDate.isValid()) {
                throw new TypeError('maxDate() Could not parse date parameter: ' + maxDate);
            }
            if (options.minDate && parsedDate.isBefore(options.minDate)) {
                throw new TypeError('maxDate() date parameter is before options.minDate: ' + parsedDate.format(actualFormat));
            }
            options.maxDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) {
                setValue(options.maxDate);
            }
            if (viewDate.isAfter(parsedDate)) {
                viewDate = parsedDate.clone().subtract(options.stepping, 'm');
            }
            update();
            return picker;
        };

        picker.minDate = function (minDate) {
            if (arguments.length === 0) {
                return options.minDate ? options.minDate.clone() : options.minDate;
            }

            if ((typeof minDate === 'boolean') && minDate === false) {
                options.minDate = false;
                update();
                return picker;
            }

            if (typeof minDate === 'string') {
                if (minDate === 'now' || minDate === 'moment') {
                    minDate = getMoment();
                }
            }

            var parsedDate = parseInputDate(minDate);

            if (!parsedDate.isValid()) {
                throw new TypeError('minDate() Could not parse date parameter: ' + minDate);
            }
            if (options.maxDate && parsedDate.isAfter(options.maxDate)) {
                throw new TypeError('minDate() date parameter is after options.maxDate: ' + parsedDate.format(actualFormat));
            }
            options.minDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) {
                setValue(options.minDate);
            }
            if (viewDate.isBefore(parsedDate)) {
                viewDate = parsedDate.clone().add(options.stepping, 'm');
            }
            update();
            return picker;
        };

        picker.defaultDate = function (defaultDate) {
            ///<signature helpKeyword="$.fn.datetimepicker.defaultDate">
            ///<summary>Returns a moment with the options.defaultDate option configuration or false if not set</summary>
            ///<returns type="Moment">date.clone()</returns>
            ///</signature>
            ///<signature>
            ///<summary>Will set the picker's inital date. If a boolean:false value is passed the options.defaultDate parameter is cleared.</summary>
            ///<param name="defaultDate" locid="$.fn.datetimepicker.defaultDate_p:defaultDate">Takes a string, Date, moment, boolean:false</param>
            ///</signature>
            if (arguments.length === 0) {
                return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
            }
            if (!defaultDate) {
                options.defaultDate = false;
                return picker;
            }

            if (typeof defaultDate === 'string') {
                if (defaultDate === 'now' || defaultDate === 'moment') {
                    defaultDate = getMoment();
                } else {
                    defaultDate = getMoment(defaultDate);
                }
            }

            var parsedDate = parseInputDate(defaultDate);
            if (!parsedDate.isValid()) {
                throw new TypeError('defaultDate() Could not parse date parameter: ' + defaultDate);
            }
            if (!isValid(parsedDate)) {
                throw new TypeError('defaultDate() date passed is invalid according to component setup validations');
            }

            options.defaultDate = parsedDate;

            if ((options.defaultDate && options.inline) || input.val().trim() === '') {
                setValue(options.defaultDate);
            }
            return picker;
        };

        picker.locale = function (locale) {
            if (arguments.length === 0) {
                return options.locale;
            }

            if (!moment.localeData(locale)) {
                throw new TypeError('locale() locale ' + locale + ' is not loaded from moment locales!');
            }

            options.locale = locale;
            date.locale(options.locale);
            viewDate.locale(options.locale);

            if (actualFormat) {
                initFormatting(); // reinit formatting
            }
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.stepping = function (stepping) {
            if (arguments.length === 0) {
                return options.stepping;
            }

            stepping = parseInt(stepping, 10);
            if (isNaN(stepping) || stepping < 1) {
                stepping = 1;
            }
            options.stepping = stepping;
            return picker;
        };

        picker.useCurrent = function (useCurrent) {
            var useCurrentOptions = ['year', 'month', 'day', 'hour', 'minute'];
            if (arguments.length === 0) {
                return options.useCurrent;
            }

            if ((typeof useCurrent !== 'boolean') && (typeof useCurrent !== 'string')) {
                throw new TypeError('useCurrent() expects a boolean or string parameter');
            }
            if (typeof useCurrent === 'string' && useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) {
                throw new TypeError('useCurrent() expects a string parameter of ' + useCurrentOptions.join(', '));
            }
            options.useCurrent = useCurrent;
            return picker;
        };

        picker.collapse = function (collapse) {
            if (arguments.length === 0) {
                return options.collapse;
            }

            if (typeof collapse !== 'boolean') {
                throw new TypeError('collapse() expects a boolean parameter');
            }
            if (options.collapse === collapse) {
                return picker;
            }
            options.collapse = collapse;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.icons = function (icons) {
            if (arguments.length === 0) {
                return $.extend({}, options.icons);
            }

            if (!(icons instanceof Object)) {
                throw new TypeError('icons() expects parameter to be an Object');
            }
            $.extend(options.icons, icons);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.tooltips = function (tooltips) {
            if (arguments.length === 0) {
                return $.extend({}, options.tooltips);
            }

            if (!(tooltips instanceof Object)) {
                throw new TypeError('tooltips() expects parameter to be an Object');
            }
            $.extend(options.tooltips, tooltips);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.useStrict = function (useStrict) {
            if (arguments.length === 0) {
                return options.useStrict;
            }

            if (typeof useStrict !== 'boolean') {
                throw new TypeError('useStrict() expects a boolean parameter');
            }
            options.useStrict = useStrict;
            return picker;
        };

        picker.sideBySide = function (sideBySide) {
            if (arguments.length === 0) {
                return options.sideBySide;
            }

            if (typeof sideBySide !== 'boolean') {
                throw new TypeError('sideBySide() expects a boolean parameter');
            }
            options.sideBySide = sideBySide;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.viewMode = function (viewMode) {
            if (arguments.length === 0) {
                return options.viewMode;
            }

            if (typeof viewMode !== 'string') {
                throw new TypeError('viewMode() expects a string parameter');
            }

            if (viewModes.indexOf(viewMode) === -1) {
                throw new TypeError('viewMode() parameter must be one of (' + viewModes.join(', ') + ') value');
            }

            options.viewMode = viewMode;
            currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);

            showMode();
            return picker;
        };

        picker.toolbarPlacement = function (toolbarPlacement) {
            if (arguments.length === 0) {
                return options.toolbarPlacement;
            }

            if (typeof toolbarPlacement !== 'string') {
                throw new TypeError('toolbarPlacement() expects a string parameter');
            }
            if (toolbarPlacements.indexOf(toolbarPlacement) === -1) {
                throw new TypeError('toolbarPlacement() parameter must be one of (' + toolbarPlacements.join(', ') + ') value');
            }
            options.toolbarPlacement = toolbarPlacement;

            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.widgetPositioning = function (widgetPositioning) {
            if (arguments.length === 0) {
                return $.extend({}, options.widgetPositioning);
            }

            if (({}).toString.call(widgetPositioning) !== '[object Object]') {
                throw new TypeError('widgetPositioning() expects an object variable');
            }
            if (widgetPositioning.horizontal) {
                if (typeof widgetPositioning.horizontal !== 'string') {
                    throw new TypeError('widgetPositioning() horizontal variable must be a string');
                }
                widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
                if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) {
                    throw new TypeError('widgetPositioning() expects horizontal parameter to be one of (' + horizontalModes.join(', ') + ')');
                }
                options.widgetPositioning.horizontal = widgetPositioning.horizontal;
            }
            if (widgetPositioning.vertical) {
                if (typeof widgetPositioning.vertical !== 'string') {
                    throw new TypeError('widgetPositioning() vertical variable must be a string');
                }
                widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
                if (verticalModes.indexOf(widgetPositioning.vertical) === -1) {
                    throw new TypeError('widgetPositioning() expects vertical parameter to be one of (' + verticalModes.join(', ') + ')');
                }
                options.widgetPositioning.vertical = widgetPositioning.vertical;
            }
            update();
            return picker;
        };

        picker.calendarWeeks = function (calendarWeeks) {
            if (arguments.length === 0) {
                return options.calendarWeeks;
            }

            if (typeof calendarWeeks !== 'boolean') {
                throw new TypeError('calendarWeeks() expects parameter to be a boolean value');
            }

            options.calendarWeeks = calendarWeeks;
            update();
            return picker;
        };

        picker.showTodayButton = function (showTodayButton) {
            if (arguments.length === 0) {
                return options.showTodayButton;
            }

            if (typeof showTodayButton !== 'boolean') {
                throw new TypeError('showTodayButton() expects a boolean parameter');
            }

            options.showTodayButton = showTodayButton;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.showClear = function (showClear) {
            if (arguments.length === 0) {
                return options.showClear;
            }

            if (typeof showClear !== 'boolean') {
                throw new TypeError('showClear() expects a boolean parameter');
            }

            options.showClear = showClear;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.widgetParent = function (widgetParent) {
            if (arguments.length === 0) {
                return options.widgetParent;
            }

            if (typeof widgetParent === 'string') {
                widgetParent = $(widgetParent);
            }

            if (widgetParent !== null && (typeof widgetParent !== 'string' && !(widgetParent instanceof $))) {
                throw new TypeError('widgetParent() expects a string or a jQuery object parameter');
            }

            options.widgetParent = widgetParent;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.keepOpen = function (keepOpen) {
            if (arguments.length === 0) {
                return options.keepOpen;
            }

            if (typeof keepOpen !== 'boolean') {
                throw new TypeError('keepOpen() expects a boolean parameter');
            }

            options.keepOpen = keepOpen;
            return picker;
        };

        picker.focusOnShow = function (focusOnShow) {
            if (arguments.length === 0) {
                return options.focusOnShow;
            }

            if (typeof focusOnShow !== 'boolean') {
                throw new TypeError('focusOnShow() expects a boolean parameter');
            }

            options.focusOnShow = focusOnShow;
            return picker;
        };

        picker.inline = function (inline) {
            if (arguments.length === 0) {
                return options.inline;
            }

            if (typeof inline !== 'boolean') {
                throw new TypeError('inline() expects a boolean parameter');
            }

            options.inline = inline;
            return picker;
        };

        picker.clear = function () {
            clear();
            return picker;
        };

        picker.keyBinds = function (keyBinds) {
            if (arguments.length === 0) {
                return options.keyBinds;
            }

            options.keyBinds = keyBinds;
            return picker;
        };

        picker.getMoment = function (d) {
            return getMoment(d);
        };

        picker.debug = function (debug) {
            if (typeof debug !== 'boolean') {
                throw new TypeError('debug() expects a boolean parameter');
            }

            options.debug = debug;
            return picker;
        };

        picker.allowInputToggle = function (allowInputToggle) {
            if (arguments.length === 0) {
                return options.allowInputToggle;
            }

            if (typeof allowInputToggle !== 'boolean') {
                throw new TypeError('allowInputToggle() expects a boolean parameter');
            }

            options.allowInputToggle = allowInputToggle;
            return picker;
        };

        picker.showClose = function (showClose) {
            if (arguments.length === 0) {
                return options.showClose;
            }

            if (typeof showClose !== 'boolean') {
                throw new TypeError('showClose() expects a boolean parameter');
            }

            options.showClose = showClose;
            return picker;
        };

        picker.keepInvalid = function (keepInvalid) {
            if (arguments.length === 0) {
                return options.keepInvalid;
            }

            if (typeof keepInvalid !== 'boolean') {
                throw new TypeError('keepInvalid() expects a boolean parameter');
            }
            options.keepInvalid = keepInvalid;
            return picker;
        };

        picker.datepickerInput = function (datepickerInput) {
            if (arguments.length === 0) {
                return options.datepickerInput;
            }

            if (typeof datepickerInput !== 'string') {
                throw new TypeError('datepickerInput() expects a string parameter');
            }

            options.datepickerInput = datepickerInput;
            return picker;
        };

        picker.parseInputDate = function (parseInputDate) {
            if (arguments.length === 0) {
                return options.parseInputDate;
            }

            if (typeof parseInputDate !== 'function') {
                throw new TypeError('parseInputDate() sholud be as function');
            }

            options.parseInputDate = parseInputDate;

            return picker;
        };

        picker.disabledTimeIntervals = function (disabledTimeIntervals) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledTimeIntervals">
            ///<summary>Returns an array with the currently set disabled dates on the component.</summary>
            ///<returns type="array">options.disabledTimeIntervals</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.disabledTimeIntervals_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals);
            }

            if (!disabledTimeIntervals) {
                options.disabledTimeIntervals = false;
                update();
                return picker;
            }
            if (!(disabledTimeIntervals instanceof Array)) {
                throw new TypeError('disabledTimeIntervals() expects an array parameter');
            }
            options.disabledTimeIntervals = disabledTimeIntervals;
            update();
            return picker;
        };

        picker.disabledHours = function (hours) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledHours">
            ///<summary>Returns an array with the currently set disabled hours on the component.</summary>
            ///<returns type="array">options.disabledHours</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledHours if such exist.</summary>
            ///<param name="hours" locid="$.fn.datetimepicker.disabledHours_p:hours">Takes an [ int ] of values and disallows the user to select only from those hours.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours);
            }

            if (!hours) {
                options.disabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError('disabledHours() expects an array parameter');
            }
            options.disabledHours = indexGivenHours(hours);
            options.enabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'h')) {
                    date.add(1, 'h');
                    if (tries === 24) {
                        throw 'Tried 24 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };

        picker.enabledHours = function (hours) {
            ///<signature helpKeyword="$.fn.datetimepicker.enabledHours">
            ///<summary>Returns an array with the currently set enabled hours on the component.</summary>
            ///<returns type="array">options.enabledHours</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledHours if such exist.</summary>
            ///<param name="hours" locid="$.fn.datetimepicker.enabledHours_p:hours">Takes an [ int ] of values and allows the user to select only from those hours.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours);
            }

            if (!hours) {
                options.enabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError('enabledHours() expects an array parameter');
            }
            options.enabledHours = indexGivenHours(hours);
            options.disabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'h')) {
                    date.add(1, 'h');
                    if (tries === 24) {
                        throw 'Tried 24 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };
        /**
         * Returns the component's model current viewDate, a moment object or null if not set. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.
         * @param {Takes string, viewDate, moment, null parameter.} newDate
         * @returns {viewDate.clone()}
         */
        picker.viewDate = function (newDate) {
            if (arguments.length === 0) {
                return viewDate.clone();
            }

            if (!newDate) {
                viewDate = date.clone();
                return picker;
            }

            if (typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError('viewDate() parameter must be one of [string, moment or Date]');
            }

            viewDate = parseInputDate(newDate);
            viewUpdate();
            return picker;
        };

        // initializing element and component attributes
        if (element.is('input')) {
            input = element;
        } else {
            input = element.find(options.datepickerInput);
            if (input.length === 0) {
                input = element.find('input');
            } else if (!input.is('input')) {
                throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
            }
        }

        if (element.hasClass('input-group')) {
            // in case there is more then one 'input-group-addon' Issue #48
            if (element.find('.datepickerbutton').length === 0) {
                component = element.find('.input-group-addon');
            } else {
                component = element.find('.datepickerbutton');
            }
        }

        if (!options.inline && !input.is('input')) {
            throw new Error('Could not initialize DateTimePicker without an input element');
        }

        // Set defaults for date here now instead of in var declaration
        date = getMoment();
        viewDate = date.clone();

        $.extend(true, options, dataToOptions());

        picker.options(options);

        initFormatting();

        attachDatePickerElementEvents();

        if (input.prop('disabled')) {
            picker.disable();
        }
        if (input.is('input') && input.val().trim().length !== 0) {
            setValue(parseInputDate(input.val().trim()));
        }
        else if (options.defaultDate && input.attr('placeholder') === undefined) {
            setValue(options.defaultDate);
        }
        if (options.inline) {
            show();
        }
        return picker;
    };

    /********************************************************************************
     *
     * jQuery plugin constructor and defaults object
     *
     ********************************************************************************/

    /**
    * See (http://jquery.com/).
    * @name jQuery
    * @class
    * See the jQuery Library  (http://jquery.com/) for full details.  This just
    * documents the function and classes that are added to jQuery by this plug-in.
    */
    /**
     * See (http://jquery.com/)
     * @name fn
     * @class
     * See the jQuery Library  (http://jquery.com/) for full details.  This just
     * documents the function and classes that are added to jQuery by this plug-in.
     * @memberOf jQuery
     */
    /**
     * Show comments
     * @class datetimepicker
     * @memberOf jQuery.fn
     */
    $.fn.datetimepicker = function (options) {
        options = options || {};

        var args = Array.prototype.slice.call(arguments, 1),
            isInstance = true,
            thisMethods = ['destroy', 'hide', 'show', 'toggle'],
            returnValue;

        if (typeof options === 'object') {
            return this.each(function () {
                var $this = $(this),
                    _options;
                if (!$this.data('DateTimePicker')) {
                    // create a private copy of the defaults object
                    _options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
                    $this.data('DateTimePicker', dateTimePicker($this, _options));
                }
            });
        } else if (typeof options === 'string') {
            this.each(function () {
                var $this = $(this),
                    instance = $this.data('DateTimePicker');
                if (!instance) {
                    throw new Error('bootstrap-datetimepicker("' + options + '") method was called on an element that is not using DateTimePicker');
                }

                returnValue = instance[options].apply(instance, args);
                isInstance = returnValue === instance;
            });

            if (isInstance || $.inArray(options, thisMethods) > -1) {
                return this;
            }

            return returnValue;
        }

        throw new TypeError('Invalid arguments for DateTimePicker: ' + options);
    };

    $.fn.datetimepicker.defaults = {
        timeZone: '',
        format: false,
        dayViewHeaderFormat: 'MMMM YYYY',
        extraFormats: false,
        stepping: 1,
        minDate: false,
        maxDate: false,
        useCurrent: true,
        collapse: true,
        locale: moment.locale(),
        defaultDate: false,
        disabledDates: false,
        enabledDates: false,
        icons: {
            time: 'glyphicon glyphicon-time',
            date: 'glyphicon glyphicon-calendar',
            up: 'glyphicon glyphicon-chevron-up',
            down: 'glyphicon glyphicon-chevron-down',
            previous: 'glyphicon glyphicon-chevron-left',
            next: 'glyphicon glyphicon-chevron-right',
            today: 'glyphicon glyphicon-screenshot',
            clear: 'glyphicon glyphicon-trash',
            close: 'glyphicon glyphicon-remove'
        },
        tooltips: {
            today: 'Go to today',
            clear: 'Clear selection',
            close: 'Close the picker',
            selectMonth: 'Select Month',
            prevMonth: 'Previous Month',
            nextMonth: 'Next Month',
            selectYear: 'Select Year',
            prevYear: 'Previous Year',
            nextYear: 'Next Year',
            selectDecade: 'Select Decade',
            prevDecade: 'Previous Decade',
            nextDecade: 'Next Decade',
            prevCentury: 'Previous Century',
            nextCentury: 'Next Century',
            pickHour: 'Pick Hour',
            incrementHour: 'Increment Hour',
            decrementHour: 'Decrement Hour',
            pickMinute: 'Pick Minute',
            incrementMinute: 'Increment Minute',
            decrementMinute: 'Decrement Minute',
            pickSecond: 'Pick Second',
            incrementSecond: 'Increment Second',
            decrementSecond: 'Decrement Second',
            togglePeriod: 'Toggle Period',
            selectTime: 'Select Time'
        },
        useStrict: false,
        sideBySide: false,
        daysOfWeekDisabled: false,
        calendarWeeks: false,
        viewMode: 'days',
        toolbarPlacement: 'default',
        showTodayButton: false,
        showClear: false,
        showClose: false,
        widgetPositioning: {
            horizontal: 'auto',
            vertical: 'auto'
        },
        widgetParent: null,
        ignoreReadonly: false,
        keepOpen: false,
        focusOnShow: true,
        inline: false,
        keepInvalid: false,
        datepickerInput: '.datepickerinput',
        keyBinds: {
            up: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(7, 'd'));
                } else {
                    this.date(d.clone().add(this.stepping(), 'm'));
                }
            },
            down: function (widget) {
                if (!widget) {
                    this.show();
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(7, 'd'));
                } else {
                    this.date(d.clone().subtract(this.stepping(), 'm'));
                }
            },
            'control up': function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'y'));
                } else {
                    this.date(d.clone().add(1, 'h'));
                }
            },
            'control down': function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'y'));
                } else {
                    this.date(d.clone().subtract(1, 'h'));
                }
            },
            left: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'd'));
                }
            },
            right: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'd'));
                }
            },
            pageUp: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'M'));
                }
            },
            pageDown: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'M'));
                }
            },
            enter: function () {
                this.hide();
            },
            escape: function () {
                this.hide();
            },
            //tab: function (widget) { //this break the flow of the form. disabling for now
            //    var toggle = widget.find('.picker-switch a[data-action="togglePicker"]');
            //    if(toggle.length > 0) toggle.click();
            //},
            'control space': function (widget) {
                if (!widget) {
                    return;
                }
                if (widget.find('.timepicker').is(':visible')) {
                    widget.find('.btn[data-action="togglePeriod"]').click();
                }
            },
            t: function () {
                this.date(this.getMoment());
            },
            'delete': function () {
                this.clear();
            }
        },
        debug: false,
        allowInputToggle: false,
        disabledTimeIntervals: false,
        disabledHours: false,
        enabledHours: false,
        viewDate: false
    };

    return $.fn.datetimepicker;
}));


/***/ }),

/***/ "./node_modules/just-extend/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/just-extend/index.esm.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ objectExtend; }
/* harmony export */ });
var objectExtend = extend;

/*
  var obj = {a: 3, b: 5};
  extend(obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 4, b: 5, c: 8}

  var obj = {a: 3, b: 5};
  extend({}, obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 3, b: 5}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3, 4]}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(true, obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3]}

  extend({a: 4, b: 5}); // {a: 4, b: 5}
  extend({a: 4, b: 5}, 3); {a: 4, b: 5}
  extend({a: 4, b: 5}, true); {a: 4, b: 5}
  extend('hello', {a: 4, b: 5}); // throws
  extend(3, {a: 4, b: 5}); // throws
*/

function extend(/* [deep], obj1, obj2, [objn] */) {
  var args = [].slice.call(arguments);
  var deep = false;
  if (typeof args[0] == 'boolean') {
    deep = args.shift();
  }
  var result = args[0];
  if (isUnextendable(result)) {
    throw new Error('extendee must be an object');
  }
  var extenders = args.slice(1);
  var len = extenders.length;
  for (var i = 0; i < len; i++) {
    var extender = extenders[i];
    for (var key in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, key)) {
        var value = extender[key];
        if (deep && isCloneable(value)) {
          var base = Array.isArray(value) ? [] : {};
          result[key] = extend(
            true,
            Object.prototype.hasOwnProperty.call(result, key) && !isUnextendable(result[key])
              ? result[key]
              : base,
            value
          );
        } else {
          result[key] = value;
        }
      }
    }
  }
  return result;
}

function isCloneable(obj) {
  return Array.isArray(obj) || {}.toString.call(obj) == '[object Object]';
}

function isUnextendable(val) {
  return !val || (typeof val != 'object' && typeof val != 'function');
}




/***/ }),

/***/ "./node_modules/dropzone/dist/dropzone.mjs":
/*!*************************************************!*\
  !*** ./node_modules/dropzone/dist/dropzone.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dropzone: function() { return /* binding */ $3ed269f2f0fb224b$export$2e2bcd8739ae039; },
/* harmony export */   "default": function() { return /* binding */ $3ed269f2f0fb224b$export$2e2bcd8739ae039; }
/* harmony export */ });
/* harmony import */ var just_extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! just-extend */ "./node_modules/just-extend/index.esm.js");
/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

class $4040acfd8584338d$export$2e2bcd8739ae039 {
    // Add an event listener for given event
    on(event, fn) {
        this._callbacks = this._callbacks || {
        };
        // Create namespace for this event
        if (!this._callbacks[event]) this._callbacks[event] = [];
        this._callbacks[event].push(fn);
        return this;
    }
    emit(event, ...args) {
        this._callbacks = this._callbacks || {
        };
        let callbacks = this._callbacks[event];
        if (callbacks) for (let callback of callbacks)callback.apply(this, args);
        // trigger a corresponding DOM event
        if (this.element) this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
            args: args
        }));
        return this;
    }
    makeEvent(eventName, detail) {
        let params = {
            bubbles: true,
            cancelable: true,
            detail: detail
        };
        if (typeof window.CustomEvent === "function") return new CustomEvent(eventName, params);
        else {
            // IE 11 support
            // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
            var evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
            return evt;
        }
    }
    // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.
    off(event, fn) {
        if (!this._callbacks || arguments.length === 0) {
            this._callbacks = {
            };
            return this;
        }
        // specific event
        let callbacks = this._callbacks[event];
        if (!callbacks) return this;
        // remove all handlers
        if (arguments.length === 1) {
            delete this._callbacks[event];
            return this;
        }
        // remove specific handler
        for(let i = 0; i < callbacks.length; i++){
            let callback = callbacks[i];
            if (callback === fn) {
                callbacks.splice(i, 1);
                break;
            }
        }
        return this;
    }
}



var $fd6031f88dce2e32$exports = {};
$fd6031f88dce2e32$exports = "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail=\"\"></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size=\"\"></span></div>\n    <div class=\"dz-filename\"><span data-dz-name=\"\"></span></div>\n  </div>\n  <div class=\"dz-progress\">\n    <span class=\"dz-upload\" data-dz-uploadprogress=\"\"></span>\n  </div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage=\"\"></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54\" height=\"54\" viewBox=\"0 0 54 54\" fill=\"white\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M10.2071 29.7929L14.2929 25.7071C14.6834 25.3166 15.3166 25.3166 15.7071 25.7071L21.2929 31.2929C21.6834 31.6834 22.3166 31.6834 22.7071 31.2929L38.2929 15.7071C38.6834 15.3166 39.3166 15.3166 39.7071 15.7071L43.7929 19.7929C44.1834 20.1834 44.1834 20.8166 43.7929 21.2071L22.7071 42.2929C22.3166 42.6834 21.6834 42.6834 21.2929 42.2929L10.2071 31.2071C9.81658 30.8166 9.81658 30.1834 10.2071 29.7929Z\"></path>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54\" height=\"54\" viewBox=\"0 0 54 54\" fill=\"white\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M26.2929 20.2929L19.2071 13.2071C18.8166 12.8166 18.1834 12.8166 17.7929 13.2071L13.2071 17.7929C12.8166 18.1834 12.8166 18.8166 13.2071 19.2071L20.2929 26.2929C20.6834 26.6834 20.6834 27.3166 20.2929 27.7071L13.2071 34.7929C12.8166 35.1834 12.8166 35.8166 13.2071 36.2071L17.7929 40.7929C18.1834 41.1834 18.8166 41.1834 19.2071 40.7929L26.2929 33.7071C26.6834 33.3166 27.3166 33.3166 27.7071 33.7071L34.7929 40.7929C35.1834 41.1834 35.8166 41.1834 36.2071 40.7929L40.7929 36.2071C41.1834 35.8166 41.1834 35.1834 40.7929 34.7929L33.7071 27.7071C33.3166 27.3166 33.3166 26.6834 33.7071 26.2929L40.7929 19.2071C41.1834 18.8166 41.1834 18.1834 40.7929 17.7929L36.2071 13.2071C35.8166 12.8166 35.1834 12.8166 34.7929 13.2071L27.7071 20.2929C27.3166 20.6834 26.6834 20.6834 26.2929 20.2929Z\"></path>\n    </svg>\n  </div>\n</div>\n";


let $4ca367182776f80b$var$defaultOptions = {
    /**
   * Has to be specified on elements other than form (or when the form doesn't
   * have an `action` attribute).
   *
   * You can also provide a function that will be called with `files` and
   * `dataBlocks`  and must return the url as string.
   */ url: null,
    /**
   * Can be changed to `"put"` if necessary. You can also provide a function
   * that will be called with `files` and must return the method (since `v3.12.0`).
   */ method: "post",
    /**
   * Will be set on the XHRequest.
   */ withCredentials: false,
    /**
   * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
   * If set to null or 0, no timeout is going to be set.
   */ timeout: null,
    /**
   * How many file uploads to process in parallel (See the
   * Enqueuing file uploads documentation section for more info)
   */ parallelUploads: 2,
    /**
   * Whether to send multiple files in one request. If
   * this it set to true, then the fallback file input element will
   * have the `multiple` attribute as well. This option will
   * also trigger additional events (like `processingmultiple`). See the events
   * documentation section for more information.
   */ uploadMultiple: false,
    /**
   * Whether you want files to be uploaded in chunks to your server. This can't be
   * used in combination with `uploadMultiple`.
   *
   * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
   */ chunking: false,
    /**
   * If `chunking` is enabled, this defines whether **every** file should be chunked,
   * even if the file size is below chunkSize. This means, that the additional chunk
   * form data will be submitted and the `chunksUploaded` callback will be invoked.
   */ forceChunking: false,
    /**
   * If `chunking` is `true`, then this defines the chunk size in bytes.
   */ chunkSize: 2097152,
    /**
   * If `true`, the individual chunks of a file are being uploaded simultaneously.
   */ parallelChunkUploads: false,
    /**
   * Whether a chunk should be retried if it fails.
   */ retryChunks: false,
    /**
   * If `retryChunks` is true, how many times should it be retried.
   */ retryChunksLimit: 3,
    /**
   * The maximum filesize (in MiB) that is allowed to be uploaded.
   */ maxFilesize: 256,
    /**
   * The name of the file param that gets transferred.
   * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
   * Dropzone will append `[]` to the name.
   */ paramName: "file",
    /**
   * Whether thumbnails for images should be generated
   */ createImageThumbnails: true,
    /**
   * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
   */ maxThumbnailFilesize: 10,
    /**
   * If `null`, the ratio of the image will be used to calculate it.
   */ thumbnailWidth: 120,
    /**
   * The same as `thumbnailWidth`. If both are null, images will not be resized.
   */ thumbnailHeight: 120,
    /**
   * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
   * Can be either `contain` or `crop`.
   */ thumbnailMethod: "crop",
    /**
   * If set, images will be resized to these dimensions before being **uploaded**.
   * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
   * ratio of the file will be preserved.
   *
   * The `options.transformFile` function uses these options, so if the `transformFile` function
   * is overridden, these options don't do anything.
   */ resizeWidth: null,
    /**
   * See `resizeWidth`.
   */ resizeHeight: null,
    /**
   * The mime type of the resized image (before it gets uploaded to the server).
   * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
   * See `resizeWidth` for more information.
   */ resizeMimeType: null,
    /**
   * The quality of the resized images. See `resizeWidth`.
   */ resizeQuality: 0.8,
    /**
   * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
   * Can be either `contain` or `crop`.
   */ resizeMethod: "contain",
    /**
   * The base that is used to calculate the **displayed** filesize. You can
   * change this to 1024 if you would rather display kibibytes, mebibytes,
   * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
   * not `1 kilobyte`. You can change this to `1024` if you don't care about
   * validity.
   */ filesizeBase: 1000,
    /**
   * If not `null` defines how many files this Dropzone handles. If it exceeds,
   * the event `maxfilesexceeded` will be called. The dropzone element gets the
   * class `dz-max-files-reached` accordingly so you can provide visual
   * feedback.
   */ maxFiles: null,
    /**
   * An optional object to send additional headers to the server. Eg:
   * `{ "My-Awesome-Header": "header value" }`
   */ headers: null,
    /**
   * Should the default headers be set or not?
   * Accept: application/json <- for requesting json response
   * Cache-Control: no-cache <- Request shouldnt be cached
   * X-Requested-With: XMLHttpRequest <- We sent the request via XMLHttpRequest
   */ defaultHeaders: true,
    /**
   * If `true`, the dropzone element itself will be clickable, if `false`
   * nothing will be clickable.
   *
   * You can also pass an HTML element, a CSS selector (for multiple elements)
   * or an array of those. In that case, all of those elements will trigger an
   * upload when clicked.
   */ clickable: true,
    /**
   * Whether hidden files in directories should be ignored.
   */ ignoreHiddenFiles: true,
    /**
   * The default implementation of `accept` checks the file's mime type or
   * extension against this list. This is a comma separated list of mime
   * types or file extensions.
   *
   * Eg.: `image/*,application/pdf,.psd`
   *
   * If the Dropzone is `clickable` this option will also be used as
   * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
   * parameter on the hidden file input as well.
   */ acceptedFiles: null,
    /**
   * **Deprecated!**
   * Use acceptedFiles instead.
   */ acceptedMimeTypes: null,
    /**
   * If false, files will be added to the queue but the queue will not be
   * processed automatically.
   * This can be useful if you need some additional user input before sending
   * files (or if you want want all files sent at once).
   * If you're ready to send the file simply call `myDropzone.processQueue()`.
   *
   * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
   * section for more information.
   */ autoProcessQueue: true,
    /**
   * If false, files added to the dropzone will not be queued by default.
   * You'll have to call `enqueueFile(file)` manually.
   */ autoQueue: true,
    /**
   * If `true`, this will add a link to every file preview to remove or cancel (if
   * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
   * and `dictRemoveFile` options are used for the wording.
   */ addRemoveLinks: false,
    /**
   * Defines where to display the file previews – if `null` the
   * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
   * selector. The element should have the `dropzone-previews` class so
   * the previews are displayed properly.
   */ previewsContainer: null,
    /**
   * Set this to `true` if you don't want previews to be shown.
   */ disablePreviews: false,
    /**
   * This is the element the hidden input field (which is used when clicking on the
   * dropzone to trigger file selection) will be appended to. This might
   * be important in case you use frameworks to switch the content of your page.
   *
   * Can be a selector string, or an element directly.
   */ hiddenInputContainer: "body",
    /**
   * If null, no capture type will be specified
   * If camera, mobile devices will skip the file selection and choose camera
   * If microphone, mobile devices will skip the file selection and choose the microphone
   * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
   * On apple devices multiple must be set to false.  AcceptedFiles may need to
   * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
   */ capture: null,
    /**
   * **Deprecated**. Use `renameFile` instead.
   */ renameFilename: null,
    /**
   * A function that is invoked before the file is uploaded to the server and renames the file.
   * This function gets the `File` as argument and can use the `file.name`. The actual name of the
   * file that gets used during the upload can be accessed through `file.upload.filename`.
   */ renameFile: null,
    /**
   * If `true` the fallback will be forced. This is very useful to test your server
   * implementations first and make sure that everything works as
   * expected without dropzone if you experience problems, and to test
   * how your fallbacks will look.
   */ forceFallback: false,
    /**
   * The text used before any files are dropped.
   */ dictDefaultMessage: "Drop files here to upload",
    /**
   * The text that replaces the default message text it the browser is not supported.
   */ dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
    /**
   * The text that will be added before the fallback form.
   * If you provide a  fallback element yourself, or if this option is `null` this will
   * be ignored.
   */ dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
    /**
   * If the filesize is too big.
   * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
   */ dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
    /**
   * If the file doesn't match the file type.
   */ dictInvalidFileType: "You can't upload files of this type.",
    /**
   * If the server response was invalid.
   * `{{statusCode}}` will be replaced with the servers status code.
   */ dictResponseError: "Server responded with {{statusCode}} code.",
    /**
   * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
   */ dictCancelUpload: "Cancel upload",
    /**
   * The text that is displayed if an upload was manually canceled
   */ dictUploadCanceled: "Upload canceled.",
    /**
   * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
   */ dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
    /**
   * If `addRemoveLinks` is true, the text to be used to remove a file.
   */ dictRemoveFile: "Remove file",
    /**
   * If this is not null, then the user will be prompted before removing a file.
   */ dictRemoveFileConfirmation: null,
    /**
   * Displayed if `maxFiles` is st and exceeded.
   * The string `{{maxFiles}}` will be replaced by the configuration value.
   */ dictMaxFilesExceeded: "You can not upload any more files.",
    /**
   * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
   * `b` for bytes.
   */ dictFileSizeUnits: {
        tb: "TB",
        gb: "GB",
        mb: "MB",
        kb: "KB",
        b: "b"
    },
    /**
   * Called when dropzone initialized
   * You can add event listeners here
   */ init () {
    },
    /**
   * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
   * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
   * of a function, this needs to return a map.
   *
   * The default implementation does nothing for normal uploads, but adds relevant information for
   * chunked uploads.
   *
   * This is the same as adding hidden input fields in the form element.
   */ params (files, xhr, chunk) {
        if (chunk) return {
            dzuuid: chunk.file.upload.uuid,
            dzchunkindex: chunk.index,
            dztotalfilesize: chunk.file.size,
            dzchunksize: this.options.chunkSize,
            dztotalchunkcount: chunk.file.upload.totalChunkCount,
            dzchunkbyteoffset: chunk.index * this.options.chunkSize
        };
    },
    /**
   * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
   * and a `done` function as parameters.
   *
   * If the done function is invoked without arguments, the file is "accepted" and will
   * be processed. If you pass an error message, the file is rejected, and the error
   * message will be displayed.
   * This function will not be called if the file is too big or doesn't match the mime types.
   */ accept (file, done) {
        return done();
    },
    /**
   * The callback that will be invoked when all chunks have been uploaded for a file.
   * It gets the file for which the chunks have been uploaded as the first parameter,
   * and the `done` function as second. `done()` needs to be invoked when everything
   * needed to finish the upload process is done.
   */ chunksUploaded: function(file, done) {
        done();
    },
    /**
   * Sends the file as binary blob in body instead of form data.
   * If this is set, the `params` option will be ignored.
   * It's an error to set this to `true` along with `uploadMultiple` since
   * multiple files cannot be in a single binary body.
   */ binaryBody: false,
    /**
   * Gets called when the browser is not supported.
   * The default implementation shows the fallback input field and adds
   * a text.
   */ fallback () {
        // This code should pass in IE7... :(
        let messageElement;
        this.element.className = `${this.element.className} dz-browser-not-supported`;
        for (let child of this.element.getElementsByTagName("div"))if (/(^| )dz-message($| )/.test(child.className)) {
            messageElement = child;
            child.className = "dz-message"; // Removes the 'dz-default' class
            break;
        }
        if (!messageElement) {
            messageElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement('<div class="dz-message"><span></span></div>');
            this.element.appendChild(messageElement);
        }
        let span = messageElement.getElementsByTagName("span")[0];
        if (span) {
            if (span.textContent != null) span.textContent = this.options.dictFallbackMessage;
            else if (span.innerText != null) span.innerText = this.options.dictFallbackMessage;
        }
        return this.element.appendChild(this.getFallbackForm());
    },
    /**
   * Gets called to calculate the thumbnail dimensions.
   *
   * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
   *
   *  - `srcWidth` & `srcHeight` (required)
   *  - `trgWidth` & `trgHeight` (required)
   *  - `srcX` & `srcY` (optional, default `0`)
   *  - `trgX` & `trgY` (optional, default `0`)
   *
   * Those values are going to be used by `ctx.drawImage()`.
   */ resize (file, width, height, resizeMethod) {
        let info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
        };
        let srcRatio = file.width / file.height;
        // Automatically calculate dimensions if not specified
        if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
        } else if (width == null) width = height * srcRatio;
        else if (height == null) height = width / srcRatio;
        // Make sure images aren't upscaled
        width = Math.min(width, info.srcWidth);
        height = Math.min(height, info.srcHeight);
        let trgRatio = width / height;
        if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === "crop") {
                if (srcRatio > trgRatio) {
                    info.srcHeight = file.height;
                    info.srcWidth = info.srcHeight * trgRatio;
                } else {
                    info.srcWidth = file.width;
                    info.srcHeight = info.srcWidth / trgRatio;
                }
            } else if (resizeMethod === "contain") {
                // Method 'contain'
                if (srcRatio > trgRatio) height = width / srcRatio;
                else width = height * srcRatio;
            } else throw new Error(`Unknown resizeMethod '${resizeMethod}'`);
        }
        info.srcX = (file.width - info.srcWidth) / 2;
        info.srcY = (file.height - info.srcHeight) / 2;
        info.trgWidth = width;
        info.trgHeight = height;
        return info;
    },
    /**
   * Can be used to transform the file (for example, resize an image if necessary).
   *
   * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
   * images according to those dimensions.
   *
   * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
   * to be invoked with the file when the transformation is done.
   */ transformFile (file, done) {
        if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
        else return done(file);
    },
    /**
   * A string that contains the template used for each dropped
   * file. Change it to fulfill your needs but make sure to properly
   * provide all elements.
   *
   * If you want to use an actual HTML element instead of providing a String
   * as a config option, you could create a div with the id `tpl`,
   * put the template inside it and provide the element like this:
   *
   *     document
   *       .querySelector('#tpl')
   *       .innerHTML
   *
   */ previewTemplate: (/*@__PURE__*/$parcel$interopDefault($fd6031f88dce2e32$exports)),
    /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */ // Those are self explanatory and simply concern the DragnDrop.
    drop (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragstart (e) {
    },
    dragend (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragenter (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragover (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragleave (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    paste (e) {
    },
    // Called whenever there are no files left in the dropzone anymore, and the
    // dropzone should be displayed as if in the initial state.
    reset () {
        return this.element.classList.remove("dz-started");
    },
    // Called when a file is added to the queue
    // Receives `file`
    addedfile (file) {
        if (this.element === this.previewsContainer) this.element.classList.add("dz-started");
        if (this.previewsContainer && !this.options.disablePreviews) {
            file.previewElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility
            this.previewsContainer.appendChild(file.previewElement);
            for (var node of file.previewElement.querySelectorAll("[data-dz-name]"))node.textContent = file.name;
            for (node of file.previewElement.querySelectorAll("[data-dz-size]"))node.innerHTML = this.filesize(file.size);
            if (this.options.addRemoveLinks) {
                file._removeLink = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<a class="dz-remove" href="javascript:undefined;" data-dz-remove>${this.options.dictRemoveFile}</a>`);
                file.previewElement.appendChild(file._removeLink);
            }
            let removeFileEvent = (e)=>{
                e.preventDefault();
                e.stopPropagation();
                if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictCancelUploadConfirmation, ()=>this.removeFile(file)
                );
                else {
                    if (this.options.dictRemoveFileConfirmation) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictRemoveFileConfirmation, ()=>this.removeFile(file)
                    );
                    else return this.removeFile(file);
                }
            };
            for (let removeLink of file.previewElement.querySelectorAll("[data-dz-remove]"))removeLink.addEventListener("click", removeFileEvent);
        }
    },
    // Called whenever a file is removed.
    removedfile (file) {
        if (file.previewElement != null && file.previewElement.parentNode != null) file.previewElement.parentNode.removeChild(file.previewElement);
        return this._updateMaxFilesReachedClass();
    },
    // Called when a thumbnail has been generated
    // Receives `file` and `dataUrl`
    thumbnail (file, dataUrl) {
        if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            for (let thumbnailElement of file.previewElement.querySelectorAll("[data-dz-thumbnail]")){
                thumbnailElement.alt = file.name;
                thumbnailElement.src = dataUrl;
            }
            return setTimeout(()=>file.previewElement.classList.add("dz-image-preview")
            , 1);
        }
    },
    // Called whenever an error occurs
    // Receives `file` and `message`
    error (file, message) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "string" && message.error) message = message.error;
            for (let node of file.previewElement.querySelectorAll("[data-dz-errormessage]"))node.textContent = message;
        }
    },
    errormultiple () {
    },
    // Called when a file gets processed. Since there is a cue, not all added
    // files are processed immediately.
    // Receives `file`
    processing (file) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) return file._removeLink.innerHTML = this.options.dictCancelUpload;
        }
    },
    processingmultiple () {
    },
    // Called whenever the upload progress gets updated.
    // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
    // To get the total number of bytes of the file, use `file.size`
    uploadprogress (file, progress, bytesSent) {
        if (file.previewElement) for (let node of file.previewElement.querySelectorAll("[data-dz-uploadprogress]"))node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = `${progress}%`;
    },
    // Called whenever the total upload progress gets updated.
    // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
    totaluploadprogress () {
    },
    // Called just before the file is sent. Gets the `xhr` object as second
    // parameter, so you can modify it (for example to add a CSRF token) and a
    // `formData` object to add additional information.
    sending () {
    },
    sendingmultiple () {
    },
    // When the complete upload is finished and successful
    // Receives `file`
    success (file) {
        if (file.previewElement) return file.previewElement.classList.add("dz-success");
    },
    successmultiple () {
    },
    // When the upload is canceled.
    canceled (file) {
        return this.emit("error", file, this.options.dictUploadCanceled);
    },
    canceledmultiple () {
    },
    // When the upload is finished, either with success or an error.
    // Receives `file`
    complete (file) {
        if (file._removeLink) file._removeLink.innerHTML = this.options.dictRemoveFile;
        if (file.previewElement) return file.previewElement.classList.add("dz-complete");
    },
    completemultiple () {
    },
    maxfilesexceeded () {
    },
    maxfilesreached () {
    },
    queuecomplete () {
    },
    addedfiles () {
    }
};
var $4ca367182776f80b$export$2e2bcd8739ae039 = $4ca367182776f80b$var$defaultOptions;


class $3ed269f2f0fb224b$export$2e2bcd8739ae039 extends $4040acfd8584338d$export$2e2bcd8739ae039 {
    static initClass() {
        // Exposing the emitter class, mainly for tests
        this.prototype.Emitter = $4040acfd8584338d$export$2e2bcd8739ae039;
        /*
     This is a list of all available events you can register on a dropzone object.

     You can register an event handler like this:

     dropzone.on("dragEnter", function() { });

     */ this.prototype.events = [
            "drop",
            "dragstart",
            "dragend",
            "dragenter",
            "dragover",
            "dragleave",
            "addedfile",
            "addedfiles",
            "removedfile",
            "thumbnail",
            "error",
            "errormultiple",
            "processing",
            "processingmultiple",
            "uploadprogress",
            "totaluploadprogress",
            "sending",
            "sendingmultiple",
            "success",
            "successmultiple",
            "canceled",
            "canceledmultiple",
            "complete",
            "completemultiple",
            "reset",
            "maxfilesexceeded",
            "maxfilesreached",
            "queuecomplete", 
        ];
        this.prototype._thumbnailQueue = [];
        this.prototype._processingThumbnail = false;
    }
    // Returns all files that have been accepted
    getAcceptedFiles() {
        return this.files.filter((file)=>file.accepted
        ).map((file)=>file
        );
    }
    // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.
    getRejectedFiles() {
        return this.files.filter((file)=>!file.accepted
        ).map((file)=>file
        );
    }
    getFilesWithStatus(status) {
        return this.files.filter((file)=>file.status === status
        ).map((file)=>file
        );
    }
    // Returns all files that are in the queue
    getQueuedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED);
    }
    getUploadingFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING);
    }
    getAddedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED);
    }
    // Files that are either queued or uploading
    getActiveFiles() {
        return this.files.filter((file)=>file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED
        ).map((file)=>file
        );
    }
    // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.
    init() {
        // In case it isn't set already
        if (this.element.tagName === "form") this.element.setAttribute("enctype", "multipart/form-data");
        if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) this.element.appendChild($3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<div class="dz-default dz-message"><button class="dz-button" type="button">${this.options.dictDefaultMessage}</button></div>`));
        if (this.clickableElements.length) {
            let setupHiddenFileInput = ()=>{
                if (this.hiddenFileInput) this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
                this.hiddenFileInput = document.createElement("input");
                this.hiddenFileInput.setAttribute("type", "file");
                if (this.options.maxFiles === null || this.options.maxFiles > 1) this.hiddenFileInput.setAttribute("multiple", "multiple");
                this.hiddenFileInput.className = "dz-hidden-input";
                if (this.options.acceptedFiles !== null) this.hiddenFileInput.setAttribute("accept", this.options.acceptedFiles);
                if (this.options.capture !== null) this.hiddenFileInput.setAttribute("capture", this.options.capture);
                // Making sure that no one can "tab" into this field.
                this.hiddenFileInput.setAttribute("tabindex", "-1");
                // Not setting `display="none"` because some browsers don't accept clicks
                // on elements that aren't displayed.
                this.hiddenFileInput.style.visibility = "hidden";
                this.hiddenFileInput.style.position = "absolute";
                this.hiddenFileInput.style.top = "0";
                this.hiddenFileInput.style.left = "0";
                this.hiddenFileInput.style.height = "0";
                this.hiddenFileInput.style.width = "0";
                $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.hiddenInputContainer, "hiddenInputContainer").appendChild(this.hiddenFileInput);
                this.hiddenFileInput.addEventListener("change", ()=>{
                    let { files: files  } = this.hiddenFileInput;
                    if (files.length) for (let file of files)this.addFile(file);
                    this.emit("addedfiles", files);
                    setupHiddenFileInput();
                });
            };
            setupHiddenFileInput();
        }
        this.URL = window.URL !== null ? window.URL : window.webkitURL;
        // Setup all event listeners on the Dropzone object itself.
        // They're not in @setupEventListeners() because they shouldn't be removed
        // again when the dropzone gets disabled.
        for (let eventName of this.events)this.on(eventName, this.options[eventName]);
        this.on("uploadprogress", ()=>this.updateTotalUploadProgress()
        );
        this.on("removedfile", ()=>this.updateTotalUploadProgress()
        );
        this.on("canceled", (file)=>this.emit("complete", file)
        );
        // Emit a `queuecomplete` event if all files finished uploading.
        this.on("complete", (file)=>{
            if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0) // This needs to be deferred so that `queuecomplete` really triggers after `complete`
            return setTimeout(()=>this.emit("queuecomplete")
            , 0);
        });
        const containsFiles = function(e) {
            if (e.dataTransfer.types) // Because e.dataTransfer.types is an Object in
            // IE, we need to iterate like this instead of
            // using e.dataTransfer.types.some()
            for(var i = 0; i < e.dataTransfer.types.length; i++){
                if (e.dataTransfer.types[i] === "Files") return true;
            }
            return false;
        };
        let noPropagation = function(e) {
            // If there are no files, we don't want to stop
            // propagation so we don't interfere with other
            // drag and drop behaviour.
            if (!containsFiles(e)) return;
            e.stopPropagation();
            if (e.preventDefault) return e.preventDefault();
            else return e.returnValue = false;
        };
        // Create the listeners
        this.listeners = [
            {
                element: this.element,
                events: {
                    dragstart: (e)=>{
                        return this.emit("dragstart", e);
                    },
                    dragenter: (e)=>{
                        noPropagation(e);
                        return this.emit("dragenter", e);
                    },
                    dragover: (e)=>{
                        // Makes it possible to drag files from chrome's download bar
                        // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                        // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                        let efct;
                        try {
                            efct = e.dataTransfer.effectAllowed;
                        } catch (error) {
                        }
                        e.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
                        noPropagation(e);
                        return this.emit("dragover", e);
                    },
                    dragleave: (e)=>{
                        return this.emit("dragleave", e);
                    },
                    drop: (e)=>{
                        noPropagation(e);
                        return this.drop(e);
                    },
                    dragend: (e)=>{
                        return this.emit("dragend", e);
                    }
                }
            }, 
        ];
        this.clickableElements.forEach((clickableElement)=>{
            return this.listeners.push({
                element: clickableElement,
                events: {
                    click: (evt)=>{
                        // Only the actual dropzone or the message element should trigger file selection
                        if (clickableElement !== this.element || evt.target === this.element || $3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside(evt.target, this.element.querySelector(".dz-message"))) this.hiddenFileInput.click(); // Forward the click
                        return true;
                    }
                }
            });
        });
        this.enable();
        return this.options.init.call(this);
    }
    // Not fully tested yet
    destroy() {
        this.disable();
        this.removeAllFiles(true);
        if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
            this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
            this.hiddenFileInput = null;
        }
        delete this.element.dropzone;
        return $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.splice($3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.indexOf(this), 1);
    }
    updateTotalUploadProgress() {
        let totalUploadProgress;
        let totalBytesSent = 0;
        let totalBytes = 0;
        let activeFiles = this.getActiveFiles();
        if (activeFiles.length) {
            for (let file of this.getActiveFiles()){
                totalBytesSent += file.upload.bytesSent;
                totalBytes += file.upload.total;
            }
            totalUploadProgress = 100 * totalBytesSent / totalBytes;
        } else totalUploadProgress = 100;
        return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    }
    // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.
    _getParamName(n) {
        if (typeof this.options.paramName === "function") return this.options.paramName(n);
        else return `${this.options.paramName}${this.options.uploadMultiple ? `[${n}]` : ""}`;
    }
    // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData
    _renameFile(file) {
        if (typeof this.options.renameFile !== "function") return file.name;
        return this.options.renameFile(file);
    }
    // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(
    getFallbackForm() {
        let existingFallback, form;
        if (existingFallback = this.getExistingFallback()) return existingFallback;
        let fieldsString = '<div class="dz-fallback">';
        if (this.options.dictFallbackText) fieldsString += `<p>${this.options.dictFallbackText}</p>`;
        fieldsString += `<input type="file" name="${this._getParamName(0)}" ${this.options.uploadMultiple ? 'multiple="multiple"' : undefined} /><input type="submit" value="Upload!"></div>`;
        let fields = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(fieldsString);
        if (this.element.tagName !== "FORM") {
            form = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<form action="${this.options.url}" enctype="multipart/form-data" method="${this.options.method}"></form>`);
            form.appendChild(fields);
        } else {
            // Make sure that the enctype and method attributes are set properly
            this.element.setAttribute("enctype", "multipart/form-data");
            this.element.setAttribute("method", this.options.method);
        }
        return form != null ? form : fields;
    }
    // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(
    getExistingFallback() {
        let getFallback = function(elements) {
            for (let el of elements){
                if (/(^| )fallback($| )/.test(el.className)) return el;
            }
        };
        for (let tagName of [
            "div",
            "form"
        ]){
            var fallback;
            if (fallback = getFallback(this.element.getElementsByTagName(tagName))) return fallback;
        }
    }
    // Activates all listeners stored in @listeners
    setupEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.addEventListener(event, listener, false));
                }
                return result;
            })()
        );
    }
    // Deactivates all listeners stored in @listeners
    removeEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.removeEventListener(event, listener, false));
                }
                return result;
            })()
        );
    }
    // Removes all event listeners and cancels all files in the queue or being processed.
    disable() {
        this.clickableElements.forEach((element)=>element.classList.remove("dz-clickable")
        );
        this.removeEventListeners();
        this.disabled = true;
        return this.files.map((file)=>this.cancelUpload(file)
        );
    }
    enable() {
        delete this.disabled;
        this.clickableElements.forEach((element)=>element.classList.add("dz-clickable")
        );
        return this.setupEventListeners();
    }
    // Returns a nicely formatted filesize
    filesize(size) {
        let selectedSize = 0;
        let selectedUnit = "b";
        if (size > 0) {
            let units = [
                "tb",
                "gb",
                "mb",
                "kb",
                "b"
            ];
            for(let i = 0; i < units.length; i++){
                let unit = units[i];
                let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
                if (size >= cutoff) {
                    selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                    selectedUnit = unit;
                    break;
                }
            }
            selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
        }
        return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;
    }
    // Adds or removes the `dz-max-files-reached` class from the form.
    _updateMaxFilesReachedClass() {
        if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            if (this.getAcceptedFiles().length === this.options.maxFiles) this.emit("maxfilesreached", this.files);
            return this.element.classList.add("dz-max-files-reached");
        } else return this.element.classList.remove("dz-max-files-reached");
    }
    drop(e) {
        if (!e.dataTransfer) return;
        this.emit("drop", e);
        // Convert the FileList to an Array
        // This is necessary for IE11
        let files = [];
        for(let i = 0; i < e.dataTransfer.files.length; i++)files[i] = e.dataTransfer.files[i];
        // Even if it's a folder, files.length will contain the folders.
        if (files.length) {
            let { items: items  } = e.dataTransfer;
            if (items && items.length && items[0].webkitGetAsEntry != null) // The browser supports dropping of folders, so handle items instead of files
            this._addFilesFromItems(items);
            else this.handleFiles(files);
        }
        this.emit("addedfiles", files);
    }
    paste(e) {
        if ($3ed269f2f0fb224b$var$__guard__(e != null ? e.clipboardData : undefined, (x)=>x.items
        ) == null) return;
        this.emit("paste", e);
        let { items: items  } = e.clipboardData;
        if (items.length) return this._addFilesFromItems(items);
    }
    handleFiles(files) {
        for (let file of files)this.addFile(file);
    }
    // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.
    _addFilesFromItems(items) {
        return (()=>{
            let result = [];
            for (let item of items){
                var entry;
                if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                    if (entry.isFile) result.push(this.addFile(item.getAsFile()));
                    else if (entry.isDirectory) // Append all files from that directory to files
                    result.push(this._addFilesFromDirectory(entry, entry.name));
                    else result.push(undefined);
                } else if (item.getAsFile != null) {
                    if (item.kind == null || item.kind === "file") result.push(this.addFile(item.getAsFile()));
                    else result.push(undefined);
                } else result.push(undefined);
            }
            return result;
        })();
    }
    // Goes through the directory, and adds each file it finds recursively
    _addFilesFromDirectory(directory, path) {
        let dirReader = directory.createReader();
        let errorHandler = (error)=>$3ed269f2f0fb224b$var$__guardMethod__(console, "log", (o)=>o.log(error)
            )
        ;
        var readEntries = ()=>{
            return dirReader.readEntries((entries)=>{
                if (entries.length > 0) {
                    for (let entry of entries){
                        if (entry.isFile) entry.file((file)=>{
                            if (this.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") return;
                            file.fullPath = `${path}/${file.name}`;
                            return this.addFile(file);
                        });
                        else if (entry.isDirectory) this._addFilesFromDirectory(entry, `${path}/${entry.name}`);
                    }
                    // Recursively call readEntries() again, since browser only handle
                    // the first 100 entries.
                    // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                    readEntries();
                }
                return null;
            }, errorHandler);
        };
        return readEntries();
    }
    // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.
    accept(file, done) {
        if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1048576) done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
        else if (!$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile(file, this.options.acceptedFiles)) done(this.options.dictInvalidFileType);
        else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
            this.emit("maxfilesexceeded", file);
        } else this.options.accept.call(this, file, done);
    }
    addFile(file) {
        file.upload = {
            uuid: $3ed269f2f0fb224b$export$2e2bcd8739ae039.uuidv4(),
            progress: 0,
            // Setting the total upload size to file.size for the beginning
            // It's actual different than the size to be transmitted.
            total: file.size,
            bytesSent: 0,
            filename: this._renameFile(file)
        };
        this.files.push(file);
        file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED;
        this.emit("addedfile", file);
        this._enqueueThumbnail(file);
        this.accept(file, (error)=>{
            if (error) {
                file.accepted = false;
                this._errorProcessing([
                    file
                ], error); // Will set the file.status
            } else {
                file.accepted = true;
                if (this.options.autoQueue) this.enqueueFile(file);
                 // Will set .accepted = true
            }
            this._updateMaxFilesReachedClass();
        });
    }
    // Wrapper for enqueueFile
    enqueueFiles(files) {
        for (let file of files)this.enqueueFile(file);
        return null;
    }
    enqueueFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED && file.accepted === true) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
            if (this.options.autoProcessQueue) return setTimeout(()=>this.processQueue()
            , 0); // Deferring the call
        } else throw new Error("This file can't be queued because it has already been processed or was rejected.");
    }
    _enqueueThumbnail(file) {
        if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1048576) {
            this._thumbnailQueue.push(file);
            return setTimeout(()=>this._processThumbnailQueue()
            , 0); // Deferring the call
        }
    }
    _processThumbnailQueue() {
        if (this._processingThumbnail || this._thumbnailQueue.length === 0) return;
        this._processingThumbnail = true;
        let file = this._thumbnailQueue.shift();
        return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, (dataUrl)=>{
            this.emit("thumbnail", file, dataUrl);
            this._processingThumbnail = false;
            return this._processThumbnailQueue();
        });
    }
    // Can be called by the user to remove a file
    removeFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) this.cancelUpload(file);
        this.files = $3ed269f2f0fb224b$var$without(this.files, file);
        this.emit("removedfile", file);
        if (this.files.length === 0) return this.emit("reset");
    }
    // Removes all files that aren't currently processed from the list
    removeAllFiles(cancelIfNecessary) {
        // Create a copy of files since removeFile() changes the @files array.
        if (cancelIfNecessary == null) cancelIfNecessary = false;
        for (let file of this.files.slice())if (file.status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || cancelIfNecessary) this.removeFile(file);
        return null;
    }
    // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.
    resizeImage(file, width, height, resizeMethod, callback) {
        return this.createThumbnail(file, width, height, resizeMethod, true, (dataUrl, canvas)=>{
            if (canvas == null) // The image has not been resized
            return callback(file);
            else {
                let { resizeMimeType: resizeMimeType  } = this.options;
                if (resizeMimeType == null) resizeMimeType = file.type;
                let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);
                if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg") // Now add the original EXIF information
                resizedDataURL = $3ed269f2f0fb224b$var$ExifRestore.restore(file.dataURL, resizedDataURL);
                return callback($3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob(resizedDataURL));
            }
        });
    }
    createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
        let fileReader = new FileReader();
        fileReader.onload = ()=>{
            file.dataURL = fileReader.result;
            // Don't bother creating a thumbnail for SVG images since they're vector
            if (file.type === "image/svg+xml") {
                if (callback != null) callback(fileReader.result);
                return;
            }
            this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
        };
        fileReader.readAsDataURL(file);
    }
    // `mockFile` needs to have these attributes:
    //
    //     { name: 'name', size: 12345, imageUrl: '' }
    //
    // `callback` will be invoked when the image has been downloaded and displayed.
    // `crossOrigin` will be added to the `img` tag when accessing the file.
    displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {
        this.emit("addedfile", mockFile);
        this.emit("complete", mockFile);
        if (!resizeThumbnail) {
            this.emit("thumbnail", mockFile, imageUrl);
            if (callback) callback();
        } else {
            let onDone = (thumbnail)=>{
                this.emit("thumbnail", mockFile, thumbnail);
                if (callback) callback();
            };
            mockFile.dataURL = imageUrl;
            this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
        }
    }
    createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
        // Not using `new Image` here because of a bug in latest Chrome versions.
        // See https://github.com/enyo/dropzone/pull/226
        let img = document.createElement("img");
        if (crossOrigin) img.crossOrigin = crossOrigin;
        // fixOrientation is not needed anymore with browsers handling imageOrientation
        fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
        img.onload = ()=>{
            let loadExif = (callback)=>callback(1)
            ;
            if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) loadExif = (callback)=>EXIF.getData(img, function() {
                    return callback(EXIF.getTag(this, "Orientation"));
                })
            ;
            return loadExif((orientation)=>{
                file.width = img.width;
                file.height = img.height;
                let resizeInfo = this.options.resize.call(this, file, width, height, resizeMethod);
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                canvas.width = resizeInfo.trgWidth;
                canvas.height = resizeInfo.trgHeight;
                if (orientation > 4) {
                    canvas.width = resizeInfo.trgHeight;
                    canvas.height = resizeInfo.trgWidth;
                }
                switch(orientation){
                    case 2:
                        // horizontal flip
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                        break;
                    case 3:
                        // 180° rotate left
                        ctx.translate(canvas.width, canvas.height);
                        ctx.rotate(Math.PI);
                        break;
                    case 4:
                        // vertical flip
                        ctx.translate(0, canvas.height);
                        ctx.scale(1, -1);
                        break;
                    case 5:
                        // vertical flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.scale(1, -1);
                        break;
                    case 6:
                        // 90° rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(0, -canvas.width);
                        break;
                    case 7:
                        // horizontal flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(canvas.height, -canvas.width);
                        ctx.scale(-1, 1);
                        break;
                    case 8:
                        // 90° rotate left
                        ctx.rotate(-0.5 * Math.PI);
                        ctx.translate(-canvas.height, 0);
                        break;
                }
                // This is a bugfix for iOS' scaling bug.
                $3ed269f2f0fb224b$var$drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
                let thumbnail = canvas.toDataURL("image/png");
                if (callback != null) return callback(thumbnail, canvas);
            });
        };
        if (callback != null) img.onerror = callback;
        return img.src = file.dataURL;
    }
    // Goes through the queue and processes files if there aren't too many already.
    processQueue() {
        let { parallelUploads: parallelUploads  } = this.options;
        let processingLength = this.getUploadingFiles().length;
        let i = processingLength;
        // There are already at least as many files uploading than should be
        if (processingLength >= parallelUploads) return;
        let queuedFiles = this.getQueuedFiles();
        if (!(queuedFiles.length > 0)) return;
        if (this.options.uploadMultiple) // The files should be uploaded in one request
        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
        else while(i < parallelUploads){
            if (!queuedFiles.length) return;
             // Nothing left to process
            this.processFile(queuedFiles.shift());
            i++;
        }
    }
    // Wrapper for `processFiles`
    processFile(file) {
        return this.processFiles([
            file
        ]);
    }
    // Loads the file, then calls finishedLoading()
    processFiles(files) {
        for (let file of files){
            file.processing = true; // Backwards compatibility
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
            this.emit("processing", file);
        }
        if (this.options.uploadMultiple) this.emit("processingmultiple", files);
        return this.uploadFiles(files);
    }
    _getFilesWithXhr(xhr) {
        let files;
        return files = this.files.filter((file)=>file.xhr === xhr
        ).map((file)=>file
        );
    }
    // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.
    cancelUpload(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) {
            let groupedFiles = this._getFilesWithXhr(file.xhr);
            for (let groupedFile of groupedFiles)groupedFile.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            if (typeof file.xhr !== "undefined") file.xhr.abort();
            for (let groupedFile1 of groupedFiles)this.emit("canceled", groupedFile1);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", groupedFiles);
        } else if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            this.emit("canceled", file);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", [
                file
            ]);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    resolveOption(option, ...args) {
        if (typeof option === "function") return option.apply(this, args);
        return option;
    }
    uploadFile(file) {
        return this.uploadFiles([
            file
        ]);
    }
    uploadFiles(files) {
        this._transformFiles(files, (transformedFiles)=>{
            if (this.options.chunking) {
                // Chunking is not allowed to be used with `uploadMultiple` so we know
                // that there is only __one__file.
                let transformedFile = transformedFiles[0];
                files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);
                files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);
            }
            if (files[0].upload.chunked) {
                // This file should be sent in chunks!
                // If the chunking option is set, we **know** that there can only be **one** file, since
                // uploadMultiple is not allowed with this option.
                let file = files[0];
                let transformedFile = transformedFiles[0];
                let startedChunkCount = 0;
                file.upload.chunks = [];
                let handleNextChunk = ()=>{
                    let chunkIndex = 0;
                    // Find the next item in file.upload.chunks that is not defined yet.
                    while(file.upload.chunks[chunkIndex] !== undefined)chunkIndex++;
                    // This means, that all chunks have already been started.
                    if (chunkIndex >= file.upload.totalChunkCount) return;
                    startedChunkCount++;
                    let start = chunkIndex * this.options.chunkSize;
                    let end = Math.min(start + this.options.chunkSize, transformedFile.size);
                    let dataBlock = {
                        name: this._getParamName(0),
                        data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
                        filename: file.upload.filename,
                        chunkIndex: chunkIndex
                    };
                    file.upload.chunks[chunkIndex] = {
                        file: file,
                        index: chunkIndex,
                        dataBlock: dataBlock,
                        status: $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING,
                        progress: 0,
                        retries: 0
                    };
                    this._uploadData(files, [
                        dataBlock
                    ]);
                };
                file.upload.finishedChunkUpload = (chunk, response)=>{
                    let allFinished = true;
                    chunk.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
                    // Clear the data from the chunk
                    chunk.dataBlock = null;
                    chunk.response = chunk.xhr.responseText;
                    chunk.responseHeaders = chunk.xhr.getAllResponseHeaders();
                    // Leaving this reference to xhr will cause memory leaks.
                    chunk.xhr = null;
                    for(let i = 0; i < file.upload.totalChunkCount; i++){
                        if (file.upload.chunks[i] === undefined) return handleNextChunk();
                        if (file.upload.chunks[i].status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS) allFinished = false;
                    }
                    if (allFinished) this.options.chunksUploaded(file, ()=>{
                        this._finished(files, response, null);
                    });
                };
                if (this.options.parallelChunkUploads) for(let i = 0; i < file.upload.totalChunkCount; i++)handleNextChunk();
                else handleNextChunk();
            } else {
                let dataBlocks = [];
                for(let i = 0; i < files.length; i++)dataBlocks[i] = {
                    name: this._getParamName(i),
                    data: transformedFiles[i],
                    filename: files[i].upload.filename
                };
                this._uploadData(files, dataBlocks);
            }
        });
    }
    /// Returns the right chunk for given file and xhr
    _getChunk(file, xhr) {
        for(let i = 0; i < file.upload.totalChunkCount; i++){
            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) return file.upload.chunks[i];
        }
    }
    // This function actually uploads the file(s) to the server.
    //
    //  If dataBlocks contains the actual data to upload (meaning, that this could
    // either be transformed files, or individual chunks for chunked upload) then
    // they will be used for the actual data to upload.
    _uploadData(files, dataBlocks) {
        let xhr = new XMLHttpRequest();
        // Put the xhr object in the file objects to be able to reference it later.
        for (let file of files)file.xhr = xhr;
        if (files[0].upload.chunked) // Put the xhr object in the right chunk object, so it can be associated
        // later, and found with _getChunk.
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
        let method = this.resolveOption(this.options.method, files, dataBlocks);
        let url = this.resolveOption(this.options.url, files, dataBlocks);
        xhr.open(method, url, true);
        // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
        let timeout = this.resolveOption(this.options.timeout, files);
        if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files);
        // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
        xhr.withCredentials = !!this.options.withCredentials;
        xhr.onload = (e)=>{
            this._finishedUploading(files, xhr, e);
        };
        xhr.ontimeout = ()=>{
            this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1000} seconds`);
        };
        xhr.onerror = ()=>{
            this._handleUploadError(files, xhr);
        };
        // Some browsers do not have the .upload property
        let progressObj = xhr.upload != null ? xhr.upload : xhr;
        progressObj.onprogress = (e)=>this._updateFilesUploadProgress(files, xhr, e)
        ;
        let headers = this.options.defaultHeaders ? {
            Accept: "application/json",
            "Cache-Control": "no-cache",
            "X-Requested-With": "XMLHttpRequest"
        } : {
        };
        if (this.options.binaryBody) headers["Content-Type"] = files[0].type;
        if (this.options.headers) (0,just_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(headers, this.options.headers);
        for(let headerName in headers){
            let headerValue = headers[headerName];
            if (headerValue) xhr.setRequestHeader(headerName, headerValue);
        }
        if (this.options.binaryBody) {
            // Since the file is going to be sent as binary body, it doesn't make
            // any sense to generate `FormData` for it.
            for (let file of files)this.emit("sending", file, xhr);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr);
            this.submitRequest(xhr, null, files);
        } else {
            let formData = new FormData();
            // Adding all @options parameters
            if (this.options.params) {
                let additionalParams = this.options.params;
                if (typeof additionalParams === "function") additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
                for(let key in additionalParams){
                    let value = additionalParams[key];
                    if (Array.isArray(value)) // The additional parameter contains an array,
                    // so lets iterate over it to attach each value
                    // individually.
                    for(let i = 0; i < value.length; i++)formData.append(key, value[i]);
                    else formData.append(key, value);
                }
            }
            // Let the user add additional data if necessary
            for (let file of files)this.emit("sending", file, xhr, formData);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr, formData);
            this._addFormElementData(formData);
            // Finally add the files
            // Has to be last because some servers (eg: S3) expect the file to be the last parameter
            for(let i = 0; i < dataBlocks.length; i++){
                let dataBlock = dataBlocks[i];
                formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
            }
            this.submitRequest(xhr, formData, files);
        }
    }
    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
    _transformFiles(files, done) {
        let transformedFiles = [];
        // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
        let doneCounter = 0;
        for(let i = 0; i < files.length; i++)this.options.transformFile.call(this, files[i], (transformedFile)=>{
            transformedFiles[i] = transformedFile;
            if (++doneCounter === files.length) done(transformedFiles);
        });
    }
    // Takes care of adding other input elements of the form to the AJAX request
    _addFormElementData(formData) {
        // Take care of other input elements
        if (this.element.tagName === "FORM") for (let input of this.element.querySelectorAll("input, textarea, select, button")){
            let inputName = input.getAttribute("name");
            let inputType = input.getAttribute("type");
            if (inputType) inputType = inputType.toLowerCase();
            // If the input doesn't have a name, we can't use it.
            if (typeof inputName === "undefined" || inputName === null) continue;
            if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                // Possibly multiple values
                for (let option of input.options)if (option.selected) formData.append(inputName, option.value);
            } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) formData.append(inputName, input.value);
        }
    }
    // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.
    _updateFilesUploadProgress(files, xhr, e) {
        if (!files[0].upload.chunked) // Handle file uploads without chunking
        for (let file of files){
            if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) continue;
            if (e) {
                file.upload.progress = 100 * e.loaded / e.total;
                file.upload.total = e.total;
                file.upload.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                file.upload.progress = 100;
                file.upload.bytesSent = file.upload.total;
            }
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
        else {
            // Handle chunked file uploads
            // Chunked upload is not compatible with uploading multiple files in one
            // request, so we know there's only one file.
            let file = files[0];
            // Since this is a chunked upload, we need to update the appropriate chunk
            // progress.
            let chunk = this._getChunk(file, xhr);
            if (e) {
                chunk.progress = 100 * e.loaded / e.total;
                chunk.total = e.total;
                chunk.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                chunk.progress = 100;
                chunk.bytesSent = chunk.total;
            }
            // Now tally the *file* upload progress from its individual chunks
            file.upload.progress = 0;
            file.upload.total = 0;
            file.upload.bytesSent = 0;
            for(let i = 0; i < file.upload.totalChunkCount; i++)if (file.upload.chunks[i] && typeof file.upload.chunks[i].progress !== "undefined") {
                file.upload.progress += file.upload.chunks[i].progress;
                file.upload.total += file.upload.chunks[i].total;
                file.upload.bytesSent += file.upload.chunks[i].bytesSent;
            }
            // Since the process is a percentage, we need to divide by the amount of
            // chunks we've used.
            file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
    }
    _finishedUploading(files, xhr, e) {
        let response;
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (xhr.readyState !== 4) return;
        if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
            response = xhr.responseText;
            if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) try {
                response = JSON.parse(response);
            } catch (error) {
                e = error;
                response = "Invalid JSON response from server.";
            }
        }
        this._updateFilesUploadProgress(files, xhr);
        if (!(200 <= xhr.status && xhr.status < 300)) this._handleUploadError(files, xhr, response);
        else if (files[0].upload.chunked) files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
        else this._finished(files, response, e);
    }
    _handleUploadError(files, xhr, response) {
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (files[0].upload.chunked && this.options.retryChunks) {
            let chunk = this._getChunk(files[0], xhr);
            if ((chunk.retries++) < this.options.retryChunksLimit) {
                this._uploadData(files, [
                    chunk.dataBlock
                ]);
                return;
            } else console.warn("Retried this chunk too often. Giving up.");
        }
        this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
    }
    submitRequest(xhr, formData, files) {
        if (xhr.readyState != 1) {
            console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
            return;
        }
        if (this.options.binaryBody) {
            if (files[0].upload.chunked) {
                const chunk = this._getChunk(files[0], xhr);
                xhr.send(chunk.dataBlock.data);
            } else xhr.send(files[0]);
        } else xhr.send(formData);
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _finished(files, responseText, e) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
            this.emit("success", file, responseText, e);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("successmultiple", files, responseText, e);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _errorProcessing(files, message, xhr) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR;
            this.emit("error", file, message, xhr);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("errormultiple", files, message, xhr);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    static uuidv4() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
        });
    }
    constructor(el, options){
        super();
        let fallback, left;
        this.element = el;
        this.clickableElements = [];
        this.listeners = [];
        this.files = []; // All files
        if (typeof this.element === "string") this.element = document.querySelector(this.element);
        // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
        if (!this.element || this.element.nodeType == null) throw new Error("Invalid dropzone element.");
        if (this.element.dropzone) throw new Error("Dropzone already attached.");
        // Now add this dropzone to the instances.
        $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.push(this);
        // Put the dropzone inside the element itself.
        this.element.dropzone = this;
        let elementOptions = (left = $3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(this.element)) != null ? left : {
        };
        this.options = (0,just_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(true, {
        }, $4ca367182776f80b$export$2e2bcd8739ae039, elementOptions, options != null ? options : {
        });
        this.options.previewTemplate = this.options.previewTemplate.replace(/\n*/g, "");
        // If the browser failed, just call the fallback and leave
        if (this.options.forceFallback || !$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported()) return this.options.fallback.call(this);
        // @options.url = @element.getAttribute "action" unless @options.url?
        if (this.options.url == null) this.options.url = this.element.getAttribute("action");
        if (!this.options.url) throw new Error("No URL provided.");
        if (this.options.acceptedFiles && this.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        if (this.options.uploadMultiple && this.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
        if (this.options.binaryBody && this.options.uploadMultiple) throw new Error("You cannot set both: binaryBody and uploadMultiple.");
        // Backwards compatibility
        if (this.options.acceptedMimeTypes) {
            this.options.acceptedFiles = this.options.acceptedMimeTypes;
            delete this.options.acceptedMimeTypes;
        }
        // Backwards compatibility
        if (this.options.renameFilename != null) this.options.renameFile = (file)=>this.options.renameFilename.call(this, file.name, file)
        ;
        if (typeof this.options.method === "string") this.options.method = this.options.method.toUpperCase();
        if ((fallback = this.getExistingFallback()) && fallback.parentNode) // Remove the fallback
        fallback.parentNode.removeChild(fallback);
        // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
        if (this.options.previewsContainer !== false) {
            if (this.options.previewsContainer) this.previewsContainer = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.previewsContainer, "previewsContainer");
            else this.previewsContainer = this.element;
        }
        if (this.options.clickable) {
            if (this.options.clickable === true) this.clickableElements = [
                this.element
            ];
            else this.clickableElements = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements(this.options.clickable, "clickable");
        }
        this.init();
    }
}
$3ed269f2f0fb224b$export$2e2bcd8739ae039.initClass();
// This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
$3ed269f2f0fb224b$export$2e2bcd8739ae039.options = {
};
// Returns the options for an element or undefined if none available.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement = function(element) {
    // Get the `Dropzone.options.elementId` for this element if it exists
    if (element.getAttribute("id")) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.options[$3ed269f2f0fb224b$var$camelize(element.getAttribute("id"))];
    else return undefined;
};
// Holds a list of all dropzone instances
$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances = [];
// Returns the dropzone for given element if any
$3ed269f2f0fb224b$export$2e2bcd8739ae039.forElement = function(element) {
    if (typeof element === "string") element = document.querySelector(element);
    if ((element != null ? element.dropzone : undefined) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
    return element.dropzone;
};
// Looks for all .dropzone elements and creates a dropzone for them
$3ed269f2f0fb224b$export$2e2bcd8739ae039.discover = function() {
    let dropzones;
    if (document.querySelectorAll) dropzones = document.querySelectorAll(".dropzone");
    else {
        dropzones = [];
        // IE :(
        let checkElements = (elements)=>(()=>{
                let result = [];
                for (let el of elements)if (/(^| )dropzone($| )/.test(el.className)) result.push(dropzones.push(el));
                else result.push(undefined);
                return result;
            })()
        ;
        checkElements(document.getElementsByTagName("div"));
        checkElements(document.getElementsByTagName("form"));
    }
    return (()=>{
        let result = [];
        for (let dropzone of dropzones)// Create a dropzone unless auto discover has been disabled for specific element
        if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(dropzone) !== false) result.push(new $3ed269f2f0fb224b$export$2e2bcd8739ae039(dropzone));
        else result.push(undefined);
        return result;
    })();
};
// Some browsers support drag and drog functionality, but not correctly.
//
// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
$3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = [
    // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
    /opera.*(Macintosh|Windows Phone).*version\/12/i, 
];
// Checks if the browser is supported
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported = function() {
    let capableBrowser = true;
    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
        if (!("classList" in document.createElement("a"))) capableBrowser = false;
        else {
            if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers !== undefined) // Since this has been renamed, this makes sure we don't break older
            // configuration.
            $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = $3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers;
            // The browser supports the API, but may be blocked.
            for (let regex of $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers)if (regex.test(navigator.userAgent)) {
                capableBrowser = false;
                continue;
            }
        }
    } else capableBrowser = false;
    return capableBrowser;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob = function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    let byteString = atob(dataURI.split(",")[1]);
    // separate out the mime component
    let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
    // write the bytes of the string to an ArrayBuffer
    let ab = new ArrayBuffer(byteString.length);
    let ia = new Uint8Array(ab);
    for(let i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--)ia[i] = byteString.charCodeAt(i);
    // write the ArrayBuffer to a blob
    return new Blob([
        ab
    ], {
        type: mimeString
    });
};
// Returns an array without the rejected item
const $3ed269f2f0fb224b$var$without = (list, rejectedItem)=>list.filter((item)=>item !== rejectedItem
    ).map((item)=>item
    )
;
// abc-def_ghi -> abcDefGhi
const $3ed269f2f0fb224b$var$camelize = (str)=>str.replace(/[\-_](\w)/g, (match)=>match.charAt(1).toUpperCase()
    )
;
// Creates an element from string
$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement = function(string) {
    let div = document.createElement("div");
    div.innerHTML = string;
    return div.childNodes[0];
};
// Tests if given element is inside (or simply is) the container
$3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside = function(element, container) {
    if (element === container) return true;
     // Coffeescript doesn't support do/while loops
    while(element = element.parentNode){
        if (element === container) return true;
    }
    return false;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement = function(el, name) {
    let element;
    if (typeof el === "string") element = document.querySelector(el);
    else if (el.nodeType != null) element = el;
    if (element == null) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector or a plain HTML element.`);
    return element;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements = function(els, name) {
    let el, elements;
    if (els instanceof Array) {
        elements = [];
        try {
            for (el of els)elements.push(this.getElement(el, name));
        } catch (e) {
            elements = null;
        }
    } else if (typeof els === "string") {
        elements = [];
        for (el of document.querySelectorAll(els))elements.push(el);
    } else if (els.nodeType != null) elements = [
        els
    ];
    if (elements == null || !elements.length) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);
    return elements;
};
// Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm = function(question, accepted, rejected) {
    if (window.confirm(question)) return accepted();
    else if (rejected != null) return rejected();
};
// Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile = function(file, acceptedFiles) {
    if (!acceptedFiles) return true;
     // If there are no accepted mime types, it's OK
    acceptedFiles = acceptedFiles.split(",");
    let mimeType = file.type;
    let baseMimeType = mimeType.replace(/\/.*$/, "");
    for (let validType of acceptedFiles){
        validType = validType.trim();
        if (validType.charAt(0) === ".") {
            if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) return true;
        } else if (/\/\*$/.test(validType)) {
            // This is something like a image/* mime type
            if (baseMimeType === validType.replace(/\/.*$/, "")) return true;
        } else {
            if (mimeType === validType) return true;
        }
    }
    return false;
};
// Augment jQuery
if (typeof jQuery !== "undefined" && jQuery !== null) jQuery.fn.dropzone = function(options) {
    return this.each(function() {
        return new $3ed269f2f0fb224b$export$2e2bcd8739ae039(this, options);
    });
};
// Dropzone file status codes
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED = "added";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED = "queued";
// For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ACCEPTED = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING = "uploading";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.PROCESSING = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING; // alias
$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED = "canceled";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR = "error";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS = "success";
/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */ // Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
let $3ed269f2f0fb224b$var$detectVerticalSquash = function(img) {
    let iw = img.naturalWidth;
    let ih = img.naturalHeight;
    let canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = ih;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    let { data: data  } = ctx.getImageData(1, 0, 1, ih);
    // search image edge pixel position in case it is squashed vertically.
    let sy = 0;
    let ey = ih;
    let py = ih;
    while(py > sy){
        let alpha = data[(py - 1) * 4 + 3];
        if (alpha === 0) ey = py;
        else sy = py;
        py = ey + sy >> 1;
    }
    let ratio = py / ih;
    if (ratio === 0) return 1;
    else return ratio;
};
// A replacement for context.drawImage
// (args are for source and destination).
var $3ed269f2f0fb224b$var$drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
    let vertSquashRatio = $3ed269f2f0fb224b$var$detectVerticalSquash(img);
    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};
// Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html
class $3ed269f2f0fb224b$var$ExifRestore {
    static initClass() {
        this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    }
    static encode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        while(true){
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) enc3 = enc4 = 64;
            else if (isNaN(chr3)) enc4 = 64;
            output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return output;
    }
    static restore(origFileBase64, resizedFileBase64) {
        if (!origFileBase64.match("data:image/jpeg;base64,")) return resizedFileBase64;
        let rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
        let segments = this.slice2Segments(rawImage);
        let image = this.exifManipulation(resizedFileBase64, segments);
        return `data:image/jpeg;base64,${this.encode64(image)}`;
    }
    static exifManipulation(resizedFileBase64, segments) {
        let exifArray = this.getExifArray(segments);
        let newImageArray = this.insertExif(resizedFileBase64, exifArray);
        let aBuffer = new Uint8Array(newImageArray);
        return aBuffer;
    }
    static getExifArray(segments) {
        let seg = undefined;
        let x = 0;
        while(x < segments.length){
            seg = segments[x];
            if (seg[0] === 255 & seg[1] === 225) return seg;
            x++;
        }
        return [];
    }
    static insertExif(resizedFileBase64, exifArray) {
        let imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
        let buf = this.decode64(imageData);
        let separatePoint = buf.indexOf(255, 3);
        let mae = buf.slice(0, separatePoint);
        let ato = buf.slice(separatePoint);
        let array = mae;
        array = array.concat(exifArray);
        array = array.concat(ato);
        return array;
    }
    static slice2Segments(rawImageArray) {
        let head = 0;
        let segments = [];
        while(true){
            var length;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) break;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) head += 2;
            else {
                length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                let endPoint = head + length + 2;
                let seg = rawImageArray.slice(head, endPoint);
                segments.push(seg);
                head = endPoint;
            }
            if (head > rawImageArray.length) break;
        }
        return segments;
    }
    static decode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        let buf = [];
        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        let base64test = /[^A-Za-z0-9\+\/\=]/g;
        if (base64test.exec(input)) console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while(true){
            enc1 = this.KEY_STR.indexOf(input.charAt(i++));
            enc2 = this.KEY_STR.indexOf(input.charAt(i++));
            enc3 = this.KEY_STR.indexOf(input.charAt(i++));
            enc4 = this.KEY_STR.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            buf.push(chr1);
            if (enc3 !== 64) buf.push(chr2);
            if (enc4 !== 64) buf.push(chr3);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return buf;
    }
}
$3ed269f2f0fb224b$var$ExifRestore.initClass();
/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */ // @win window reference
// @fn function reference
let $3ed269f2f0fb224b$var$contentLoaded = function(win, fn) {
    let done = false;
    let top = true;
    let doc = win.document;
    let root = doc.documentElement;
    let add = doc.addEventListener ? "addEventListener" : "attachEvent";
    let rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
    let pre = doc.addEventListener ? "" : "on";
    var init = function(e) {
        if (e.type === "readystatechange" && doc.readyState !== "complete") return;
        (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
        if (!done && (done = true)) return fn.call(win, e.type || e);
    };
    var poll = function() {
        try {
            root.doScroll("left");
        } catch (e) {
            setTimeout(poll, 50);
            return;
        }
        return init("poll");
    };
    if (doc.readyState !== "complete") {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement;
            } catch (error) {
            }
            if (top) poll();
        }
        doc[add](pre + "DOMContentLoaded", init, false);
        doc[add](pre + "readystatechange", init, false);
        return win[add](pre + "load", init, false);
    }
};
function $3ed269f2f0fb224b$var$__guard__(value, transform) {
    return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
}
function $3ed269f2f0fb224b$var$__guardMethod__(obj, methodName, transform) {
    if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") return transform(obj, methodName);
    else return undefined;
}



//# sourceMappingURL=dropzone.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYm9vdHN0cmFwLXRhZ3NpbnB1dF9kaXN0X2Jvb3RzdHJhcC10YWdzaW5wdXRfanMtbm9kZV9tb2R1bGVzX2Jvb3RzdHJhcDQtLTFiN2YxZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELHFEQUFxRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMkNBQTJDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCw0Q0FBNEM7QUFDdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCw4QkFBOEI7QUFDekYsUUFBUTtBQUNSLHFEQUFxRCw4QkFBOEI7QUFDbkY7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELHlFQUF5RTtBQUNwSTtBQUNBLDJEQUEyRCxpREFBaUQ7O0FBRTVHO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsNkNBQTZDO0FBQy9HO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsdUNBQXVDO0FBQzlGLHVEQUF1RCx1Q0FBdUM7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCw4QkFBOEI7QUFDcEYsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0Esd0VBQXdFLHVDQUF1QztBQUMvRztBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsRUFBRSxvQ0FBYTs7Ozs7Ozs7Ozs7QUN0cEJoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQU8sQ0FBQyx5RUFBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDL0IsSUFBSSxLQUFLLEVBZU47QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQyw0RUFBNEUsR0FBRyxNQUFNLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsMkJBQTJCLElBQUk7QUFDL0IsNkJBQTZCLElBQUk7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7OztBQzUzQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sQ0FBQyx5RUFBUSxFQUFFLG9FQUFRLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUM3QyxNQUFNLEtBQUssRUFXTjtBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvRUFBb0U7QUFDcEg7QUFDQSwrRUFBK0Usb0VBQW9FO0FBQ25KO0FBQ0EsZ0RBQWdELG9FQUFvRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNFQUFzRTtBQUN0SDtBQUNBO0FBQ0EsaUZBQWlGLHdFQUF3RTtBQUN6SjtBQUNBLGdEQUFnRCxzRUFBc0U7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNFQUFzRTtBQUN0SDtBQUNBO0FBQ0EsaUZBQWlGLHdFQUF3RTtBQUN6SjtBQUNBLGdEQUFnRCxzRUFBc0U7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVGQUF1RjtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlEQUF5RDtBQUN2SDtBQUNBO0FBQ0EsOERBQThELHFFQUFxRTtBQUNuSTtBQUNBO0FBQ0EsOERBQThELHlEQUF5RDtBQUN2SDtBQUNBO0FBQ0EsOERBQThELHlEQUF5RDtBQUN2SDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtEQUFrRDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLElBQUk7QUFDdkY7QUFDQSxpRkFBaUYsSUFBSSwrQkFBK0I7QUFDcEg7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBaUQ7QUFDcEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xqRkQ7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsZUFBZSxXQUFXLEdBQUcsSUFBSTtBQUNqQyxPQUFPLElBQUk7O0FBRVgsYUFBYTtBQUNiLFdBQVcsUUFBUSxXQUFXLEdBQUcsSUFBSTtBQUNyQyxPQUFPLElBQUk7O0FBRVg7QUFDQSxhQUFhO0FBQ2IsZUFBZSxPQUFPLEdBQUcsSUFBSTtBQUM3QjtBQUNBLE9BQU8sSUFBSTs7QUFFWDtBQUNBLGFBQWE7QUFDYixxQkFBcUIsT0FBTyxHQUFHLElBQUk7QUFDbkM7QUFDQSxPQUFPLElBQUk7O0FBRVgsVUFBVSxXQUFXLEdBQUcsSUFBSTtBQUM1QixVQUFVLFdBQVcsT0FBTztBQUM1QixVQUFVLFdBQVcsVUFBVTtBQUMvQixtQkFBbUIsV0FBVyxHQUFHO0FBQ2pDLGFBQWEsV0FBVyxHQUFHO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RVc7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVSxTQUFTLGFBQWE7QUFDeEMsMENBQTBDLFVBQVUsc0JBQXNCLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQixrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQThDLGFBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLG1CQUFtQiw0QkFBNEI7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTUFBZ00sU0FBUztBQUN6TSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxUUFBcVEsZ0NBQWdDO0FBQ3JTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZPQUE2TztBQUM3TztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUIsRUFBRSxrQ0FBa0MsRUFBRSxRQUFRO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw4QkFBOEI7QUFDL0Ysb0RBQW9ELHNCQUFzQixJQUFJLGlFQUFpRTtBQUMvSTtBQUNBO0FBQ0EsMkZBQTJGLGlCQUFpQiwwQ0FBMEMsb0JBQW9CO0FBQzFLO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsMEJBQTBCLGFBQWEsWUFBWSw2Q0FBNkM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUssR0FBRyxVQUFVO0FBQ2pFO0FBQ0EseUJBQXlCO0FBQ3pCLDBGQUEwRixLQUFLLEdBQUcsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxVQUFVLDBEQUEwRCxhQUFhO0FBQ3JOO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNFQUFzRSxpQ0FBaUM7QUFDdkc7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw2QkFBNkI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0MsdURBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMkZBQTJGLFlBQVk7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBaUI7QUFDeEMsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyRUFBMkUsS0FBSztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNLG9CQUFvQixNQUFNLFdBQVcsTUFBTTtBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdtSDtBQUNuSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtdGFnc2lucHV0L2Rpc3QvYm9vdHN0cmFwLXRhZ3NpbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwNC1kdWFsbGlzdGJveC9kaXN0L2pxdWVyeS5ib290c3RyYXAtZHVhbGxpc3Rib3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VvbmFzZGFuLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlci9zcmMvanMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qdXN0LWV4dGVuZC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Ryb3B6b25lL2Rpc3QvZHJvcHpvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoJCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdGFnQ2xhc3M6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnbGFiZWwgbGFiZWwtaW5mbyc7XG4gICAgfSxcbiAgICBpdGVtVmFsdWU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtID8gaXRlbS50b1N0cmluZygpIDogaXRlbTtcbiAgICB9LFxuICAgIGl0ZW1UZXh0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtVmFsdWUoaXRlbSk7XG4gICAgfSxcbiAgICBpdGVtVGl0bGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZnJlZUlucHV0OiB0cnVlLFxuICAgIGFkZE9uQmx1cjogdHJ1ZSxcbiAgICBtYXhUYWdzOiB1bmRlZmluZWQsXG4gICAgbWF4Q2hhcnM6IHVuZGVmaW5lZCxcbiAgICBjb25maXJtS2V5czogWzEzLCA0NF0sXG4gICAgZGVsaW1pdGVyOiAnLCcsXG4gICAgZGVsaW1pdGVyUmVnZXg6IG51bGwsXG4gICAgY2FuY2VsQ29uZmlybUtleXNPbkVtcHR5OiBmYWxzZSxcbiAgICBvblRhZ0V4aXN0czogZnVuY3Rpb24oaXRlbSwgJHRhZykge1xuICAgICAgJHRhZy5oaWRlKCkuZmFkZUluKCk7XG4gICAgfSxcbiAgICB0cmltVmFsdWU6IGZhbHNlLFxuICAgIGFsbG93RHVwbGljYXRlczogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIFRhZ3NJbnB1dChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pc0luaXQgPSB0cnVlO1xuICAgIHRoaXMuaXRlbXNBcnJheSA9IFtdO1xuXG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKCk7XG5cbiAgICB0aGlzLmlzU2VsZWN0ID0gKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NFTEVDVCcpO1xuICAgIHRoaXMubXVsdGlwbGUgPSAodGhpcy5pc1NlbGVjdCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSk7XG4gICAgdGhpcy5vYmplY3RJdGVtcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pdGVtVmFsdWU7XG4gICAgdGhpcy5wbGFjZWhvbGRlclRleHQgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSA/IHRoaXMuJGVsZW1lbnQuYXR0cigncGxhY2Vob2xkZXInKSA6ICcnO1xuICAgIHRoaXMuaW5wdXRTaXplID0gTWF0aC5tYXgoMSwgdGhpcy5wbGFjZWhvbGRlclRleHQubGVuZ3RoKTtcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJib290c3RyYXAtdGFnc2lucHV0XCI+PC9kaXY+Jyk7XG4gICAgdGhpcy4kaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIicgKyB0aGlzLnBsYWNlaG9sZGVyVGV4dCArICdcIi8+JykuYXBwZW5kVG8odGhpcy4kY29udGFpbmVyKTtcblxuICAgIHRoaXMuJGVsZW1lbnQuYmVmb3JlKHRoaXMuJGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLmJ1aWxkKG9wdGlvbnMpO1xuICAgIHRoaXMuaXNJbml0ID0gZmFsc2U7XG4gIH1cblxuICBUYWdzSW5wdXQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBUYWdzSW5wdXQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBpdGVtIGFzIGEgbmV3IHRhZy4gUGFzcyB0cnVlIHRvIGRvbnRQdXNoVmFsIHRvIHByZXZlbnRcbiAgICAgKiB1cGRhdGluZyB0aGUgZWxlbWVudHMgdmFsKClcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGRvbnRQdXNoVmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLm9wdGlvbnMubWF4VGFncyAmJiBzZWxmLml0ZW1zQXJyYXkubGVuZ3RoID49IHNlbGYub3B0aW9ucy5tYXhUYWdzKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIElnbm9yZSBmYWxzZXkgdmFsdWVzLCBleGNlcHQgZmFsc2VcbiAgICAgIGlmIChpdGVtICE9PSBmYWxzZSAmJiAhaXRlbSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBUcmltIHZhbHVlXG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgJiYgc2VsZi5vcHRpb25zLnRyaW1WYWx1ZSkge1xuICAgICAgICBpdGVtID0gJC50cmltKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIHRyeWluZyB0byBhZGQgYW4gb2JqZWN0IHdoaWxlIHRoZSBpdGVtVmFsdWUgb3B0aW9uIHdhcyBub3Qgc2V0XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgIXNlbGYub2JqZWN0SXRlbXMpXG4gICAgICAgIHRocm93KFwiQ2FuJ3QgYWRkIG9iamVjdHMgd2hlbiBpdGVtVmFsdWUgb3B0aW9uIGlzIG5vdCBzZXRcIik7XG5cbiAgICAgIC8vIElnbm9yZSBzdHJpbmdzIG9ubHkgY29udGFpbmcgd2hpdGVzcGFjZVxuICAgICAgaWYgKGl0ZW0udG9TdHJpbmcoKS5tYXRjaCgvXlxccyokLykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gSWYgU0VMRUNUIGJ1dCBub3QgbXVsdGlwbGUsIHJlbW92ZSBjdXJyZW50IHRhZ1xuICAgICAgaWYgKHNlbGYuaXNTZWxlY3QgJiYgIXNlbGYubXVsdGlwbGUgJiYgc2VsZi5pdGVtc0FycmF5Lmxlbmd0aCA+IDApXG4gICAgICAgIHNlbGYucmVtb3ZlKHNlbGYuaXRlbXNBcnJheVswXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLiRlbGVtZW50WzBdLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IChzZWxmLm9wdGlvbnMuZGVsaW1pdGVyUmVnZXgpID8gc2VsZi5vcHRpb25zLmRlbGltaXRlclJlZ2V4IDogc2VsZi5vcHRpb25zLmRlbGltaXRlcjtcbiAgICAgICAgdmFyIGl0ZW1zID0gaXRlbS5zcGxpdChkZWxpbWl0ZXIpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW1zW2ldLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRvbnRQdXNoVmFsKVxuICAgICAgICAgICAgc2VsZi5wdXNoVmFsKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtVmFsdWUgPSBzZWxmLm9wdGlvbnMuaXRlbVZhbHVlKGl0ZW0pLFxuICAgICAgICAgIGl0ZW1UZXh0ID0gc2VsZi5vcHRpb25zLml0ZW1UZXh0KGl0ZW0pLFxuICAgICAgICAgIHRhZ0NsYXNzID0gc2VsZi5vcHRpb25zLnRhZ0NsYXNzKGl0ZW0pLFxuICAgICAgICAgIGl0ZW1UaXRsZSA9IHNlbGYub3B0aW9ucy5pdGVtVGl0bGUoaXRlbSk7XG5cbiAgICAgIC8vIElnbm9yZSBpdGVtcyBhbGxyZWFkeSBhZGRlZFxuICAgICAgdmFyIGV4aXN0aW5nID0gJC5ncmVwKHNlbGYuaXRlbXNBcnJheSwgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZi5vcHRpb25zLml0ZW1WYWx1ZShpdGVtKSA9PT0gaXRlbVZhbHVlOyB9IClbMF07XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgIXNlbGYub3B0aW9ucy5hbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgICAgLy8gSW52b2tlIG9uVGFnRXhpc3RzXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25UYWdFeGlzdHMpIHtcbiAgICAgICAgICB2YXIgJGV4aXN0aW5nVGFnID0gJChcIi50YWdcIiwgc2VsZi4kY29udGFpbmVyKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiAkKHRoaXMpLmRhdGEoXCJpdGVtXCIpID09PSBleGlzdGluZzsgfSk7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLm9uVGFnRXhpc3RzKGl0ZW0sICRleGlzdGluZ1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBsZW5ndGggZ3JlYXRlciB0aGFuIGxpbWl0XG4gICAgICBpZiAoc2VsZi5pdGVtcygpLnRvU3RyaW5nKCkubGVuZ3RoICsgaXRlbS5sZW5ndGggKyAxID4gc2VsZi5vcHRpb25zLm1heElucHV0TGVuZ3RoKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIHJhaXNlIGJlZm9yZUl0ZW1BZGQgYXJnXG4gICAgICB2YXIgYmVmb3JlSXRlbUFkZEV2ZW50ID0gJC5FdmVudCgnYmVmb3JlSXRlbUFkZCcsIHsgaXRlbTogaXRlbSwgY2FuY2VsOiBmYWxzZSwgb3B0aW9uczogb3B0aW9uc30pO1xuICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKGJlZm9yZUl0ZW1BZGRFdmVudCk7XG4gICAgICBpZiAoYmVmb3JlSXRlbUFkZEV2ZW50LmNhbmNlbClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyByZWdpc3RlciBpdGVtIGluIGludGVybmFsIGFycmF5IGFuZCBtYXBcbiAgICAgIHNlbGYuaXRlbXNBcnJheS5wdXNoKGl0ZW0pO1xuXG4gICAgICAvLyBhZGQgYSB0YWcgZWxlbWVudFxuXG4gICAgICB2YXIgJHRhZyA9ICQoJzxzcGFuIGNsYXNzPVwidGFnICcgKyBodG1sRW5jb2RlKHRhZ0NsYXNzKSArIChpdGVtVGl0bGUgIT09IG51bGwgPyAoJ1wiIHRpdGxlPVwiJyArIGl0ZW1UaXRsZSkgOiAnJykgKyAnXCI+JyArIGh0bWxFbmNvZGUoaXRlbVRleHQpICsgJzxzcGFuIGRhdGEtcm9sZT1cInJlbW92ZVwiPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICAkdGFnLmRhdGEoJ2l0ZW0nLCBpdGVtKTtcbiAgICAgIHNlbGYuZmluZElucHV0V3JhcHBlcigpLmJlZm9yZSgkdGFnKTtcbiAgICAgICR0YWcuYWZ0ZXIoJyAnKTtcblxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSB0YWcgZXhpc3RzIGluIGl0cyByYXcgb3IgdXJpLWVuY29kZWQgZm9ybVxuICAgICAgdmFyIG9wdGlvbkV4aXN0cyA9IChcbiAgICAgICAgJCgnb3B0aW9uW3ZhbHVlPVwiJyArIGVuY29kZVVSSUNvbXBvbmVudChpdGVtVmFsdWUpICsgJ1wiXScsIHNlbGYuJGVsZW1lbnQpLmxlbmd0aCB8fFxuICAgICAgICAkKCdvcHRpb25bdmFsdWU9XCInICsgaHRtbEVuY29kZShpdGVtVmFsdWUpICsgJ1wiXScsIHNlbGYuJGVsZW1lbnQpLmxlbmd0aFxuICAgICAgKTtcblxuICAgICAgLy8gYWRkIDxvcHRpb24gLz4gaWYgaXRlbSByZXByZXNlbnRzIGEgdmFsdWUgbm90IHByZXNlbnQgaW4gb25lIG9mIHRoZSA8c2VsZWN0IC8+J3Mgb3B0aW9uc1xuICAgICAgaWYgKHNlbGYuaXNTZWxlY3QgJiYgIW9wdGlvbkV4aXN0cykge1xuICAgICAgICB2YXIgJG9wdGlvbiA9ICQoJzxvcHRpb24gc2VsZWN0ZWQ+JyArIGh0bWxFbmNvZGUoaXRlbVRleHQpICsgJzwvb3B0aW9uPicpO1xuICAgICAgICAkb3B0aW9uLmRhdGEoJ2l0ZW0nLCBpdGVtKTtcbiAgICAgICAgJG9wdGlvbi5hdHRyKCd2YWx1ZScsIGl0ZW1WYWx1ZSk7XG4gICAgICAgIHNlbGYuJGVsZW1lbnQuYXBwZW5kKCRvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbnRQdXNoVmFsKVxuICAgICAgICBzZWxmLnB1c2hWYWwoKTtcblxuICAgICAgLy8gQWRkIGNsYXNzIHdoZW4gcmVhY2hlZCBtYXhUYWdzXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLm1heFRhZ3MgPT09IHNlbGYuaXRlbXNBcnJheS5sZW5ndGggfHwgc2VsZi5pdGVtcygpLnRvU3RyaW5nKCkubGVuZ3RoID09PSBzZWxmLm9wdGlvbnMubWF4SW5wdXRMZW5ndGgpXG4gICAgICAgIHNlbGYuJGNvbnRhaW5lci5hZGRDbGFzcygnYm9vdHN0cmFwLXRhZ3NpbnB1dC1tYXgnKTtcblxuICAgICAgLy8gSWYgdXNpbmcgdHlwZWFoZWFkLCBvbmNlIHRoZSB0YWcgaGFzIGJlZW4gYWRkZWQsIGNsZWFyIHRoZSB0eXBlYWhlYWQgdmFsdWUgc28gaXQgZG9lcyBub3Qgc3RpY2sgYXJvdW5kIGluIHRoZSBpbnB1dC5cbiAgICAgIGlmICgkKCcudHlwZWFoZWFkLCAudHdpdHRlci10eXBlYWhlYWQnLCBzZWxmLiRjb250YWluZXIpLmxlbmd0aCkge1xuICAgICAgICBzZWxmLiRpbnB1dC50eXBlYWhlYWQoJ3ZhbCcsICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNJbml0KSB7XG4gICAgICAgIHNlbGYuJGVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KCdpdGVtQWRkZWRPbkluaXQnLCB7IGl0ZW06IGl0ZW0sIG9wdGlvbnM6IG9wdGlvbnMgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCQuRXZlbnQoJ2l0ZW1BZGRlZCcsIHsgaXRlbTogaXRlbSwgb3B0aW9uczogb3B0aW9ucyB9KSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGl0ZW0uIFBhc3MgdHJ1ZSB0byBkb250UHVzaFZhbCB0byBwcmV2ZW50IHVwZGF0aW5nIHRoZVxuICAgICAqIGVsZW1lbnRzIHZhbCgpXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihpdGVtLCBkb250UHVzaFZhbCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5vYmplY3RJdGVtcykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgaXRlbSA9ICQuZ3JlcChzZWxmLml0ZW1zQXJyYXksIGZ1bmN0aW9uKG90aGVyKSB7IHJldHVybiBzZWxmLm9wdGlvbnMuaXRlbVZhbHVlKG90aGVyKSA9PSAgc2VsZi5vcHRpb25zLml0ZW1WYWx1ZShpdGVtKTsgfSApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaXRlbSA9ICQuZ3JlcChzZWxmLml0ZW1zQXJyYXksIGZ1bmN0aW9uKG90aGVyKSB7IHJldHVybiBzZWxmLm9wdGlvbnMuaXRlbVZhbHVlKG90aGVyKSA9PSAgaXRlbTsgfSApO1xuXG4gICAgICAgIGl0ZW0gPSBpdGVtW2l0ZW0ubGVuZ3RoLTFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB2YXIgYmVmb3JlSXRlbVJlbW92ZUV2ZW50ID0gJC5FdmVudCgnYmVmb3JlSXRlbVJlbW92ZScsIHsgaXRlbTogaXRlbSwgY2FuY2VsOiBmYWxzZSwgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKGJlZm9yZUl0ZW1SZW1vdmVFdmVudCk7XG4gICAgICAgIGlmIChiZWZvcmVJdGVtUmVtb3ZlRXZlbnQuY2FuY2VsKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAkKCcudGFnJywgc2VsZi4kY29udGFpbmVyKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiAkKHRoaXMpLmRhdGEoJ2l0ZW0nKSA9PT0gaXRlbTsgfSkucmVtb3ZlKCk7XG4gICAgICAgICQoJ29wdGlvbicsIHNlbGYuJGVsZW1lbnQpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuICQodGhpcykuZGF0YSgnaXRlbScpID09PSBpdGVtOyB9KS5yZW1vdmUoKTtcbiAgICAgICAgaWYoJC5pbkFycmF5KGl0ZW0sIHNlbGYuaXRlbXNBcnJheSkgIT09IC0xKVxuICAgICAgICAgIHNlbGYuaXRlbXNBcnJheS5zcGxpY2UoJC5pbkFycmF5KGl0ZW0sIHNlbGYuaXRlbXNBcnJheSksIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbnRQdXNoVmFsKVxuICAgICAgICBzZWxmLnB1c2hWYWwoKTtcblxuICAgICAgLy8gUmVtb3ZlIGNsYXNzIHdoZW4gcmVhY2hlZCBtYXhUYWdzXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLm1heFRhZ3MgPiBzZWxmLml0ZW1zQXJyYXkubGVuZ3RoKVxuICAgICAgICBzZWxmLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ2Jvb3RzdHJhcC10YWdzaW5wdXQtbWF4Jyk7XG5cbiAgICAgIHNlbGYuJGVsZW1lbnQudHJpZ2dlcigkLkV2ZW50KCdpdGVtUmVtb3ZlZCcsICB7IGl0ZW06IGl0ZW0sIG9wdGlvbnM6IG9wdGlvbnMgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtc1xuICAgICAqL1xuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICQoJy50YWcnLCBzZWxmLiRjb250YWluZXIpLnJlbW92ZSgpO1xuICAgICAgJCgnb3B0aW9uJywgc2VsZi4kZWxlbWVudCkucmVtb3ZlKCk7XG5cbiAgICAgIHdoaWxlKHNlbGYuaXRlbXNBcnJheS5sZW5ndGggPiAwKVxuICAgICAgICBzZWxmLml0ZW1zQXJyYXkucG9wKCk7XG5cbiAgICAgIHNlbGYucHVzaFZhbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIHRhZ3Mgc28gdGhleSBtYXRjaCB0aGUgdGV4dC92YWx1ZSBvZiB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAgICogaXRlbS5cbiAgICAgKi9cbiAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICQoJy50YWcnLCBzZWxmLiRjb250YWluZXIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkdGFnID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGl0ZW0gPSAkdGFnLmRhdGEoJ2l0ZW0nKSxcbiAgICAgICAgICAgIGl0ZW1WYWx1ZSA9IHNlbGYub3B0aW9ucy5pdGVtVmFsdWUoaXRlbSksXG4gICAgICAgICAgICBpdGVtVGV4dCA9IHNlbGYub3B0aW9ucy5pdGVtVGV4dChpdGVtKSxcbiAgICAgICAgICAgIHRhZ0NsYXNzID0gc2VsZi5vcHRpb25zLnRhZ0NsYXNzKGl0ZW0pO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRhZydzIGNsYXNzIGFuZCBpbm5lciB0ZXh0XG4gICAgICAgICAgJHRhZy5hdHRyKCdjbGFzcycsIG51bGwpO1xuICAgICAgICAgICR0YWcuYWRkQ2xhc3MoJ3RhZyAnICsgaHRtbEVuY29kZSh0YWdDbGFzcykpO1xuICAgICAgICAgICR0YWcuY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlVHlwZSA9PSAzO1xuICAgICAgICAgIH0pWzBdLm5vZGVWYWx1ZSA9IGh0bWxFbmNvZGUoaXRlbVRleHQpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuaXNTZWxlY3QpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSAkKCdvcHRpb24nLCBzZWxmLiRlbGVtZW50KS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiAkKHRoaXMpLmRhdGEoJ2l0ZW0nKSA9PT0gaXRlbTsgfSk7XG4gICAgICAgICAgICBvcHRpb24uYXR0cigndmFsdWUnLCBpdGVtVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtcyBhZGRlZCBhcyB0YWdzXG4gICAgICovXG4gICAgaXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNBcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXNzZW1ibHkgdmFsdWUgYnkgcmV0cmlldmluZyB0aGUgdmFsdWUgb2YgZWFjaCBpdGVtLCBhbmQgc2V0IGl0IG9uIHRoZVxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG4gICAgcHVzaFZhbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgdmFsID0gJC5tYXAoc2VsZi5pdGVtcygpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLml0ZW1WYWx1ZShpdGVtKS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICBzZWxmLiRlbGVtZW50LnZhbCh2YWwsIHRydWUpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFncyBpbnB1dCBiZWhhdmlvdXIgb24gdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBidWlsZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBzZWxmLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgLy8gV2hlbiBpdGVtVmFsdWUgaXMgc2V0LCBmcmVlSW5wdXQgc2hvdWxkIGFsd2F5cyBiZSBmYWxzZVxuICAgICAgaWYgKHNlbGYub2JqZWN0SXRlbXMpXG4gICAgICAgIHNlbGYub3B0aW9ucy5mcmVlSW5wdXQgPSBmYWxzZTtcblxuICAgICAgbWFrZU9wdGlvbkl0ZW1GdW5jdGlvbihzZWxmLm9wdGlvbnMsICdpdGVtVmFsdWUnKTtcbiAgICAgIG1ha2VPcHRpb25JdGVtRnVuY3Rpb24oc2VsZi5vcHRpb25zLCAnaXRlbVRleHQnKTtcbiAgICAgIG1ha2VPcHRpb25GdW5jdGlvbihzZWxmLm9wdGlvbnMsICd0YWdDbGFzcycpO1xuXG4gICAgICAvLyBUeXBlYWhlYWQgQm9vdHN0cmFwIHZlcnNpb24gMi4zLjJcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZWFoZWFkKSB7XG4gICAgICAgIHZhciB0eXBlYWhlYWQgPSBzZWxmLm9wdGlvbnMudHlwZWFoZWFkIHx8IHt9O1xuXG4gICAgICAgIG1ha2VPcHRpb25GdW5jdGlvbih0eXBlYWhlYWQsICdzb3VyY2UnKTtcblxuICAgICAgICBzZWxmLiRpbnB1dC50eXBlYWhlYWQoJC5leHRlbmQoe30sIHR5cGVhaGVhZCwge1xuICAgICAgICAgIHNvdXJjZTogZnVuY3Rpb24gKHF1ZXJ5LCBwcm9jZXNzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHRzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2VsZi5vcHRpb25zLml0ZW1UZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBtYXBbdGV4dF0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB0ZXh0cy5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb2Nlc3ModGV4dHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlYWhlYWQuc291cmNlKHF1ZXJ5KTtcblxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihkYXRhLnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIEFuZ3VsYXIgY2FsbGJhY2tzXG4gICAgICAgICAgICAgIGRhdGEuc3VjY2Vzcyhwcm9jZXNzSXRlbXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzRnVuY3Rpb24oZGF0YS50aGVuKSkge1xuICAgICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBBbmd1bGFyIHByb21pc2VzXG4gICAgICAgICAgICAgIGRhdGEudGhlbihwcm9jZXNzSXRlbXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgZnVuY3Rpb25zIGFuZCBqcXVlcnkgcHJvbWlzZXNcbiAgICAgICAgICAgICAgJC53aGVuKGRhdGEpXG4gICAgICAgICAgICAgICAudGhlbihwcm9jZXNzSXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBkYXRlcjogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkKHRoaXMubWFwW3RleHRdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFt0ZXh0XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMucXVlcnkudHJpbSgpLnRvTG93ZXJDYXNlKCkpICE9PSAtMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzb3J0ZXI6IGZ1bmN0aW9uICh0ZXh0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRzLnNvcnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhpZ2hsaWdodGVyOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggJygnICsgdGhpcy5xdWVyeSArICcpJywgJ2dpJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSggcmVnZXgsIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGVhaGVhZC5qc1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy50eXBlYWhlYWRqcykge1xuICAgICAgICAgIHZhciB0eXBlYWhlYWRDb25maWcgPSBudWxsO1xuICAgICAgICAgIHZhciB0eXBlYWhlYWREYXRhc2V0cyA9IHt9O1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIG1haW4gY29uZmlndXJhdGlvbnMgd2VyZSBwYXNzZWQgb3Igc2ltcGx5IGEgZGF0YXNldFxuICAgICAgICAgIHZhciB0eXBlYWhlYWRqcyA9IHNlbGYub3B0aW9ucy50eXBlYWhlYWRqcztcbiAgICAgICAgICBpZiAoJC5pc0FycmF5KHR5cGVhaGVhZGpzKSkge1xuICAgICAgICAgICAgdHlwZWFoZWFkQ29uZmlnID0gdHlwZWFoZWFkanNbMF07XG4gICAgICAgICAgICB0eXBlYWhlYWREYXRhc2V0cyA9IHR5cGVhaGVhZGpzWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlYWhlYWREYXRhc2V0cyA9IHR5cGVhaGVhZGpzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuJGlucHV0LnR5cGVhaGVhZCh0eXBlYWhlYWRDb25maWcsIHR5cGVhaGVhZERhdGFzZXRzKS5vbigndHlwZWFoZWFkOnNlbGVjdGVkJywgJC5wcm94eShmdW5jdGlvbiAob2JqLCBkYXR1bSkge1xuICAgICAgICAgICAgaWYgKHR5cGVhaGVhZERhdGFzZXRzLnZhbHVlS2V5KVxuICAgICAgICAgICAgICBzZWxmLmFkZChkYXR1bVt0eXBlYWhlYWREYXRhc2V0cy52YWx1ZUtleV0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBzZWxmLmFkZChkYXR1bSk7XG4gICAgICAgICAgICBzZWxmLiRpbnB1dC50eXBlYWhlYWQoJ3ZhbCcsICcnKTtcbiAgICAgICAgICB9LCBzZWxmKSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGNvbnRhaW5lci5vbignY2xpY2snLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghIHNlbGYuJGVsZW1lbnQuYXR0cignZGlzYWJsZWQnKSkge1xuICAgICAgICAgIHNlbGYuJGlucHV0LnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi4kaW5wdXQuZm9jdXMoKTtcbiAgICAgIH0sIHNlbGYpKTtcblxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmFkZE9uQmx1ciAmJiBzZWxmLm9wdGlvbnMuZnJlZUlucHV0KSB7XG4gICAgICAgICAgc2VsZi4kaW5wdXQub24oJ2ZvY3Vzb3V0JywgJC5wcm94eShmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAvLyBIQUNLOiBvbmx5IHByb2Nlc3Mgb24gZm9jdXNvdXQgd2hlbiBubyB0eXBlYWhlYWQgb3BlbmVkLCB0b1xuICAgICAgICAgICAgICAvLyAgICAgICBhdm9pZCBhZGRpbmcgdGhlIHR5cGVhaGVhZCB0ZXh0IGFzIHRhZ1xuICAgICAgICAgICAgICBpZiAoJCgnLnR5cGVhaGVhZCwgLnR3aXR0ZXItdHlwZWFoZWFkJywgc2VsZi4kY29udGFpbmVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZChzZWxmLiRpbnB1dC52YWwoKSk7XG4gICAgICAgICAgICAgICAgc2VsZi4kaW5wdXQudmFsKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlbGYpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgIHNlbGYuJGNvbnRhaW5lci5vbigna2V5ZG93bicsICdpbnB1dCcsICQucHJveHkoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyICRpbnB1dCA9ICQoZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgICRpbnB1dFdyYXBwZXIgPSBzZWxmLmZpbmRJbnB1dFdyYXBwZXIoKTtcblxuICAgICAgICBpZiAoc2VsZi4kZWxlbWVudC5hdHRyKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgc2VsZi4kaW5wdXQuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgLy8gQkFDS1NQQUNFXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKGRvR2V0Q2FyZXRQb3NpdGlvbigkaW5wdXRbMF0pID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gJGlucHV0V3JhcHBlci5wcmV2KCk7XG4gICAgICAgICAgICAgIGlmIChwcmV2Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlKHByZXYuZGF0YSgnaXRlbScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBERUxFVEVcbiAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgaWYgKGRvR2V0Q2FyZXRQb3NpdGlvbigkaW5wdXRbMF0pID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gJGlucHV0V3JhcHBlci5uZXh0KCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlKG5leHQuZGF0YSgnaXRlbScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBMRUZUIEFSUk9XXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIC8vIFRyeSB0byBtb3ZlIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHByZXZpb3VzIHRhZ1xuICAgICAgICAgICAgdmFyICRwcmV2VGFnID0gJGlucHV0V3JhcHBlci5wcmV2KCk7XG4gICAgICAgICAgICBpZiAoJGlucHV0LnZhbCgpLmxlbmd0aCA9PT0gMCAmJiAkcHJldlRhZ1swXSkge1xuICAgICAgICAgICAgICAkcHJldlRhZy5iZWZvcmUoJGlucHV0V3JhcHBlcik7XG4gICAgICAgICAgICAgICRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gUklHSFQgQVJST1dcbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1vdmUgdGhlIGlucHV0IGFmdGVyIHRoZSBuZXh0IHRhZ1xuICAgICAgICAgICAgdmFyICRuZXh0VGFnID0gJGlucHV0V3JhcHBlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoJGlucHV0LnZhbCgpLmxlbmd0aCA9PT0gMCAmJiAkbmV4dFRhZ1swXSkge1xuICAgICAgICAgICAgICAkbmV4dFRhZy5hZnRlcigkaW5wdXRXcmFwcGVyKTtcbiAgICAgICAgICAgICAgJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgaW50ZXJuYWwgaW5wdXQncyBzaXplXG4gICAgICAgIHZhciB0ZXh0TGVuZ3RoID0gJGlucHV0LnZhbCgpLmxlbmd0aCxcbiAgICAgICAgICAgIHdvcmRTcGFjZSA9IE1hdGguY2VpbCh0ZXh0TGVuZ3RoIC8gNSksXG4gICAgICAgICAgICBzaXplID0gdGV4dExlbmd0aCArIHdvcmRTcGFjZSArIDE7XG4gICAgICAgICRpbnB1dC5hdHRyKCdzaXplJywgTWF0aC5tYXgodGhpcy5pbnB1dFNpemUsICRpbnB1dC52YWwoKS5sZW5ndGgpKTtcbiAgICAgIH0sIHNlbGYpKTtcblxuICAgICAgc2VsZi4kY29udGFpbmVyLm9uKCdrZXlwcmVzcycsICdpbnB1dCcsICQucHJveHkoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgIHZhciAkaW5wdXQgPSAkKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgIGlmIChzZWxmLiRlbGVtZW50LmF0dHIoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHNlbGYuJGlucHV0LmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciB0ZXh0ID0gJGlucHV0LnZhbCgpLFxuICAgICAgICAgbWF4TGVuZ3RoUmVhY2hlZCA9IHNlbGYub3B0aW9ucy5tYXhDaGFycyAmJiB0ZXh0Lmxlbmd0aCA+PSBzZWxmLm9wdGlvbnMubWF4Q2hhcnM7XG4gICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmZyZWVJbnB1dCAmJiAoa2V5Q29tYmluYXRpb25Jbkxpc3QoZXZlbnQsIHNlbGYub3B0aW9ucy5jb25maXJtS2V5cykgfHwgbWF4TGVuZ3RoUmVhY2hlZCkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBhZGQgYSB0YWcgaWYgdGhlcmUgaXMgZGF0YSBpbiB0aGUgZmllbGRcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgc2VsZi5hZGQobWF4TGVuZ3RoUmVhY2hlZCA/IHRleHQuc3Vic3RyKDAsIHNlbGYub3B0aW9ucy5tYXhDaGFycykgOiB0ZXh0KTtcbiAgICAgICAgICAgICAgICRpbnB1dC52YWwoJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmllbGQgaXMgZW1wdHksIGxldCB0aGUgZXZlbnQgdHJpZ2dlcmVkIGZpcmUgYXMgdXN1YWxcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY2FuY2VsQ29uZmlybUtleXNPbkVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIFJlc2V0IGludGVybmFsIGlucHV0J3Mgc2l6ZVxuICAgICAgICAgdmFyIHRleHRMZW5ndGggPSAkaW5wdXQudmFsKCkubGVuZ3RoLFxuICAgICAgICAgICAgd29yZFNwYWNlID0gTWF0aC5jZWlsKHRleHRMZW5ndGggLyA1KSxcbiAgICAgICAgICAgIHNpemUgPSB0ZXh0TGVuZ3RoICsgd29yZFNwYWNlICsgMTtcbiAgICAgICAgICRpbnB1dC5hdHRyKCdzaXplJywgTWF0aC5tYXgodGhpcy5pbnB1dFNpemUsICRpbnB1dC52YWwoKS5sZW5ndGgpKTtcbiAgICAgIH0sIHNlbGYpKTtcblxuICAgICAgLy8gUmVtb3ZlIGljb24gY2xpY2tlZFxuICAgICAgc2VsZi4kY29udGFpbmVyLm9uKCdjbGljaycsICdbZGF0YS1yb2xlPXJlbW92ZV0nLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChzZWxmLiRlbGVtZW50LmF0dHIoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZW1vdmUoJChldmVudC50YXJnZXQpLmNsb3Nlc3QoJy50YWcnKS5kYXRhKCdpdGVtJykpO1xuICAgICAgfSwgc2VsZikpO1xuXG4gICAgICAvLyBPbmx5IGFkZCBleGlzdGluZyB2YWx1ZSBhcyB0YWdzIHdoZW4gdXNpbmcgc3RyaW5ncyBhcyB0YWdzXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLml0ZW1WYWx1ZSA9PT0gZGVmYXVsdE9wdGlvbnMuaXRlbVZhbHVlKSB7XG4gICAgICAgIGlmIChzZWxmLiRlbGVtZW50WzBdLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkKHNlbGYuJGVsZW1lbnQudmFsKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQoJ29wdGlvbicsIHNlbGYuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmFkZCgkKHRoaXMpLmF0dHIoJ3ZhbHVlJyksIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRhZ3NpbnB1dCBiZWhhdmlvdXIgYW5kIHVucmVnc2l0ZXIgYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFVuYmluZCBldmVudHNcbiAgICAgIHNlbGYuJGNvbnRhaW5lci5vZmYoJ2tleXByZXNzJywgJ2lucHV0Jyk7XG4gICAgICBzZWxmLiRjb250YWluZXIub2ZmKCdjbGljaycsICdbcm9sZT1yZW1vdmVdJyk7XG5cbiAgICAgIHNlbGYuJGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIHNlbGYuJGVsZW1lbnQucmVtb3ZlRGF0YSgndGFnc2lucHV0Jyk7XG4gICAgICBzZWxmLiRlbGVtZW50LnNob3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBmb2N1cyBvbiB0aGUgdGFnc2lucHV0XG4gICAgICovXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgaW5wdXQgZWxlbWVudFxuICAgICAqL1xuICAgIGlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRpbnB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgaW50ZXJuYWwgaW5wdXQuIFRoaXNcbiAgICAgKiBpcyBub3JtYWxseSB0aGUgJGNvbnRhaW5lciwgYnV0IHR5cGVhaGVhZC5qcyBtb3ZlcyB0aGUgJGlucHV0IGVsZW1lbnQuXG4gICAgICovXG4gICAgZmluZElucHV0V3JhcHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWx0ID0gdGhpcy4kaW5wdXRbMF0sXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy4kY29udGFpbmVyWzBdO1xuICAgICAgd2hpbGUoZWx0ICYmIGVsdC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpXG4gICAgICAgIGVsdCA9IGVsdC5wYXJlbnROb2RlO1xuXG4gICAgICByZXR1cm4gJChlbHQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgSlF1ZXJ5IHBsdWdpblxuICAgKi9cbiAgJC5mbi50YWdzaW5wdXQgPSBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YWdzaW5wdXQgPSAkKHRoaXMpLmRhdGEoJ3RhZ3NpbnB1dCcpO1xuICAgICAgLy8gSW5pdGlhbGl6ZSBhIG5ldyB0YWdzIGlucHV0XG4gICAgICBpZiAoIXRhZ3NpbnB1dCkge1xuICAgICAgICAgIHRhZ3NpbnB1dCA9IG5ldyBUYWdzSW5wdXQodGhpcywgYXJnMSk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKCd0YWdzaW5wdXQnLCB0YWdzaW5wdXQpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0YWdzaW5wdXQpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgJCgnb3B0aW9uJywgJCh0aGlzKSkuYXR0cignc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbml0IHRhZ3MgZnJvbSAkKHRoaXMpLnZhbCgpXG4gICAgICAgICAgJCh0aGlzKS52YWwoJCh0aGlzKS52YWwoKSk7XG4gICAgICB9IGVsc2UgaWYgKCFhcmcxICYmICFhcmcyKSB7XG4gICAgICAgICAgLy8gdGFnc2lucHV0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgLy8gbm8gZnVuY3Rpb24sIHRyeWluZyB0byBpbml0XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRhZ3NpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYodGFnc2lucHV0W2FyZzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBJbnZva2UgZnVuY3Rpb24gb24gZXhpc3RpbmcgdGFncyBpbnB1dFxuICAgICAgICAgICAgaWYodGFnc2lucHV0W2FyZzFdLmxlbmd0aCA9PT0gMyAmJiBhcmczICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHRhZ3NpbnB1dFthcmcxXShhcmcyLCBudWxsLCBhcmczKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHRhZ3NpbnB1dFthcmcxXShhcmcyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmV0VmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXRWYWwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCB0eXBlb2YgYXJnMSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIGZyb20gdGhlIGludm9rZWQgZnVuY3Rpb24gY2FsbHNcbiAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9O1xuXG4gICQuZm4udGFnc2lucHV0LkNvbnN0cnVjdG9yID0gVGFnc0lucHV0O1xuXG4gIC8qKlxuICAgKiBNb3N0IG9wdGlvbnMgc3VwcG9ydCBib3RoIGEgc3RyaW5nIG9yIG51bWJlciBhcyB3ZWxsIGFzIGEgZnVuY3Rpb24gYXNcbiAgICogb3B0aW9uIHZhbHVlLiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB0aGUgb3B0aW9uIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBpbiB0aGUgZ2l2ZW4gb3B0aW9ucyBpcyB3cmFwcGVkIGluIGEgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VPcHRpb25JdGVtRnVuY3Rpb24ob3B0aW9ucywga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBvcHRpb25zW2tleV07XG4gICAgICBvcHRpb25zW2tleV0gPSBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtW3Byb3BlcnR5TmFtZV07IH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1ha2VPcHRpb25GdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgb3B0aW9uc1trZXldID0gZnVuY3Rpb24oKSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEh0bWxFbmNvZGVzIHRoZSBnaXZlbiB2YWx1ZVxuICAgKi9cbiAgdmFyIGh0bWxFbmNvZGVDb250YWluZXIgPSAkKCc8ZGl2IC8+Jyk7XG4gIGZ1bmN0aW9uIGh0bWxFbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBodG1sRW5jb2RlQ29udGFpbmVyLnRleHQodmFsdWUpLmh0bWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQgaW4gdGhlIGdpdmVuIGlucHV0IGZpZWxkXG4gICAqIGh0dHA6Ly9mbGlnaHRzY2hvb2wuYWN5bHQuY29tL2Rldm5vdGVzL2NhcmV0LXBvc2l0aW9uLXdvZXMvXG4gICAqL1xuICBmdW5jdGlvbiBkb0dldENhcmV0UG9zaXRpb24ob0ZpZWxkKSB7XG4gICAgdmFyIGlDYXJldFBvcyA9IDA7XG4gICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgb0ZpZWxkLmZvY3VzICgpO1xuICAgICAgdmFyIG9TZWwgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIG9TZWwubW92ZVN0YXJ0ICgnY2hhcmFjdGVyJywgLW9GaWVsZC52YWx1ZS5sZW5ndGgpO1xuICAgICAgaUNhcmV0UG9zID0gb1NlbC50ZXh0Lmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKG9GaWVsZC5zZWxlY3Rpb25TdGFydCB8fCBvRmllbGQuc2VsZWN0aW9uU3RhcnQgPT0gJzAnKSB7XG4gICAgICBpQ2FyZXRQb3MgPSBvRmllbGQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiAoaUNhcmV0UG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgICogUmV0dXJucyBib29sZWFuIGluZGljYXRlcyB3aGV0aGVyIHVzZXIgaGFzIHByZXNzZWQgYW4gZXhwZWN0ZWQga2V5IGNvbWJpbmF0aW9uLlxuICAgICogQHBhcmFtIG9iamVjdCBrZXlQcmVzc0V2ZW50OiBKYXZhU2NyaXB0IGV2ZW50IG9iamVjdCwgcmVmZXJcbiAgICAqICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICAqIEBwYXJhbSBvYmplY3QgbG9va3VwTGlzdDogZXhwZWN0ZWQga2V5IGNvbWJpbmF0aW9ucywgYXMgaW46XG4gICAgKiAgICAgWzEzLCB7d2hpY2g6IDE4OCwgc2hpZnRLZXk6IHRydWV9XVxuICAgICovXG4gIGZ1bmN0aW9uIGtleUNvbWJpbmF0aW9uSW5MaXN0KGtleVByZXNzRXZlbnQsIGxvb2t1cExpc3QpIHtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgJC5lYWNoKGxvb2t1cExpc3QsIGZ1bmN0aW9uIChpbmRleCwga2V5Q29tYmluYXRpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIChrZXlDb21iaW5hdGlvbikgPT09ICdudW1iZXInICYmIGtleVByZXNzRXZlbnQud2hpY2ggPT09IGtleUNvbWJpbmF0aW9uKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlQcmVzc0V2ZW50LndoaWNoID09PSBrZXlDb21iaW5hdGlvbi53aGljaCkge1xuICAgICAgICAgICAgICB2YXIgYWx0ID0gIWtleUNvbWJpbmF0aW9uLmhhc093blByb3BlcnR5KCdhbHRLZXknKSB8fCBrZXlQcmVzc0V2ZW50LmFsdEtleSA9PT0ga2V5Q29tYmluYXRpb24uYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgc2hpZnQgPSAha2V5Q29tYmluYXRpb24uaGFzT3duUHJvcGVydHkoJ3NoaWZ0S2V5JykgfHwga2V5UHJlc3NFdmVudC5zaGlmdEtleSA9PT0ga2V5Q29tYmluYXRpb24uc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICBjdHJsID0gIWtleUNvbWJpbmF0aW9uLmhhc093blByb3BlcnR5KCdjdHJsS2V5JykgfHwga2V5UHJlc3NFdmVudC5jdHJsS2V5ID09PSBrZXlDb21iaW5hdGlvbi5jdHJsS2V5O1xuICAgICAgICAgICAgICBpZiAoYWx0ICYmIHNoaWZ0ICYmIGN0cmwpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0YWdzaW5wdXQgYmVoYXZpb3VyIG9uIGlucHV0cyBhbmQgc2VsZWN0cyB3aGljaCBoYXZlXG4gICAqIGRhdGEtcm9sZT10YWdzaW5wdXRcbiAgICovXG4gICQoZnVuY3Rpb24oKSB7XG4gICAgJChcImlucHV0W2RhdGEtcm9sZT10YWdzaW5wdXRdLCBzZWxlY3RbbXVsdGlwbGVdW2RhdGEtcm9sZT10YWdzaW5wdXRdXCIpLnRhZ3NpbnB1dCgpO1xuICB9KTtcbn0pKHdpbmRvdy5qUXVlcnkpO1xuIiwiLypcclxuICogIEJvb3RzdHJhcCBEdWFsbGlzdGJveCAtIHY0LjAuMlxyXG4gKiAgQSByZXNwb25zaXZlIGR1YWwgbGlzdGJveCB3aWRnZXQgb3B0aW1pemVkIGZvciBUd2l0dGVyIEJvb3RzdHJhcC4gSXQgd29ya3Mgb24gYWxsIG1vZGVybiBicm93c2VycyBhbmQgb24gdG91Y2ggZGV2aWNlcy5cclxuICogIGh0dHA6Ly93d3cudmlydHVvc29mdC5ldS9jb2RlL2Jvb3RzdHJhcC1kdWFsbGlzdGJveC9cclxuICpcclxuICogIE1hZGUgYnkgSXN0dsOhbiBVamotTcOpc3rDoXJvc1xyXG4gKiAgVW5kZXIgQXBhY2hlIExpY2Vuc2UgdjIuMCBMaWNlbnNlXHJcbiAqL1xyXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyb290LCBqUXVlcnkpIHtcbiAgICAgIGlmIChqUXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKShyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgfVxufShmdW5jdGlvbigkKSB7XG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdHMgb25jZVxuICB2YXIgcGx1Z2luTmFtZSA9ICdib290c3RyYXBEdWFsTGlzdGJveCcsXG4gICAgZGVmYXVsdHMgPSB7XG4gICAgICBmaWx0ZXJUZXh0Q2xlYXI6ICdzaG93IGFsbCcsXG4gICAgICBmaWx0ZXJQbGFjZUhvbGRlcjogJ0ZpbHRlcicsXG4gICAgICBtb3ZlU2VsZWN0ZWRMYWJlbDogJ01vdmUgc2VsZWN0ZWQnLFxuICAgICAgbW92ZUFsbExhYmVsOiAnTW92ZSBhbGwnLFxuICAgICAgcmVtb3ZlU2VsZWN0ZWRMYWJlbDogJ1JlbW92ZSBzZWxlY3RlZCcsXG4gICAgICByZW1vdmVBbGxMYWJlbDogJ1JlbW92ZSBhbGwnLFxuICAgICAgbW92ZU9uU2VsZWN0OiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZS9mYWxzZSAoZm9yY2VkIHRydWUgb24gYW5kcm9pZHMsIHNlZSB0aGUgY29tbWVudCBsYXRlcilcbiAgICAgIG1vdmVPbkRvdWJsZUNsaWNrOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUvZmFsc2UgKGZvcmNlZCBmYWxzZSBvbiBhbmRyb2lkcywgY2F1c2UgbW92ZU9uU2VsZWN0IGlzIGZvcmNlZCB0byB0cnVlKVxuICAgICAgcHJlc2VydmVTZWxlY3Rpb25Pbk1vdmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2FsbCcgLyAnbW92ZWQnIC8gZmFsc2VcbiAgICAgIHNlbGVjdGVkTGlzdExhYmVsOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzdHJpbmcnLCBmYWxzZVxuICAgICAgbm9uU2VsZWN0ZWRMaXN0TGFiZWw6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3N0cmluZycsIGZhbHNlXG4gICAgICBoZWxwZXJTZWxlY3ROYW1lUG9zdGZpeDogJ19oZWxwZXInLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc3RyaW5nX29mX3Bvc3RmaXgnIC8gZmFsc2VcbiAgICAgIHNlbGVjdG9yTWluaW1hbEhlaWdodDogMTAwLFxuICAgICAgc2hvd0ZpbHRlcklucHV0czogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hldGhlciB0byBzaG93IGZpbHRlciBpbnB1dHNcbiAgICAgIG5vblNlbGVjdGVkRmlsdGVyOiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZywgZmlsdGVyIHRoZSBub24gc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgc2VsZWN0ZWRGaWx0ZXI6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBmaWx0ZXIgdGhlIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgIGluZm9UZXh0OiAnU2hvd2luZyBhbGwgezB9JywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRleHQgd2hlbiBhbGwgb3B0aW9ucyBhcmUgdmlzaWJsZSAvIGZhbHNlIGZvciBubyBpbmZvIHRleHRcbiAgICAgIGluZm9UZXh0RmlsdGVyZWQ6ICc8c3BhbiBjbGFzcz1cImJhZGdlIGJhZGdlLXdhcm5pbmdcIj5GaWx0ZXJlZDwvc3Bhbj4gezB9IGZyb20gezF9JywgLy8gd2hlbiBub3QgYWxsIG9mIHRoZSBvcHRpb25zIGFyZSB2aXNpYmxlIGR1ZSB0byB0aGUgZmlsdGVyXG4gICAgICBpbmZvVGV4dEVtcHR5OiAnRW1wdHkgbGlzdCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZXJlIGFyZSBubyBvcHRpb25zIHByZXNlbnQgaW4gdGhlIGxpc3RcbiAgICAgIGZpbHRlck9uVmFsdWVzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBieSBzZWxlY3RvcidzIHZhbHVlcywgYm9vbGVhblxuICAgICAgc29ydEJ5SW5wdXRPcmRlcjogZmFsc2UsXG4gICAgICBldmVudE1vdmVPdmVycmlkZTogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib29sZWFuLCBhbGxvd3MgdXNlciB0byB1bmJpbmQgZGVmYXVsdCBldmVudCBiZWhhdmlvdXIgYW5kIHJ1biB0aGVpciBvd24gaW5zdGVhZFxuICAgICAgZXZlbnRNb3ZlQWxsT3ZlcnJpZGU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9vbGVhbiwgYWxsb3dzIHVzZXIgdG8gdW5iaW5kIGRlZmF1bHQgZXZlbnQgYmVoYXZpb3VyIGFuZCBydW4gdGhlaXIgb3duIGluc3RlYWRcbiAgICAgIGV2ZW50UmVtb3ZlT3ZlcnJpZGU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvb2xlYW4sIGFsbG93cyB1c2VyIHRvIHVuYmluZCBkZWZhdWx0IGV2ZW50IGJlaGF2aW91ciBhbmQgcnVuIHRoZWlyIG93biBpbnN0ZWFkXG4gICAgICBldmVudFJlbW92ZUFsbE92ZXJyaWRlOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib29sZWFuLCBhbGxvd3MgdXNlciB0byB1bmJpbmQgZGVmYXVsdCBldmVudCBiZWhhdmlvdXIgYW5kIHJ1biB0aGVpciBvd24gaW5zdGVhZFxuICAgICAgYnRuQ2xhc3M6ICdidG4tb3V0bGluZS1zZWNvbmRhcnknLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgYnV0dG9uIHN0eWxlIGNsYXNzIGZvciBhbGwgdGhlIGJ1dHRvbnNcbiAgICAgIGJ0bk1vdmVUZXh0OiAnJmd0OycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZywgc2V0cyB0aGUgdGV4dCBmb3IgdGhlIFwiTW92ZVwiIGJ1dHRvblxuICAgICAgYnRuUmVtb3ZlVGV4dDogJyZsdDsnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBzZXRzIHRoZSB0ZXh0IGZvciB0aGUgXCJSZW1vdmVcIiBidXR0b25cbiAgICAgIGJ0bk1vdmVBbGxUZXh0OiAnJmd0OyZndDsnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZywgc2V0cyB0aGUgdGV4dCBmb3IgdGhlIFwiTW92ZSBBbGxcIiBidXR0b25cbiAgICAgIGJ0blJlbW92ZUFsbFRleHQ6ICcmbHQ7Jmx0OycgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZywgc2V0cyB0aGUgdGV4dCBmb3IgdGhlIFwiUmVtb3ZlIEFsbFwiIGJ1dHRvblxuICAgIH0sXG4gICAgLy8gU2VsZWN0aW9ucyBhcmUgaW52aXNpYmxlIG9uIGFuZHJvaWQgaWYgdGhlIGNvbnRhaW5pbmcgc2VsZWN0IGlzIHN0eWxlZCB3aXRoIENTU1xuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTY5MjJcbiAgICBpc0J1Z2d5QW5kcm9pZCA9IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG4gIC8vIFRoZSBhY3R1YWwgcGx1Z2luIGNvbnN0cnVjdG9yXG4gIGZ1bmN0aW9uIEJvb3RzdHJhcER1YWxMaXN0Ym94KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIC8vIGpRdWVyeSBoYXMgYW4gZXh0ZW5kIG1ldGhvZCB3aGljaCBtZXJnZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvclxuICAgIC8vIG1vcmUgb2JqZWN0cywgc3RvcmluZyB0aGUgcmVzdWx0IGluIHRoZSBmaXJzdCBvYmplY3QuIFRoZSBmaXJzdCBvYmplY3RcbiAgICAvLyBpcyBnZW5lcmFsbHkgZW1wdHkgYXMgd2UgZG9uJ3Qgd2FudCB0byBhbHRlciB0aGUgZGVmYXVsdCBvcHRpb25zIGZvclxuICAgIC8vIGZ1dHVyZSBpbnN0YW5jZXMgb2YgdGhlIHBsdWdpblxuICAgIHRoaXMuc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2RlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgdGhpcy5fbmFtZSA9IHBsdWdpbk5hbWU7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlRXZlbnQoZHVhbExpc3Rib3gpIHtcbiAgICBkdWFsTGlzdGJveC5lbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uU3RhdGVzKGR1YWxMaXN0Ym94KSB7XG4gICAgZHVhbExpc3Rib3guZWxlbWVudC5maW5kKCdvcHRpb24nKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgICB2YXIgJGl0ZW0gPSAkKGl0ZW0pO1xuICAgICAgaWYgKHR5cGVvZigkaXRlbS5kYXRhKCdvcmlnaW5hbC1pbmRleCcpKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJGl0ZW0uZGF0YSgnb3JpZ2luYWwtaW5kZXgnLCBkdWFsTGlzdGJveC5lbGVtZW50Q291bnQrKyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKCRpdGVtLmRhdGEoJ19zZWxlY3RlZCcpKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJGl0ZW0uZGF0YSgnX3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlU2VsZWN0aW9uU3RhdGUoZHVhbExpc3Rib3gsIG9yaWdpbmFsX2luZGV4LCBzZWxlY3RlZCkge1xuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJykuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcbiAgICAgIGlmICgkaXRlbS5kYXRhKCdvcmlnaW5hbC1pbmRleCcpID09PSBvcmlnaW5hbF9pbmRleCkge1xuICAgICAgICAkaXRlbS5wcm9wKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgICAgaWYoc2VsZWN0ZWQpe1xuICAgICAgICAgICRpdGVtLmF0dHIoJ2RhdGEtc29ydGluZGV4JywgZHVhbExpc3Rib3guc29ydEluZGV4KTtcbiAgICAgICAgICBkdWFsTGlzdGJveC5zb3J0SW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaXRlbS5yZW1vdmVBdHRyKCdkYXRhLXNvcnRpbmRleCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTdHJpbmcocywgYXJncykge1xuICAgIGNvbnNvbGUubG9nKHMsIGFyZ3MpO1xuICAgIHJldHVybiBzLnJlcGxhY2UoL3soXFxkKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnc1tudW1iZXJdICE9PSAndW5kZWZpbmVkJyA/IGFyZ3NbbnVtYmVyXSA6IG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaEluZm8oZHVhbExpc3Rib3gpIHtcbiAgICBpZiAoIWR1YWxMaXN0Ym94LnNldHRpbmdzLmluZm9UZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZpc2libGUxID0gZHVhbExpc3Rib3guZWxlbWVudHMuc2VsZWN0MS5maW5kKCdvcHRpb24nKS5sZW5ndGgsXG4gICAgICB2aXNpYmxlMiA9IGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDIuZmluZCgnb3B0aW9uJykubGVuZ3RoLFxuICAgICAgYWxsMSA9IGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJykubGVuZ3RoIC0gZHVhbExpc3Rib3guc2VsZWN0ZWRFbGVtZW50cyxcbiAgICAgIGFsbDIgPSBkdWFsTGlzdGJveC5zZWxlY3RlZEVsZW1lbnRzLFxuICAgICAgY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGFsbDEgPT09IDApIHtcbiAgICAgIGNvbnRlbnQgPSBkdWFsTGlzdGJveC5zZXR0aW5ncy5pbmZvVGV4dEVtcHR5O1xuICAgIH0gZWxzZSBpZiAodmlzaWJsZTEgPT09IGFsbDEpIHtcbiAgICAgIGNvbnRlbnQgPSBmb3JtYXRTdHJpbmcoZHVhbExpc3Rib3guc2V0dGluZ3MuaW5mb1RleHQsIFt2aXNpYmxlMSwgYWxsMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0U3RyaW5nKGR1YWxMaXN0Ym94LnNldHRpbmdzLmluZm9UZXh0RmlsdGVyZWQsIFt2aXNpYmxlMSwgYWxsMV0pO1xuICAgIH1cblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLmluZm8xLmh0bWwoY29udGVudCk7XG4gICAgZHVhbExpc3Rib3guZWxlbWVudHMuYm94MS50b2dnbGVDbGFzcygnZmlsdGVyZWQnLCAhKHZpc2libGUxID09PSBhbGwxIHx8IGFsbDEgPT09IDApKTtcblxuICAgIGlmIChhbGwyID09PSAwKSB7XG4gICAgICBjb250ZW50ID0gZHVhbExpc3Rib3guc2V0dGluZ3MuaW5mb1RleHRFbXB0eTtcbiAgICB9IGVsc2UgaWYgKHZpc2libGUyID09PSBhbGwyKSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0U3RyaW5nKGR1YWxMaXN0Ym94LnNldHRpbmdzLmluZm9UZXh0LCBbdmlzaWJsZTIsIGFsbDJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGZvcm1hdFN0cmluZyhkdWFsTGlzdGJveC5zZXR0aW5ncy5pbmZvVGV4dEZpbHRlcmVkLCBbdmlzaWJsZTIsIGFsbDJdKTtcbiAgICB9XG5cbiAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5pbmZvMi5odG1sKGNvbnRlbnQpO1xuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLmJveDIudG9nZ2xlQ2xhc3MoJ2ZpbHRlcmVkJywgISh2aXNpYmxlMiA9PT0gYWxsMiB8fCBhbGwyID09PSAwKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoU2VsZWN0cyhkdWFsTGlzdGJveCkge1xuICAgIGR1YWxMaXN0Ym94LnNlbGVjdGVkRWxlbWVudHMgPSAwO1xuXG4gICAgZHVhbExpc3Rib3guZWxlbWVudHMuc2VsZWN0MS5lbXB0eSgpO1xuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDIuZW1wdHkoKTtcblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJykuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcbiAgICAgIGlmICgkaXRlbS5wcm9wKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIGR1YWxMaXN0Ym94LnNlbGVjdGVkRWxlbWVudHMrKztcbiAgICAgICAgZHVhbExpc3Rib3guZWxlbWVudHMuc2VsZWN0Mi5hcHBlbmQoJGl0ZW0uY2xvbmUodHJ1ZSkucHJvcCgnc2VsZWN0ZWQnLCAkaXRlbS5kYXRhKCdfc2VsZWN0ZWQnKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHVhbExpc3Rib3guZWxlbWVudHMuc2VsZWN0MS5hcHBlbmQoJGl0ZW0uY2xvbmUodHJ1ZSkucHJvcCgnc2VsZWN0ZWQnLCAkaXRlbS5kYXRhKCdfc2VsZWN0ZWQnKSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGR1YWxMaXN0Ym94LnNldHRpbmdzLnNob3dGaWx0ZXJJbnB1dHMpIHtcbiAgICAgIGZpbHRlcihkdWFsTGlzdGJveCwgMSk7XG4gICAgICBmaWx0ZXIoZHVhbExpc3Rib3gsIDIpO1xuICAgIH1cbiAgICByZWZyZXNoSW5mbyhkdWFsTGlzdGJveCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXIoZHVhbExpc3Rib3gsIHNlbGVjdEluZGV4KSB7XG4gICAgaWYgKCFkdWFsTGlzdGJveC5zZXR0aW5ncy5zaG93RmlsdGVySW5wdXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIHNlbGVjdEluZGV4KTtcblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzWydzZWxlY3QnK3NlbGVjdEluZGV4XS5lbXB0eSgpLnNjcm9sbFRvcCgwKTtcbiAgICB2YXIgcmVnZXgsXG4gICAgICBhbGxPcHRpb25zID0gZHVhbExpc3Rib3guZWxlbWVudC5maW5kKCdvcHRpb24nKSxcbiAgICAgIG9wdGlvbnMgPSBkdWFsTGlzdGJveC5lbGVtZW50O1xuXG4gICAgaWYgKHNlbGVjdEluZGV4ID09PSAxKSB7XG4gICAgICBvcHRpb25zID0gYWxsT3B0aW9ucy5ub3QoJzpzZWxlY3RlZCcpO1xuICAgIH0gZWxzZSAge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuZmluZCgnb3B0aW9uOnNlbGVjdGVkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCgkLnRyaW0oZHVhbExpc3Rib3guZWxlbWVudHNbJ2ZpbHRlcklucHV0JytzZWxlY3RJbmRleF0udmFsKCkpLCAnZ2knKTtcbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgLy8gYSByZWdleCB0byBtYXRjaCBub3RoaW5nXG4gICAgICByZWdleCA9IG5ldyBSZWdFeHAoJy9hXi8nLCAnZ2knKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSksXG4gICAgICAgIGlzRmlsdGVyZWQgPSB0cnVlO1xuICAgICAgaWYgKGl0ZW0udGV4dC5tYXRjaChyZWdleCkgfHwgKGR1YWxMaXN0Ym94LnNldHRpbmdzLmZpbHRlck9uVmFsdWVzICYmICRpdGVtLmF0dHIoJ3ZhbHVlJykubWF0Y2gocmVnZXgpICkgKSB7XG4gICAgICAgIGlzRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgZHVhbExpc3Rib3guZWxlbWVudHNbJ3NlbGVjdCcrc2VsZWN0SW5kZXhdLmFwcGVuZCgkaXRlbS5jbG9uZSh0cnVlKS5wcm9wKCdzZWxlY3RlZCcsICRpdGVtLmRhdGEoJ19zZWxlY3RlZCcpKSk7XG4gICAgICB9XG4gICAgICBhbGxPcHRpb25zLmVxKCRpdGVtLmRhdGEoJ29yaWdpbmFsLWluZGV4JykpLmRhdGEoJ2ZpbHRlcmVkJytzZWxlY3RJbmRleCwgaXNGaWx0ZXJlZCk7XG4gICAgfSk7XG5cbiAgICByZWZyZXNoSW5mbyhkdWFsTGlzdGJveCk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXZlU2VsZWN0aW9ucyhkdWFsTGlzdGJveCwgc2VsZWN0SW5kZXgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJyk7XG4gICAgZHVhbExpc3Rib3guZWxlbWVudHNbJ3NlbGVjdCcrc2VsZWN0SW5kZXhdLmZpbmQoJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSk7XG4gICAgICBvcHRpb25zLmVxKCRpdGVtLmRhdGEoJ29yaWdpbmFsLWluZGV4JykpLmRhdGEoJ19zZWxlY3RlZCcsICRpdGVtLnByb3AoJ3NlbGVjdGVkJykpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc29ydE9wdGlvbnNCeUlucHV0T3JkZXIoc2VsZWN0KXtcbiAgICB2YXIgc2VsZWN0b3B0ID0gc2VsZWN0LmNoaWxkcmVuKCdvcHRpb24nKTtcblxuICAgIHNlbGVjdG9wdC5zb3J0KGZ1bmN0aW9uKGEsYil7XG4gICAgICB2YXIgYW4gPSBwYXJzZUludChhLmdldEF0dHJpYnV0ZSgnZGF0YS1zb3J0aW5kZXgnKSksXG4gICAgICAgICAgYm4gPSBwYXJzZUludChiLmdldEF0dHJpYnV0ZSgnZGF0YS1zb3J0aW5kZXgnKSk7XG5cbiAgICAgICAgICBpZihhbiA+IGJuKSB7XG4gICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGFuIDwgYm4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICBzZWxlY3RvcHQuZGV0YWNoKCkuYXBwZW5kVG8oc2VsZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRPcHRpb25zKHNlbGVjdCwgZHVhbExpc3Rib3gpIHtcbiAgICBzZWxlY3QuZmluZCgnb3B0aW9uJykuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gKCQoYSkuZGF0YSgnb3JpZ2luYWwtaW5kZXgnKSA+ICQoYikuZGF0YSgnb3JpZ2luYWwtaW5kZXgnKSkgPyAxIDogLTE7XG4gICAgfSkuYXBwZW5kVG8oc2VsZWN0KTtcblxuICAgIC8vIHdvcmthcm91bmQgZm9yIGNocm9taXVtIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA3MjQ3NVxuICAgIHJlZnJlc2hTZWxlY3RzKGR1YWxMaXN0Ym94KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9ucyhkdWFsTGlzdGJveCkge1xuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDEuZmluZCgnb3B0aW9uJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJykuZGF0YSgnX3NlbGVjdGVkJywgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZShkdWFsTGlzdGJveCkge1xuICAgIGlmIChkdWFsTGlzdGJveC5zZXR0aW5ncy5wcmVzZXJ2ZVNlbGVjdGlvbk9uTW92ZSA9PT0gJ2FsbCcgJiYgIWR1YWxMaXN0Ym94LnNldHRpbmdzLm1vdmVPblNlbGVjdCkge1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDEpO1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDIpO1xuICAgIH0gZWxzZSBpZiAoZHVhbExpc3Rib3guc2V0dGluZ3MucHJlc2VydmVTZWxlY3Rpb25Pbk1vdmUgPT09ICdtb3ZlZCcgJiYgIWR1YWxMaXN0Ym94LnNldHRpbmdzLm1vdmVPblNlbGVjdCkge1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDEpO1xuICAgIH1cblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDEuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcbiAgICAgIGlmICghJGl0ZW0uZGF0YSgnZmlsdGVyZWQxJykpIHtcbiAgICAgICAgY2hhbmdlU2VsZWN0aW9uU3RhdGUoZHVhbExpc3Rib3gsICRpdGVtLmRhdGEoJ29yaWdpbmFsLWluZGV4JyksIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVmcmVzaFNlbGVjdHMoZHVhbExpc3Rib3gpO1xuICAgIHRyaWdnZXJDaGFuZ2VFdmVudChkdWFsTGlzdGJveCk7XG4gICAgaWYoZHVhbExpc3Rib3guc2V0dGluZ3Muc29ydEJ5SW5wdXRPcmRlcil7XG4gICAgICAgIHNvcnRPcHRpb25zQnlJbnB1dE9yZGVyKGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvcnRPcHRpb25zKGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDIsIGR1YWxMaXN0Ym94KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZHVhbExpc3Rib3gpIHtcbiAgICBpZiAoZHVhbExpc3Rib3guc2V0dGluZ3MucHJlc2VydmVTZWxlY3Rpb25Pbk1vdmUgPT09ICdhbGwnICYmICFkdWFsTGlzdGJveC5zZXR0aW5ncy5tb3ZlT25TZWxlY3QpIHtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAxKTtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAyKTtcbiAgICB9IGVsc2UgaWYgKGR1YWxMaXN0Ym94LnNldHRpbmdzLnByZXNlcnZlU2VsZWN0aW9uT25Nb3ZlID09PSAnbW92ZWQnICYmICFkdWFsTGlzdGJveC5zZXR0aW5ncy5tb3ZlT25TZWxlY3QpIHtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAyKTtcbiAgICB9XG5cbiAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5zZWxlY3QyLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSk7XG4gICAgICBpZiAoISRpdGVtLmRhdGEoJ2ZpbHRlcmVkMicpKSB7XG4gICAgICAgIGNoYW5nZVNlbGVjdGlvblN0YXRlKGR1YWxMaXN0Ym94LCAkaXRlbS5kYXRhKCdvcmlnaW5hbC1pbmRleCcpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWZyZXNoU2VsZWN0cyhkdWFsTGlzdGJveCk7XG4gICAgdHJpZ2dlckNoYW5nZUV2ZW50KGR1YWxMaXN0Ym94KTtcbiAgICBzb3J0T3B0aW9ucyhkdWFsTGlzdGJveC5lbGVtZW50cy5zZWxlY3QxLCBkdWFsTGlzdGJveCk7XG4gICAgaWYoZHVhbExpc3Rib3guc2V0dGluZ3Muc29ydEJ5SW5wdXRPcmRlcil7XG4gICAgICAgIHNvcnRPcHRpb25zQnlJbnB1dE9yZGVyKGR1YWxMaXN0Ym94LmVsZW1lbnRzLnNlbGVjdDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVBbGwoZHVhbExpc3Rib3gpIHtcbiAgICBpZiAoZHVhbExpc3Rib3guc2V0dGluZ3MucHJlc2VydmVTZWxlY3Rpb25Pbk1vdmUgPT09ICdhbGwnICYmICFkdWFsTGlzdGJveC5zZXR0aW5ncy5tb3ZlT25TZWxlY3QpIHtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAxKTtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAyKTtcbiAgICB9IGVsc2UgaWYgKGR1YWxMaXN0Ym94LnNldHRpbmdzLnByZXNlcnZlU2VsZWN0aW9uT25Nb3ZlID09PSAnbW92ZWQnICYmICFkdWFsTGlzdGJveC5zZXR0aW5ncy5tb3ZlT25TZWxlY3QpIHtcbiAgICAgIHNhdmVTZWxlY3Rpb25zKGR1YWxMaXN0Ym94LCAxKTtcbiAgICB9XG5cbiAgICBkdWFsTGlzdGJveC5lbGVtZW50LmZpbmQoJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSk7XG4gICAgICBpZiAoISRpdGVtLmRhdGEoJ2ZpbHRlcmVkMScpKSB7XG4gICAgICAgICRpdGVtLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICRpdGVtLmF0dHIoJ2RhdGEtc29ydGluZGV4JywgZHVhbExpc3Rib3guc29ydEluZGV4KTtcbiAgICAgICAgZHVhbExpc3Rib3guc29ydEluZGV4Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWZyZXNoU2VsZWN0cyhkdWFsTGlzdGJveCk7XG4gICAgdHJpZ2dlckNoYW5nZUV2ZW50KGR1YWxMaXN0Ym94KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFsbChkdWFsTGlzdGJveCkge1xuICAgIGlmIChkdWFsTGlzdGJveC5zZXR0aW5ncy5wcmVzZXJ2ZVNlbGVjdGlvbk9uTW92ZSA9PT0gJ2FsbCcgJiYgIWR1YWxMaXN0Ym94LnNldHRpbmdzLm1vdmVPblNlbGVjdCkge1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDEpO1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDIpO1xuICAgIH0gZWxzZSBpZiAoZHVhbExpc3Rib3guc2V0dGluZ3MucHJlc2VydmVTZWxlY3Rpb25Pbk1vdmUgPT09ICdtb3ZlZCcgJiYgIWR1YWxMaXN0Ym94LnNldHRpbmdzLm1vdmVPblNlbGVjdCkge1xuICAgICAgc2F2ZVNlbGVjdGlvbnMoZHVhbExpc3Rib3gsIDIpO1xuICAgIH1cblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnQuZmluZCgnb3B0aW9uJykuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcbiAgICAgIGlmICghJGl0ZW0uZGF0YSgnZmlsdGVyZWQyJykpIHtcbiAgICAgICAgJGl0ZW0ucHJvcCgnc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgICRpdGVtLnJlbW92ZUF0dHIoJ2RhdGEtc29ydGluZGV4Jyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWZyZXNoU2VsZWN0cyhkdWFsTGlzdGJveCk7XG4gICAgdHJpZ2dlckNoYW5nZUV2ZW50KGR1YWxMaXN0Ym94KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRFdmVudHMoZHVhbExpc3Rib3gpIHtcbiAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5mb3JtLnN1Ym1pdChmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZHVhbExpc3Rib3guZWxlbWVudHMuZmlsdGVySW5wdXQxLmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLmZpbHRlcklucHV0MS5mb2N1c291dCgpO1xuICAgICAgfSBlbHNlIGlmIChkdWFsTGlzdGJveC5lbGVtZW50cy5maWx0ZXJJbnB1dDIuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZHVhbExpc3Rib3guZWxlbWVudHMuZmlsdGVySW5wdXQyLmZvY3Vzb3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkdWFsTGlzdGJveC5lbGVtZW50Lm9uKCdib290c3RyYXBEdWFsTGlzdGJveC5yZWZyZXNoJywgZnVuY3Rpb24oZSwgbXVzdENsZWFyU2VsZWN0aW9ucyl7XG4gICAgICBkdWFsTGlzdGJveC5yZWZyZXNoKG11c3RDbGVhclNlbGVjdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgZHVhbExpc3Rib3guZWxlbWVudHMuZmlsdGVyQ2xlYXIxLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZHVhbExpc3Rib3guc2V0Tm9uU2VsZWN0ZWRGaWx0ZXIoJycsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgZHVhbExpc3Rib3guZWxlbWVudHMuZmlsdGVyQ2xlYXIyLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZHVhbExpc3Rib3guc2V0U2VsZWN0ZWRGaWx0ZXIoJycsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGR1YWxMaXN0Ym94LnNldHRpbmdzLmV2ZW50TW92ZU92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgICAgZHVhbExpc3Rib3guZWxlbWVudHMubW92ZUJ1dHRvbi5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbW92ZShkdWFsTGlzdGJveCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZHVhbExpc3Rib3guc2V0dGluZ3MuZXZlbnRNb3ZlQWxsT3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5tb3ZlQWxsQnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3ZlQWxsKGR1YWxMaXN0Ym94KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkdWFsTGlzdGJveC5zZXR0aW5ncy5ldmVudFJlbW92ZU92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgICAgZHVhbExpc3Rib3guZWxlbWVudHMucmVtb3ZlQnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmUoZHVhbExpc3Rib3gpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGR1YWxMaXN0Ym94LnNldHRpbmdzLmV2ZW50UmVtb3ZlQWxsT3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5yZW1vdmVBbGxCdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZUFsbChkdWFsTGlzdGJveCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkdWFsTGlzdGJveC5lbGVtZW50cy5maWx0ZXJJbnB1dDEub24oJ2NoYW5nZSBrZXl1cCcsIGZ1bmN0aW9uKCkge1xuICAgICAgZmlsdGVyKGR1YWxMaXN0Ym94LCAxKTtcbiAgICB9KTtcblxuICAgIGR1YWxMaXN0Ym94LmVsZW1lbnRzLmZpbHRlcklucHV0Mi5vbignY2hhbmdlIGtleXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICBmaWx0ZXIoZHVhbExpc3Rib3gsIDIpO1xuICAgIH0pO1xuICB9XG5cbiAgQm9vdHN0cmFwRHVhbExpc3Rib3gucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFkZCB0aGUgY3VzdG9tIEhUTUwgdGVtcGxhdGVcbiAgICAgIHRoaXMuY29udGFpbmVyID0gJCgnJyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWR1YWxsaXN0Ym94LWNvbnRhaW5lciByb3dcIj4nICtcbiAgICAgICAgJyA8ZGl2IGNsYXNzPVwiYm94MSBjb2wtbWQtNlwiPicgK1xuICAgICAgICAnICAgPGxhYmVsPjwvbGFiZWw+JyArXG4gICAgICAgICcgICA8c3BhbiBjbGFzcz1cImluZm8tY29udGFpbmVyXCI+JyArXG4gICAgICAgICcgICAgIDxzcGFuIGNsYXNzPVwiaW5mb1wiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGNsZWFyMVwiIHN0eWxlPVwiZmxvYXQ6cmlnaHQhaW1wb3J0YW50O1wiPjwvYnV0dG9uPicgK1xuICAgICAgICAnICAgPC9zcGFuPicgK1xuICAgICAgICAnICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sIGZpbHRlclwiIHR5cGU9XCJ0ZXh0XCI+JyArXG4gICAgICAgICcgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ1dHRvbnNcIj4nICtcbiAgICAgICAgJyAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gbW92ZWFsbFwiPjwvYnV0dG9uPicgK1xuICAgICAgICAnICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBtb3ZlXCI+PC9idXR0b24+JyArXG4gICAgICAgICcgICA8L2Rpdj4nICtcbiAgICAgICAgJyAgIDxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPjwvc2VsZWN0PicgK1xuICAgICAgICAnIDwvZGl2PicgK1xuICAgICAgICAnIDxkaXYgY2xhc3M9XCJib3gyIGNvbC1tZC02XCI+JyArXG4gICAgICAgICcgICA8bGFiZWw+PC9sYWJlbD4nICtcbiAgICAgICAgJyAgIDxzcGFuIGNsYXNzPVwiaW5mby1jb250YWluZXJcIj4nICtcbiAgICAgICAgJyAgICAgPHNwYW4gY2xhc3M9XCJpbmZvXCI+PC9zcGFuPicgK1xuICAgICAgICAnICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc20gY2xlYXIyXCIgc3R5bGU9XCJmbG9hdDpyaWdodCFpbXBvcnRhbnQ7XCI+PC9idXR0b24+JyArXG4gICAgICAgICcgICA8L3NwYW4+JyArXG4gICAgICAgICcgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZmlsdGVyXCIgdHlwZT1cInRleHRcIj4nICtcbiAgICAgICAgJyAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnV0dG9uc1wiPicgK1xuICAgICAgICAnICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biByZW1vdmVcIj48L2J1dHRvbj4nICtcbiAgICAgICAgJyAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gcmVtb3ZlYWxsXCI+PC9idXR0b24+JyArXG4gICAgICAgICcgICA8L2Rpdj4nICtcbiAgICAgICAgJyAgIDxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPjwvc2VsZWN0PicgK1xuICAgICAgICAnIDwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JylcbiAgICAgICAgLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgaW5uZXIgZWxlbWVudHNcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgICAgIG9yaWdpbmFsU2VsZWN0OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGJveDE6ICQoJy5ib3gxJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBib3gyOiAkKCcuYm94MicsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgZmlsdGVySW5wdXQxOiAkKCcuYm94MSAuZmlsdGVyJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBmaWx0ZXJJbnB1dDI6ICQoJy5ib3gyIC5maWx0ZXInLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIGZpbHRlckNsZWFyMTogJCgnLmJveDEgLmNsZWFyMScsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgZmlsdGVyQ2xlYXIyOiAkKCcuYm94MiAuY2xlYXIyJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBsYWJlbDE6ICQoJy5ib3gxID4gbGFiZWwnLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIGxhYmVsMjogJCgnLmJveDIgPiBsYWJlbCcsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgaW5mbzE6ICQoJy5ib3gxIC5pbmZvJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBpbmZvMjogJCgnLmJveDIgLmluZm8nLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIHNlbGVjdDE6ICQoJy5ib3gxIHNlbGVjdCcsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgc2VsZWN0MjogJCgnLmJveDIgc2VsZWN0JywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBtb3ZlQnV0dG9uOiAkKCcuYm94MSAubW92ZScsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgcmVtb3ZlQnV0dG9uOiAkKCcuYm94MiAucmVtb3ZlJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBtb3ZlQWxsQnV0dG9uOiAkKCcuYm94MSAubW92ZWFsbCcsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgcmVtb3ZlQWxsQnV0dG9uOiAkKCcuYm94MiAucmVtb3ZlYWxsJywgdGhpcy5jb250YWluZXIpLFxuICAgICAgICBmb3JtOiAkKCQoJy5ib3gxIC5maWx0ZXInLCB0aGlzLmNvbnRhaW5lcilbMF0uZm9ybSlcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCBzZWxlY3QgSURzXG4gICAgICB0aGlzLm9yaWdpbmFsU2VsZWN0TmFtZSA9IHRoaXMuZWxlbWVudC5hdHRyKCduYW1lJykgfHwgJyc7XG4gICAgICB2YXIgc2VsZWN0MUlkID0gJ2Jvb3RzdHJhcC1kdWFsbGlzdGJveC1ub25zZWxlY3RlZC1saXN0XycgKyB0aGlzLm9yaWdpbmFsU2VsZWN0TmFtZSxcbiAgICAgICAgc2VsZWN0MklkID0gJ2Jvb3RzdHJhcC1kdWFsbGlzdGJveC1zZWxlY3RlZC1saXN0XycgKyB0aGlzLm9yaWdpbmFsU2VsZWN0TmFtZTtcbiAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0MS5hdHRyKCdpZCcsIHNlbGVjdDFJZCk7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDIuYXR0cignaWQnLCBzZWxlY3QySWQpO1xuICAgICAgdGhpcy5lbGVtZW50cy5sYWJlbDEuYXR0cignZm9yJywgc2VsZWN0MUlkKTtcbiAgICAgIHRoaXMuZWxlbWVudHMubGFiZWwyLmF0dHIoJ2ZvcicsIHNlbGVjdDJJZCk7XG5cbiAgICAgIC8vIEFwcGx5IGFsbCBzZXR0aW5nc1xuICAgICAgdGhpcy5zZWxlY3RlZEVsZW1lbnRzID0gMDtcbiAgICAgIHRoaXMuc29ydEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcbiAgICAgIHRoaXMuc2V0RmlsdGVyVGV4dENsZWFyKHRoaXMuc2V0dGluZ3MuZmlsdGVyVGV4dENsZWFyKTtcbiAgICAgIHRoaXMuc2V0RmlsdGVyUGxhY2VIb2xkZXIodGhpcy5zZXR0aW5ncy5maWx0ZXJQbGFjZUhvbGRlcik7XG4gICAgICB0aGlzLnNldE1vdmVTZWxlY3RlZExhYmVsKHRoaXMuc2V0dGluZ3MubW92ZVNlbGVjdGVkTGFiZWwpO1xuICAgICAgdGhpcy5zZXRNb3ZlQWxsTGFiZWwodGhpcy5zZXR0aW5ncy5tb3ZlQWxsTGFiZWwpO1xuICAgICAgdGhpcy5zZXRSZW1vdmVTZWxlY3RlZExhYmVsKHRoaXMuc2V0dGluZ3MucmVtb3ZlU2VsZWN0ZWRMYWJlbCk7XG4gICAgICB0aGlzLnNldFJlbW92ZUFsbExhYmVsKHRoaXMuc2V0dGluZ3MucmVtb3ZlQWxsTGFiZWwpO1xuICAgICAgdGhpcy5zZXRNb3ZlT25TZWxlY3QodGhpcy5zZXR0aW5ncy5tb3ZlT25TZWxlY3QpO1xuICAgICAgdGhpcy5zZXRNb3ZlT25Eb3VibGVDbGljayh0aGlzLnNldHRpbmdzLm1vdmVPbkRvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMuc2V0UHJlc2VydmVTZWxlY3Rpb25Pbk1vdmUodGhpcy5zZXR0aW5ncy5wcmVzZXJ2ZVNlbGVjdGlvbk9uTW92ZSk7XG4gICAgICB0aGlzLnNldFNlbGVjdGVkTGlzdExhYmVsKHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRMaXN0TGFiZWwpO1xuICAgICAgdGhpcy5zZXROb25TZWxlY3RlZExpc3RMYWJlbCh0aGlzLnNldHRpbmdzLm5vblNlbGVjdGVkTGlzdExhYmVsKTtcbiAgICAgIHRoaXMuc2V0SGVscGVyU2VsZWN0TmFtZVBvc3RmaXgodGhpcy5zZXR0aW5ncy5oZWxwZXJTZWxlY3ROYW1lUG9zdGZpeCk7XG4gICAgICB0aGlzLnNldFNlbGVjdE9yTWluaW1hbEhlaWdodCh0aGlzLnNldHRpbmdzLnNlbGVjdG9yTWluaW1hbEhlaWdodCk7XG5cbiAgICAgIHVwZGF0ZVNlbGVjdGlvblN0YXRlcyh0aGlzKTtcblxuICAgICAgdGhpcy5zZXRTaG93RmlsdGVySW5wdXRzKHRoaXMuc2V0dGluZ3Muc2hvd0ZpbHRlcklucHV0cyk7XG4gICAgICB0aGlzLnNldE5vblNlbGVjdGVkRmlsdGVyKHRoaXMuc2V0dGluZ3Mubm9uU2VsZWN0ZWRGaWx0ZXIpO1xuICAgICAgdGhpcy5zZXRTZWxlY3RlZEZpbHRlcih0aGlzLnNldHRpbmdzLnNlbGVjdGVkRmlsdGVyKTtcbiAgICAgIHRoaXMuc2V0SW5mb1RleHQodGhpcy5zZXR0aW5ncy5pbmZvVGV4dCk7XG4gICAgICB0aGlzLnNldEluZm9UZXh0RmlsdGVyZWQodGhpcy5zZXR0aW5ncy5pbmZvVGV4dEZpbHRlcmVkKTtcbiAgICAgIHRoaXMuc2V0SW5mb1RleHRFbXB0eSh0aGlzLnNldHRpbmdzLmluZm9UZXh0RW1wdHkpO1xuICAgICAgdGhpcy5zZXRGaWx0ZXJPblZhbHVlcyh0aGlzLnNldHRpbmdzLmZpbHRlck9uVmFsdWVzKTtcbiAgICAgIHRoaXMuc2V0U29ydEJ5SW5wdXRPcmRlcih0aGlzLnNldHRpbmdzLnNvcnRCeUlucHV0T3JkZXIpO1xuICAgICAgdGhpcy5zZXRFdmVudE1vdmVPdmVycmlkZSh0aGlzLnNldHRpbmdzLmV2ZW50TW92ZU92ZXJyaWRlKTtcbiAgICAgIHRoaXMuc2V0RXZlbnRNb3ZlQWxsT3ZlcnJpZGUodGhpcy5zZXR0aW5ncy5ldmVudE1vdmVBbGxPdmVycmlkZSk7XG4gICAgICB0aGlzLnNldEV2ZW50UmVtb3ZlT3ZlcnJpZGUodGhpcy5zZXR0aW5ncy5ldmVudFJlbW92ZU92ZXJyaWRlKTtcbiAgICAgIHRoaXMuc2V0RXZlbnRSZW1vdmVBbGxPdmVycmlkZSh0aGlzLnNldHRpbmdzLmV2ZW50UmVtb3ZlQWxsT3ZlcnJpZGUpO1xuICAgICAgdGhpcy5zZXRCdG5DbGFzcyh0aGlzLnNldHRpbmdzLmJ0bkNsYXNzKTtcbiAgICAgIHRoaXMuc2V0QnRuTW92ZVRleHQodGhpcy5zZXR0aW5ncy5idG5Nb3ZlVGV4dCk7XG4gICAgICB0aGlzLnNldEJ0blJlbW92ZVRleHQodGhpcy5zZXR0aW5ncy5idG5SZW1vdmVUZXh0KTtcbiAgICAgIHRoaXMuc2V0QnRuTW92ZUFsbFRleHQodGhpcy5zZXR0aW5ncy5idG5Nb3ZlQWxsVGV4dCk7XG4gICAgICB0aGlzLnNldEJ0blJlbW92ZUFsbFRleHQodGhpcy5zZXR0aW5ncy5idG5SZW1vdmVBbGxUZXh0KTtcblxuICAgICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgc2VsZWN0XG4gICAgICB0aGlzLmVsZW1lbnQuaGlkZSgpO1xuXG4gICAgICBiaW5kRXZlbnRzKHRoaXMpO1xuICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRGaWx0ZXJUZXh0Q2xlYXI6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmZpbHRlclRleHRDbGVhciA9IHZhbHVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5maWx0ZXJDbGVhcjEuaHRtbCh2YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZpbHRlckNsZWFyMi5odG1sKHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEZpbHRlclBsYWNlSG9sZGVyOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXJQbGFjZUhvbGRlciA9IHZhbHVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5maWx0ZXJJbnB1dDEuYXR0cigncGxhY2Vob2xkZXInLCB2YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZpbHRlcklucHV0Mi5hdHRyKCdwbGFjZWhvbGRlcicsIHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldE1vdmVTZWxlY3RlZExhYmVsOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5tb3ZlU2VsZWN0ZWRMYWJlbCA9IHZhbHVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5tb3ZlQnV0dG9uLmF0dHIoJ3RpdGxlJywgdmFsdWUpO1xuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0TW92ZUFsbExhYmVsOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5tb3ZlQWxsTGFiZWwgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWxlbWVudHMubW92ZUFsbEJ1dHRvbi5hdHRyKCd0aXRsZScsIHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldFJlbW92ZVNlbGVjdGVkTGFiZWw6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLnJlbW92ZVNlbGVjdGVkTGFiZWwgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWxlbWVudHMucmVtb3ZlQnV0dG9uLmF0dHIoJ3RpdGxlJywgdmFsdWUpO1xuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0UmVtb3ZlQWxsTGFiZWw6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLnJlbW92ZUFsbExhYmVsID0gdmFsdWU7XG4gICAgICB0aGlzLmVsZW1lbnRzLnJlbW92ZUFsbEJ1dHRvbi5hdHRyKCd0aXRsZScsIHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldE1vdmVPblNlbGVjdDogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpIHtcbiAgICAgIGlmIChpc0J1Z2d5QW5kcm9pZCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnNldHRpbmdzLm1vdmVPblNlbGVjdCA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW92ZU9uU2VsZWN0KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdtb3Zlb25zZWxlY3QnKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDEub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1vdmUoc2VsZik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDIub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZShzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMubW92ZUJ1dHRvbi5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5yZW1vdmVCdXR0b24uZGV0YWNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnbW92ZW9uc2VsZWN0Jyk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0MS5vZmYoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDIub2ZmKCdjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5tb3ZlQnV0dG9uLmluc2VydEFmdGVyKHRoaXMuZWxlbWVudHMubW92ZUFsbEJ1dHRvbik7XG4gICAgICAgIHRoaXMuZWxlbWVudHMucmVtb3ZlQnV0dG9uLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnRzLnJlbW92ZUFsbEJ1dHRvbik7XG4gICAgICB9XG4gICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRNb3ZlT25Eb3VibGVDbGljazogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpIHtcbiAgICAgIGlmIChpc0J1Z2d5QW5kcm9pZCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXR0aW5ncy5tb3ZlT25Eb3VibGVDbGljayA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW92ZU9uRG91YmxlQ2xpY2spIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ21vdmVvbmRvdWJsZWNsaWNrJyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZWxlY3QxLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1vdmUoc2VsZik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDIub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlKHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdtb3Zlb25kb3VibGVjbGljaycpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDEub2ZmKCdkYmxjbGljaycpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNlbGVjdDIub2ZmKCdkYmxjbGljaycpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0UHJlc2VydmVTZWxlY3Rpb25Pbk1vdmU6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICAvLyBXZSBhcmUgZm9yY2luZyB0byBtb3ZlIG9uIHNlbGVjdCBhbmQgZGlzYWJsaW5nIHByZXNlcnZlU2VsZWN0aW9uT25Nb3ZlIG9uIEFuZHJvaWRcbiAgICAgIGlmIChpc0J1Z2d5QW5kcm9pZCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXR0aW5ncy5wcmVzZXJ2ZVNlbGVjdGlvbk9uTW92ZSA9IHZhbHVlO1xuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWRMaXN0TGFiZWw6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdGVkTGlzdExhYmVsID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5sYWJlbDIuc2hvdygpLmh0bWwodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5sYWJlbDIuaGlkZSgpLmh0bWwodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0Tm9uU2VsZWN0ZWRMaXN0TGFiZWw6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLm5vblNlbGVjdGVkTGlzdExhYmVsID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5sYWJlbDEuc2hvdygpLmh0bWwodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5sYWJlbDEuaGlkZSgpLmh0bWwodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0SGVscGVyU2VsZWN0TmFtZVBvc3RmaXg6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmhlbHBlclNlbGVjdE5hbWVQb3N0Zml4ID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZWxlY3QxLmF0dHIoJ25hbWUnLCB0aGlzLm9yaWdpbmFsU2VsZWN0TmFtZSArIHZhbHVlICsgJzEnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZWxlY3QyLmF0dHIoJ25hbWUnLCB0aGlzLm9yaWdpbmFsU2VsZWN0TmFtZSArIHZhbHVlICsgJzInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0MS5yZW1vdmVBdHRyKCduYW1lJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0Mi5yZW1vdmVBdHRyKCduYW1lJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RPck1pbmltYWxIZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdG9yTWluaW1hbEhlaWdodCA9IHZhbHVlO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGVpZ2h0KCkgPCB2YWx1ZSkge1xuICAgICAgICBoZWlnaHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0MS5oZWlnaHQoaGVpZ2h0KTtcbiAgICAgIHRoaXMuZWxlbWVudHMuc2VsZWN0Mi5oZWlnaHQoaGVpZ2h0KTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldFNob3dGaWx0ZXJJbnB1dHM6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0Tm9uU2VsZWN0ZWRGaWx0ZXIoJycpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkRmlsdGVyKCcnKTtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZmlsdGVySW5wdXQxLmhpZGUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5maWx0ZXJJbnB1dDIuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5maWx0ZXJJbnB1dDEuc2hvdygpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmZpbHRlcklucHV0Mi5zaG93KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldHRpbmdzLnNob3dGaWx0ZXJJbnB1dHMgPSB2YWx1ZTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldE5vblNlbGVjdGVkRmlsdGVyOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd0ZpbHRlcklucHV0cykge1xuICAgICAgICB0aGlzLnNldHRpbmdzLm5vblNlbGVjdGVkRmlsdGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZmlsdGVySW5wdXQxLnZhbCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFNlbGVjdGVkRmlsdGVyOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd0ZpbHRlcklucHV0cykge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdGVkRmlsdGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZmlsdGVySW5wdXQyLnZhbCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEluZm9UZXh0OiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5pbmZvVGV4dCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuaW5mbzEuc2hvdygpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmluZm8yLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuaW5mbzEuaGlkZSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmluZm8yLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEluZm9UZXh0RmlsdGVyZWQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmluZm9UZXh0RmlsdGVyZWQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEluZm9UZXh0RW1wdHk6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmluZm9UZXh0RW1wdHkgPSB2YWx1ZTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEZpbHRlck9uVmFsdWVzOiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXJPblZhbHVlcyA9IHZhbHVlO1xuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0U29ydEJ5SW5wdXRPcmRlcjogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpe1xuICAgICAgICB0aGlzLnNldHRpbmdzLnNvcnRCeUlucHV0T3JkZXIgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0RXZlbnRNb3ZlT3ZlcnJpZGU6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZXZlbnRNb3ZlT3ZlcnJpZGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0RXZlbnRNb3ZlQWxsT3ZlcnJpZGU6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZXZlbnRNb3ZlQWxsT3ZlcnJpZGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0RXZlbnRSZW1vdmVPdmVycmlkZTogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5ldmVudFJlbW92ZU92ZXJyaWRlID0gdmFsdWU7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEV2ZW50UmVtb3ZlQWxsT3ZlcnJpZGU6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZXZlbnRSZW1vdmVBbGxPdmVycmlkZSA9IHZhbHVlO1xuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRCdG5DbGFzczogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYnRuQ2xhc3MgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWxlbWVudHMubW92ZUJ1dHRvbi5hdHRyKCdjbGFzcycsICdidG4gbW92ZScpLmFkZENsYXNzKHZhbHVlKTtcbiAgICAgIHRoaXMuZWxlbWVudHMucmVtb3ZlQnV0dG9uLmF0dHIoJ2NsYXNzJywgJ2J0biByZW1vdmUnKS5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLm1vdmVBbGxCdXR0b24uYXR0cignY2xhc3MnLCAnYnRuIG1vdmVhbGwnKS5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLnJlbW92ZUFsbEJ1dHRvbi5hdHRyKCdjbGFzcycsICdidG4gcmVtb3ZlYWxsJykuYWRkQ2xhc3ModmFsdWUpO1xuICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdHModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0QnRuTW92ZVRleHQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmJ0bk1vdmVUZXh0ID0gdmFsdWU7XG4gICAgICB0aGlzLmVsZW1lbnRzLm1vdmVCdXR0b24uaHRtbCh2YWx1ZSk7XG4gICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRCdG5SZW1vdmVUZXh0OiBmdW5jdGlvbih2YWx1ZSwgcmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5idG5Nb3ZlVGV4dCA9IHZhbHVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5yZW1vdmVCdXR0b24uaHRtbCh2YWx1ZSk7XG4gICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2VsZWN0cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBzZXRCdG5Nb3ZlQWxsVGV4dDogZnVuY3Rpb24odmFsdWUsIHJlZnJlc2gpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYnRuTW92ZVRleHQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWxlbWVudHMubW92ZUFsbEJ1dHRvbi5odG1sKHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIHNldEJ0blJlbW92ZUFsbFRleHQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZyZXNoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLmJ0bk1vdmVUZXh0ID0gdmFsdWU7XG4gICAgICB0aGlzLmVsZW1lbnRzLnJlbW92ZUFsbEJ1dHRvbi5odG1sKHZhbHVlKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfSxcbiAgICByZWZyZXNoOiBmdW5jdGlvbihtdXN0Q2xlYXJTZWxlY3Rpb25zKSB7XG4gICAgICB1cGRhdGVTZWxlY3Rpb25TdGF0ZXModGhpcyk7XG5cbiAgICAgIGlmICghbXVzdENsZWFyU2VsZWN0aW9ucykge1xuICAgICAgICBzYXZlU2VsZWN0aW9ucyh0aGlzLCAxKTtcbiAgICAgICAgc2F2ZVNlbGVjdGlvbnModGhpcywgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhclNlbGVjdGlvbnModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hTZWxlY3RzKHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zaG93KCk7XG4gICAgICAkLmRhdGEodGhpcywgJ3BsdWdpbl8nICsgcGx1Z2luTmFtZSwgbnVsbCk7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICAvLyBBIHJlYWxseSBsaWdodHdlaWdodCBwbHVnaW4gd3JhcHBlciBhcm91bmQgdGhlIGNvbnN0cnVjdG9yLFxuICAvLyBwcmV2ZW50aW5nIGFnYWluc3QgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnNcbiAgJC5mblsgcGx1Z2luTmFtZSBdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIC8vIElzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYW4gb2JqZWN0IChvcHRpb25zKSwgb3Igd2FzIG9taXR0ZWQsIGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwbHVnaW4uXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHNlbGVjdFxuICAgICAgICBpZiAoISQodGhpcykuaXMoJ3NlbGVjdCcpKSB7XG4gICAgICAgICAgJCh0aGlzKS5maW5kKCdzZWxlY3QnKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBuZXN0ZWQgc2VsZWN0LCBpbnN0YW50aWF0ZSB0aGUgRHVhbCBMaXN0IEJveFxuICAgICAgICAgICAgJChpdGVtKS5ib290c3RyYXBEdWFsTGlzdGJveChvcHRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghJC5kYXRhKHRoaXMsICdwbHVnaW5fJyArIHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgLy8gT25seSBhbGxvdyB0aGUgcGx1Z2luIHRvIGJlIGluc3RhbnRpYXRlZCBvbmNlIHNvIHdlIGNoZWNrIHRoYXQgdGhlIGVsZW1lbnQgaGFzIG5vIHBsdWdpbiBpbnN0YW50aWF0aW9uIHlldFxuXG4gICAgICAgICAgLy8gaWYgaXQgaGFzIG5vIGluc3RhbmNlLCBjcmVhdGUgYSBuZXcgb25lLCBwYXNzIG9wdGlvbnMgdG8gb3VyIHBsdWdpbiBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAvLyBhbmQgc3RvcmUgdGhlIHBsdWdpbiBpbnN0YW5jZSBpbiB0aGUgZWxlbWVudHMgalF1ZXJ5IGRhdGEgb2JqZWN0LlxuICAgICAgICAgICQuZGF0YSh0aGlzLCAncGx1Z2luXycgKyBwbHVnaW5OYW1lLCBuZXcgQm9vdHN0cmFwRHVhbExpc3Rib3godGhpcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgYW5kIGl0IGRvZXNuJ3Qgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlIG9yIFwiY29udGFpbnNcIiB0aGUgYGluaXRgLWZ1bmN0aW9uLFxuICAgICAgLy8gdHJlYXQgdGhpcyBhcyBhIGNhbGwgdG8gYSBwdWJsaWMgbWV0aG9kLlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnICYmIG9wdGlvbnNbMF0gIT09ICdfJyAmJiBvcHRpb25zICE9PSAnaW5pdCcpIHtcblxuICAgICAgLy8gQ2FjaGUgdGhlIG1ldGhvZCBjYWxsIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gcmV0dXJuIGEgdmFsdWVcbiAgICAgIHZhciByZXR1cm5zO1xuXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSAkLmRhdGEodGhpcywgJ3BsdWdpbl8nICsgcGx1Z2luTmFtZSk7XG4gICAgICAgIC8vIFRlc3RzIHRoYXQgdGhlcmUncyBhbHJlYWR5IGEgcGx1Z2luLWluc3RhbmNlIGFuZCBjaGVja3MgdGhhdCB0aGUgcmVxdWVzdGVkIHB1YmxpYyBtZXRob2QgZXhpc3RzXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIEJvb3RzdHJhcER1YWxMaXN0Ym94ICYmIHR5cGVvZiBpbnN0YW5jZVtvcHRpb25zXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIENhbGwgdGhlIG1ldGhvZCBvZiBvdXIgcGx1Z2luIGluc3RhbmNlLCBhbmQgcGFzcyBpdCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICAgICAgICAgIHJldHVybnMgPSBpbnN0YW5jZVtvcHRpb25zXS5hcHBseShpbnN0YW5jZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIGVhcmxpZXIgY2FjaGVkIG1ldGhvZCBnaXZlcyBhIHZhbHVlIGJhY2sgcmV0dXJuIHRoZSB2YWx1ZSxcbiAgICAgIC8vIG90aGVyd2lzZSByZXR1cm4gdGhpcyB0byBwcmVzZXJ2ZSBjaGFpbmFiaWxpdHkuXG4gICAgICByZXR1cm4gcmV0dXJucyAhPT0gdW5kZWZpbmVkID8gcmV0dXJucyA6IHRoaXM7XG4gICAgfVxuXG4gIH07XG5cbn0pKTtcbiIsIi8qIVxyXG4gICogQm9vdHN0cmFwIERhdGV0aW1lIFBpY2tlciB2NC4xNy40OVxyXG4gICogQ29weXJpZ2h0IDIwMTUtMjAyMCBKb25hdGhhbiBQZXRlcnNvblxyXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vRW9uYXNkYW4vYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXHJcbiAgKi9cclxuLypnbG9iYWwgZGVmaW5lOmZhbHNlICovXHJcbi8qZ2xvYmFsIGV4cG9ydHM6ZmFsc2UgKi9cclxuLypnbG9iYWwgcmVxdWlyZTpmYWxzZSAqL1xyXG4vKmdsb2JhbCBqUXVlcnk6ZmFsc2UgKi9cclxuLypnbG9iYWwgbW9tZW50OmZhbHNlICovXHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRCBpcyB1c2VkIC0gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoWydqcXVlcnknLCAnbW9tZW50J10sIGZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JyksIHJlcXVpcmUoJ21vbWVudCcpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTmVpdGhlciBBTUQgbm9yIENvbW1vbkpTIHVzZWQuIFVzZSBnbG9iYWwgdmFyaWFibGVzLlxyXG4gICAgICAgIGlmICh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyAnYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyIHJlcXVpcmVzIGpRdWVyeSB0byBiZSBsb2FkZWQgZmlyc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG1vbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBNb21lbnQuanMgdG8gYmUgbG9hZGVkIGZpcnN0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIG1vbWVudCk7XHJcbiAgICB9XHJcbn0oZnVuY3Rpb24gKCQsIG1vbWVudCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgaWYgKCFtb21lbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBNb21lbnQuanMgdG8gYmUgbG9hZGVkIGZpcnN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGVUaW1lUGlja2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcGlja2VyID0ge30sXHJcbiAgICAgICAgICAgIGRhdGUsXHJcbiAgICAgICAgICAgIHZpZXdEYXRlLFxyXG4gICAgICAgICAgICB1bnNldCA9IHRydWUsXHJcbiAgICAgICAgICAgIGlucHV0LFxyXG4gICAgICAgICAgICBjb21wb25lbnQgPSBmYWxzZSxcclxuICAgICAgICAgICAgd2lkZ2V0ID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHVzZTI0SG91cnMsXHJcbiAgICAgICAgICAgIG1pblZpZXdNb2RlTnVtYmVyID0gMCxcclxuICAgICAgICAgICAgYWN0dWFsRm9ybWF0LFxyXG4gICAgICAgICAgICBwYXJzZUZvcm1hdHMsXHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZSxcclxuICAgICAgICAgICAgZGF0ZVBpY2tlck1vZGVzID0gW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWU6ICdkYXlzJyxcclxuICAgICAgICAgICAgICAgICAgICBuYXZGbmM6ICdNJyxcclxuICAgICAgICAgICAgICAgICAgICBuYXZTdGVwOiAxXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWU6ICdtb250aHMnLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdkZuYzogJ3knLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdlN0ZXA6IDFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZTogJ3llYXJzJyxcclxuICAgICAgICAgICAgICAgICAgICBuYXZGbmM6ICd5JyxcclxuICAgICAgICAgICAgICAgICAgICBuYXZTdGVwOiAxMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lOiAnZGVjYWRlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF2Rm5jOiAneScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF2U3RlcDogMTAwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHZpZXdNb2RlcyA9IFsnZGF5cycsICdtb250aHMnLCAneWVhcnMnLCAnZGVjYWRlcyddLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbE1vZGVzID0gWyd0b3AnLCAnYm90dG9tJywgJ2F1dG8nXSxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbE1vZGVzID0gWydsZWZ0JywgJ3JpZ2h0JywgJ2F1dG8nXSxcclxuICAgICAgICAgICAgdG9vbGJhclBsYWNlbWVudHMgPSBbJ2RlZmF1bHQnLCAndG9wJywgJ2JvdHRvbSddLFxyXG4gICAgICAgICAgICBrZXlNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICAndXAnOiAzOCxcclxuICAgICAgICAgICAgICAgIDM4OiAndXAnLFxyXG4gICAgICAgICAgICAgICAgJ2Rvd24nOiA0MCxcclxuICAgICAgICAgICAgICAgIDQwOiAnZG93bicsXHJcbiAgICAgICAgICAgICAgICAnbGVmdCc6IDM3LFxyXG4gICAgICAgICAgICAgICAgMzc6ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgICdyaWdodCc6IDM5LFxyXG4gICAgICAgICAgICAgICAgMzk6ICdyaWdodCcsXHJcbiAgICAgICAgICAgICAgICAndGFiJzogOSxcclxuICAgICAgICAgICAgICAgIDk6ICd0YWInLFxyXG4gICAgICAgICAgICAgICAgJ2VzY2FwZSc6IDI3LFxyXG4gICAgICAgICAgICAgICAgMjc6ICdlc2NhcGUnLFxyXG4gICAgICAgICAgICAgICAgJ2VudGVyJzogMTMsXHJcbiAgICAgICAgICAgICAgICAxMzogJ2VudGVyJyxcclxuICAgICAgICAgICAgICAgICdwYWdlVXAnOiAzMyxcclxuICAgICAgICAgICAgICAgIDMzOiAncGFnZVVwJyxcclxuICAgICAgICAgICAgICAgICdwYWdlRG93bic6IDM0LFxyXG4gICAgICAgICAgICAgICAgMzQ6ICdwYWdlRG93bicsXHJcbiAgICAgICAgICAgICAgICAnc2hpZnQnOiAxNixcclxuICAgICAgICAgICAgICAgIDE2OiAnc2hpZnQnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbnRyb2wnOiAxNyxcclxuICAgICAgICAgICAgICAgIDE3OiAnY29udHJvbCcsXHJcbiAgICAgICAgICAgICAgICAnc3BhY2UnOiAzMixcclxuICAgICAgICAgICAgICAgIDMyOiAnc3BhY2UnLFxyXG4gICAgICAgICAgICAgICAgJ3QnOiA4NCxcclxuICAgICAgICAgICAgICAgIDg0OiAndCcsXHJcbiAgICAgICAgICAgICAgICAnZGVsZXRlJzogNDYsXHJcbiAgICAgICAgICAgICAgICA0NjogJ2RlbGV0ZSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAga2V5U3RhdGUgPSB7fSxcclxuXHJcbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBQcml2YXRlIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgICAgICAgICBoYXNUaW1lWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQudHogIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRpbWVab25lICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aW1lWm9uZSAhPT0gbnVsbCAmJiBvcHRpb25zLnRpbWVab25lICE9PSAnJztcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldE1vbWVudCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuTW9tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkID09PSB1bmRlZmluZWQgfHwgZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk1vbWVudCA9IG1vbWVudCgpOyAvL1RPRE8gc2hvdWxkIHRoaXMgdXNlIGZvcm1hdD8gYW5kIGxvY2FsZT9cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzRGF0ZShkKSB8fCBtb21lbnQuaXNNb21lbnQoZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0ZSB0aGF0IGlzIHBhc3NlZCBpbiBpcyBhbHJlYWR5IGEgRGF0ZSgpIG9yIG1vbWVudCgpIG9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIGl0IGRpcmVjdGx5IHRvIG1vbWVudC5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Nb21lbnQgPSBtb21lbnQoZCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1RpbWVab25lKCkpIHsgLy8gVGhlcmUgaXMgYSBzdHJpbmcgdG8gcGFyc2UgYW5kIGEgZGVmYXVsdCB0aW1lIHpvbmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB3aXRoIHRoZSB0eiBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIGRlZmF1bHQgdGltZSB6b25lIGlmIGl0IGlzIG5vdCBpbiB0aGUgZm9ybWF0IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk1vbWVudCA9IG1vbWVudC50eihkLCBwYXJzZUZvcm1hdHMsIG9wdGlvbnMudXNlU3RyaWN0LCBvcHRpb25zLnRpbWVab25lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuTW9tZW50ID0gbW9tZW50KGQsIHBhcnNlRm9ybWF0cywgb3B0aW9ucy51c2VTdHJpY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNUaW1lWm9uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuTW9tZW50LnR6KG9wdGlvbnMudGltZVpvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5Nb21lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc0VuYWJsZWQgPSBmdW5jdGlvbiAoZ3JhbnVsYXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JhbnVsYXJpdHkgIT09ICdzdHJpbmcnIHx8IGdyYW51bGFyaXR5Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpc0VuYWJsZWQgZXhwZWN0cyBhIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChncmFudWxhcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRm9ybWF0LmluZGV4T2YoJ1knKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxGb3JtYXQuaW5kZXhPZignTScpICE9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2QnKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxGb3JtYXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoJykgIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRm9ybWF0LmluZGV4T2YoJ20nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxGb3JtYXQuaW5kZXhPZigncycpICE9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBoYXNUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc0VuYWJsZWQoJ2gnKSB8fCBpc0VuYWJsZWQoJ20nKSB8fCBpc0VuYWJsZWQoJ3MnKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBoYXNEYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc0VuYWJsZWQoJ3knKSB8fCBpc0VuYWJsZWQoJ00nKSB8fCBpc0VuYWJsZWQoJ2QnKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXREYXRlUGlja2VyVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZFRlbXBsYXRlID0gJCgnPHRoZWFkPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRyPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0aD4nKS5hZGRDbGFzcygncHJldicpLmF0dHIoJ2RhdGEtYWN0aW9uJywgJ3ByZXZpb3VzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuPicpLmFkZENsYXNzKG9wdGlvbnMuaWNvbnMucHJldmlvdXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRoPicpLmFkZENsYXNzKCdwaWNrZXItc3dpdGNoJykuYXR0cignZGF0YS1hY3Rpb24nLCAncGlja2VyU3dpdGNoJykuYXR0cignY29sc3BhbicsIChvcHRpb25zLmNhbGVuZGFyV2Vla3MgPyAnNicgOiAnNScpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRoPicpLmFkZENsYXNzKCduZXh0JykuYXR0cignZGF0YS1hY3Rpb24nLCAnbmV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLm5leHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgY29udFRlbXBsYXRlID0gJCgnPHRib2R5PicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRyPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0ZD4nKS5hdHRyKCdjb2xzcGFuJywgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyA/ICc4JyA6ICc3JykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItZGF5cycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRhYmxlPicpLmFkZENsYXNzKCd0YWJsZS1jb25kZW5zZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChoZWFkVGVtcGxhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0Ym9keT4nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygnZGF0ZXBpY2tlci1tb250aHMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0YWJsZT4nKS5hZGRDbGFzcygndGFibGUtY29uZGVuc2VkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoaGVhZFRlbXBsYXRlLmNsb25lKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNvbnRUZW1wbGF0ZS5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2PicpLmFkZENsYXNzKCdkYXRlcGlja2VyLXllYXJzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8dGFibGU+JykuYWRkQ2xhc3MoJ3RhYmxlLWNvbmRlbnNlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGhlYWRUZW1wbGF0ZS5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjb250VGVtcGxhdGUuY2xvbmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygnZGF0ZXBpY2tlci1kZWNhZGVzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8dGFibGU+JykuYWRkQ2xhc3MoJ3RhYmxlLWNvbmRlbnNlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGhlYWRUZW1wbGF0ZS5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjb250VGVtcGxhdGUuY2xvbmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRUaW1lUGlja2VyTWFpblRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcFJvdyA9ICQoJzx0cj4nKSxcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVSb3cgPSAkKCc8dHI+JyksXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tUm93ID0gJCgnPHRyPicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQoJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcFJvdy5hcHBlbmQoJCgnPHRkPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGE+JykuYXR0cih7IGhyZWY6ICcjJywgdGFiaW5kZXg6ICctMScsICd0aXRsZSc6IG9wdGlvbnMudG9vbHRpcHMuaW5jcmVtZW50SG91ciB9KS5hZGRDbGFzcygnYnRuJykuYXR0cignZGF0YS1hY3Rpb24nLCAnaW5jcmVtZW50SG91cnMnKS5hcHBlbmQoJCgnPHNwYW4+JykuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy51cCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlUm93LmFwcGVuZCgkKCc8dGQ+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcygndGltZXBpY2tlci1ob3VyJykuYXR0cih7ICdkYXRhLXRpbWUtY29tcG9uZW50JzogJ2hvdXJzJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5waWNrSG91ciB9KS5hdHRyKCdkYXRhLWFjdGlvbicsICdzaG93SG91cnMnKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbVJvdy5hcHBlbmQoJCgnPHRkPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGE+JykuYXR0cih7IGhyZWY6ICcjJywgdGFiaW5kZXg6ICctMScsICd0aXRsZSc6IG9wdGlvbnMudG9vbHRpcHMuZGVjcmVtZW50SG91ciB9KS5hZGRDbGFzcygnYnRuJykuYXR0cignZGF0YS1hY3Rpb24nLCAnZGVjcmVtZW50SG91cnMnKS5hcHBlbmQoJCgnPHNwYW4+JykuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy5kb3duKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQoJ20nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQoJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BSb3cuYXBwZW5kKCQoJzx0ZD4nKS5hZGRDbGFzcygnc2VwYXJhdG9yJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRkbGVSb3cuYXBwZW5kKCQoJzx0ZD4nKS5hZGRDbGFzcygnc2VwYXJhdG9yJykuaHRtbCgnOicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tUm93LmFwcGVuZCgkKCc8dGQ+JykuYWRkQ2xhc3MoJ3NlcGFyYXRvcicpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wUm93LmFwcGVuZCgkKCc8dGQ+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8YT4nKS5hdHRyKHsgaHJlZjogJyMnLCB0YWJpbmRleDogJy0xJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5pbmNyZW1lbnRNaW51dGUgfSkuYWRkQ2xhc3MoJ2J0bicpLmF0dHIoJ2RhdGEtYWN0aW9uJywgJ2luY3JlbWVudE1pbnV0ZXMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLnVwKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVSb3cuYXBwZW5kKCQoJzx0ZD4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuPicpLmFkZENsYXNzKCd0aW1lcGlja2VyLW1pbnV0ZScpLmF0dHIoeyAnZGF0YS10aW1lLWNvbXBvbmVudCc6ICdtaW51dGVzJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5waWNrTWludXRlIH0pLmF0dHIoJ2RhdGEtYWN0aW9uJywgJ3Nob3dNaW51dGVzJykpKTtcclxuICAgICAgICAgICAgICAgICAgICBib3R0b21Sb3cuYXBwZW5kKCQoJzx0ZD4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxhPicpLmF0dHIoeyBocmVmOiAnIycsIHRhYmluZGV4OiAnLTEnLCAndGl0bGUnOiBvcHRpb25zLnRvb2x0aXBzLmRlY3JlbWVudE1pbnV0ZSB9KS5hZGRDbGFzcygnYnRuJykuYXR0cignZGF0YS1hY3Rpb24nLCAnZGVjcmVtZW50TWludXRlcycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuPicpLmFkZENsYXNzKG9wdGlvbnMuaWNvbnMuZG93bikpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmFibGVkKCdzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbmFibGVkKCdtJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wUm93LmFwcGVuZCgkKCc8dGQ+JykuYWRkQ2xhc3MoJ3NlcGFyYXRvcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkZGxlUm93LmFwcGVuZCgkKCc8dGQ+JykuYWRkQ2xhc3MoJ3NlcGFyYXRvcicpLmh0bWwoJzonKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJvdy5hcHBlbmQoJCgnPHRkPicpLmFkZENsYXNzKCdzZXBhcmF0b3InKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRvcFJvdy5hcHBlbmQoJCgnPHRkPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGE+JykuYXR0cih7IGhyZWY6ICcjJywgdGFiaW5kZXg6ICctMScsICd0aXRsZSc6IG9wdGlvbnMudG9vbHRpcHMuaW5jcmVtZW50U2Vjb25kIH0pLmFkZENsYXNzKCdidG4nKS5hdHRyKCdkYXRhLWFjdGlvbicsICdpbmNyZW1lbnRTZWNvbmRzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHNwYW4+JykuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy51cCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlUm93LmFwcGVuZCgkKCc8dGQ+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcygndGltZXBpY2tlci1zZWNvbmQnKS5hdHRyKHsgJ2RhdGEtdGltZS1jb21wb25lbnQnOiAnc2Vjb25kcycsICd0aXRsZSc6IG9wdGlvbnMudG9vbHRpcHMucGlja1NlY29uZCB9KS5hdHRyKCdkYXRhLWFjdGlvbicsICdzaG93U2Vjb25kcycpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tUm93LmFwcGVuZCgkKCc8dGQ+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8YT4nKS5hdHRyKHsgaHJlZjogJyMnLCB0YWJpbmRleDogJy0xJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5kZWNyZW1lbnRTZWNvbmQgfSkuYWRkQ2xhc3MoJ2J0bicpLmF0dHIoJ2RhdGEtYWN0aW9uJywgJ2RlY3JlbWVudFNlY29uZHMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLmRvd24pKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdXNlMjRIb3Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcFJvdy5hcHBlbmQoJCgnPHRkPicpLmFkZENsYXNzKCdzZXBhcmF0b3InKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlUm93LmFwcGVuZCgkKCc8dGQ+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8YnV0dG9uPicpLmFkZENsYXNzKCdidG4gYnRuLXByaW1hcnknKS5hdHRyKHsgJ2RhdGEtYWN0aW9uJzogJ3RvZ2dsZVBlcmlvZCcsIHRhYmluZGV4OiAnLTEnLCAndGl0bGUnOiBvcHRpb25zLnRvb2x0aXBzLnRvZ2dsZVBlcmlvZCB9KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbVJvdy5hcHBlbmQoJCgnPHRkPicpLmFkZENsYXNzKCdzZXBhcmF0b3InKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykuYWRkQ2xhc3MoJ3RpbWVwaWNrZXItcGlja2VyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0YWJsZT4nKS5hZGRDbGFzcygndGFibGUtY29uZGVuc2VkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChbdG9wUm93LCBtaWRkbGVSb3csIGJvdHRvbVJvd10pKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldFRpbWVQaWNrZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBob3Vyc1ZpZXcgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCd0aW1lcGlja2VyLWhvdXJzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8dGFibGU+JykuYWRkQ2xhc3MoJ3RhYmxlLWNvbmRlbnNlZCcpKSxcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzVmlldyA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ3RpbWVwaWNrZXItbWludXRlcycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRhYmxlPicpLmFkZENsYXNzKCd0YWJsZS1jb25kZW5zZWQnKSksXHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kc1ZpZXcgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCd0aW1lcGlja2VyLXNlY29uZHMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0YWJsZT4nKS5hZGRDbGFzcygndGFibGUtY29uZGVuc2VkJykpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFtnZXRUaW1lUGlja2VyTWFpblRlbXBsYXRlKCldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQoJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGhvdXJzVmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmFibGVkKCdtJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChtaW51dGVzVmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmFibGVkKCdzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChzZWNvbmRzVmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldFRvb2xiYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9kYXlCdXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgkKCc8dGQ+JykuYXBwZW5kKCQoJzxhPicpLmF0dHIoeyAnZGF0YS1hY3Rpb24nOiAndG9kYXknLCAndGl0bGUnOiBvcHRpb25zLnRvb2x0aXBzLnRvZGF5IH0pLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLnRvZGF5KSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaWRlQnlTaWRlICYmIGhhc0RhdGUoKSAmJiBoYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgkKCc8dGQ+JykuYXBwZW5kKCQoJzxhPicpLmF0dHIoeyAnZGF0YS1hY3Rpb24nOiAndG9nZ2xlUGlja2VyJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5zZWxlY3RUaW1lIH0pLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLnRpbWUpKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0NsZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goJCgnPHRkPicpLmFwcGVuZCgkKCc8YT4nKS5hdHRyKHsgJ2RhdGEtYWN0aW9uJzogJ2NsZWFyJywgJ3RpdGxlJzogb3B0aW9ucy50b29sdGlwcy5jbGVhciB9KS5hcHBlbmQoJCgnPHNwYW4+JykuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy5jbGVhcikpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93Q2xvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgkKCc8dGQ+JykuYXBwZW5kKCQoJzxhPicpLmF0dHIoeyAnZGF0YS1hY3Rpb24nOiAnY2xvc2UnLCAndGl0bGUnOiBvcHRpb25zLnRvb2x0aXBzLmNsb3NlIH0pLmFwcGVuZCgkKCc8c3Bhbj4nKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLmNsb3NlKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAkKCc8dGFibGU+JykuYWRkQ2xhc3MoJ3RhYmxlLWNvbmRlbnNlZCcpLmFwcGVuZCgkKCc8dGJvZHk+JykuYXBwZW5kKCQoJzx0cj4nKS5hcHBlbmQocm93KSkpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGRyb3Bkb3duLW1lbnUnKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlVmlldyA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2RhdGVwaWNrZXInKS5hcHBlbmQoZ2V0RGF0ZVBpY2tlclRlbXBsYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVWaWV3ID0gJCgnPGRpdj4nKS5hZGRDbGFzcygndGltZXBpY2tlcicpLmFwcGVuZChnZXRUaW1lUGlja2VyVGVtcGxhdGUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9ICQoJzx1bD4nKS5hZGRDbGFzcygnbGlzdC11bnN0eWxlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXIgPSAkKCc8bGk+JykuYWRkQ2xhc3MoJ3BpY2tlci1zd2l0Y2gnICsgKG9wdGlvbnMuY29sbGFwc2UgPyAnIGFjY29yZGlvbi10b2dnbGUnIDogJycpKS5hcHBlbmQoZ2V0VG9vbGJhcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDbGFzcygnZHJvcGRvd24tbWVudScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh1c2UyNEhvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuYWRkQ2xhc3MoJ3VzZXR3ZW50eWZvdXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmFibGVkKCdzJykgJiYgIXVzZTI0SG91cnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hZGRDbGFzcygnd2lkZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWRlQnlTaWRlICYmIGhhc0RhdGUoKSAmJiBoYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hZGRDbGFzcygndGltZXBpY2tlci1zYnMnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50b29sYmFyUGxhY2VtZW50ID09PSAndG9wJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmQodG9vbGJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygncm93JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoZGF0ZVZpZXcuYWRkQ2xhc3MoJ2NvbC1tZC02JykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHRpbWVWaWV3LmFkZENsYXNzKCdjb2wtbWQtNicpKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbGJhclBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuYXBwZW5kKHRvb2xiYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbGJhclBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZCh0b29sYmFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoYXNEYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZCgkKCc8bGk+JykuYWRkQ2xhc3MoKG9wdGlvbnMuY29sbGFwc2UgJiYgaGFzVGltZSgpID8gJ2NvbGxhcHNlIGluJyA6ICcnKSkuYXBwZW5kKGRhdGVWaWV3KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50b29sYmFyUGxhY2VtZW50ID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZCh0b29sYmFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZCgkKCc8bGk+JykuYWRkQ2xhc3MoKG9wdGlvbnMuY29sbGFwc2UgJiYgaGFzRGF0ZSgpID8gJ2NvbGxhcHNlJyA6ICcnKSkuYXBwZW5kKHRpbWVWaWV3KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50b29sYmFyUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kKHRvb2xiYXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmFwcGVuZChjb250ZW50KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGRhdGFUb09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YU9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcygnaW5wdXQnKSB8fCBvcHRpb25zLmlubGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVEYXRhID0gZWxlbWVudC5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVEYXRhID0gZWxlbWVudC5maW5kKCdpbnB1dCcpLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZURhdGEuZGF0ZU9wdGlvbnMgJiYgZURhdGEuZGF0ZU9wdGlvbnMgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhT3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIGRhdGFPcHRpb25zLCBlRGF0YS5kYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9ICdkYXRlJyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZURhdGFbYXR0cmlidXRlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT3B0aW9uc1trZXldID0gZURhdGFbYXR0cmlidXRlTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YU9wdGlvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwbGFjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IChjb21wb25lbnQgfHwgZWxlbWVudCkucG9zaXRpb24oKSxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAoY29tcG9uZW50IHx8IGVsZW1lbnQpLm9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsID0gb3B0aW9ucy53aWRnZXRQb3NpdGlvbmluZy52ZXJ0aWNhbCxcclxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gb3B0aW9ucy53aWRnZXRQb3NpdGlvbmluZy5ob3Jpem9udGFsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWRnZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBvcHRpb25zLndpZGdldFBhcmVudC5hcHBlbmQod2lkZ2V0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQuYWZ0ZXIod2lkZ2V0KS5wYXJlbnQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtZW50LmFwcGVuZCh3aWRnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuKCkuZmlyc3QoKS5hZnRlcih3aWRnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRvcCBhbmQgYm90dG9tIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWwgPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQudG9wICsgd2lkZ2V0LmhlaWdodCgpICogMS41ID49ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuaGVpZ2h0KCkgKyBlbGVtZW50Lm91dGVySGVpZ2h0KCkgPCBvZmZzZXQudG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsID0gJ3RvcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSAnYm90dG9tJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBhbmQgcmlnaHQgbG9naWNcclxuICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LndpZHRoKCkgPCBvZmZzZXQubGVmdCArIHdpZGdldC5vdXRlcldpZHRoKCkgLyAyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0ICsgd2lkZ2V0Lm91dGVyV2lkdGgoKSA+ICQod2luZG93KS53aWR0aCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWwgPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWwgPSAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuYWRkQ2xhc3MoJ3RvcCcpLnJlbW92ZUNsYXNzKCdib3R0b20nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmFkZENsYXNzKCdib3R0b20nKS5yZW1vdmVDbGFzcygndG9wJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnJlbW92ZUNsYXNzKCdwdWxsLXJpZ2h0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgcGFyZW50IGVsZW1lbnQgdGhhdCBoYXMgYSBub24tc3RhdGljIGNzcyBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmZpcnN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGV0aW1lcGlja2VyIGNvbXBvbmVudCBzaG91bGQgYmUgcGxhY2VkIHdpdGhpbiBhIG5vbi1zdGF0aWMgcG9zaXRpb25lZCBjb250YWluZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3aWRnZXQuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHZlcnRpY2FsID09PSAndG9wJyA/ICdhdXRvJyA6IHBvc2l0aW9uLnRvcCArIGVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHZlcnRpY2FsID09PSAndG9wJyA/IHBhcmVudC5vdXRlckhlaWdodCgpIC0gKHBhcmVudCA9PT0gZWxlbWVudCA/IDAgOiBwb3NpdGlvbi50b3ApIDogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGhvcml6b250YWwgPT09ICdsZWZ0JyA/IChwYXJlbnQgPT09IGVsZW1lbnQgPyAwIDogcG9zaXRpb24ubGVmdCkgOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGhvcml6b250YWwgPT09ICdsZWZ0JyA/ICdhdXRvJyA6IHBhcmVudC5vdXRlcldpZHRoKCkgLSBlbGVtZW50Lm91dGVyV2lkdGgoKSAtIChwYXJlbnQgPT09IGVsZW1lbnQgPyAwIDogcG9zaXRpb24ubGVmdClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgbm90aWZ5RXZlbnQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2RwLmNoYW5nZScgJiYgKChlLmRhdGUgJiYgZS5kYXRlLmlzU2FtZShlLm9sZERhdGUpKSB8fCAoIWUuZGF0ZSAmJiAhZS5vbGREYXRlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnRyaWdnZXIoZSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB2aWV3VXBkYXRlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlID09PSAneScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gJ1lZWVknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm90aWZ5RXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcC51cGRhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZSxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RGF0ZTogdmlld0RhdGUuY2xvbmUoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzaG93TW9kZSA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZSA9IE1hdGgubWF4KG1pblZpZXdNb2RlTnVtYmVyLCBNYXRoLm1pbigzLCBjdXJyZW50Vmlld01vZGUgKyBkaXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlciA+IGRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScgKyBkYXRlUGlja2VyTW9kZXNbY3VycmVudFZpZXdNb2RlXS5jbHNOYW1lKS5zaG93KCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmaWxsRG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9ICQoJzx0cj4nKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHZpZXdEYXRlLmNsb25lKCkuc3RhcnRPZigndycpLnN0YXJ0T2YoJ2QnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgkKCc8dGg+JykuYWRkQ2xhc3MoJ2N3JykudGV4dCgnIycpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudERhdGUuaXNCZWZvcmUodmlld0RhdGUuY2xvbmUoKS5lbmRPZigndycpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJCgnPHRoPicpLmFkZENsYXNzKCdkb3cnKS50ZXh0KGN1cnJlbnREYXRlLmZvcm1hdCgnZGQnKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLmFkZCgxLCAnZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQocm93KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGlzSW5EaXNhYmxlZERhdGVzID0gZnVuY3Rpb24gKHRlc3REYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXNhYmxlZERhdGVzW3Rlc3REYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpXSA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGlzSW5FbmFibGVkRGF0ZXMgPSBmdW5jdGlvbiAodGVzdERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVuYWJsZWREYXRlc1t0ZXN0RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKV0gPT09IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc0luRGlzYWJsZWRIb3VycyA9IGZ1bmN0aW9uICh0ZXN0RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlzYWJsZWRIb3Vyc1t0ZXN0RGF0ZS5mb3JtYXQoJ0gnKV0gPT09IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc0luRW5hYmxlZEhvdXJzID0gZnVuY3Rpb24gKHRlc3REYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbmFibGVkSG91cnNbdGVzdERhdGUuZm9ybWF0KCdIJyldID09PSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZ1bmN0aW9uICh0YXJnZXRNb21lbnQsIGdyYW51bGFyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldE1vbWVudC5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZERhdGVzICYmIGdyYW51bGFyaXR5ID09PSAnZCcgJiYgaXNJbkRpc2FibGVkRGF0ZXModGFyZ2V0TW9tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWREYXRlcyAmJiBncmFudWxhcml0eSA9PT0gJ2QnICYmICFpc0luRW5hYmxlZERhdGVzKHRhcmdldE1vbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5taW5EYXRlICYmIHRhcmdldE1vbWVudC5pc0JlZm9yZShvcHRpb25zLm1pbkRhdGUsIGdyYW51bGFyaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERhdGUgJiYgdGFyZ2V0TW9tZW50LmlzQWZ0ZXIob3B0aW9ucy5tYXhEYXRlLCBncmFudWxhcml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQgJiYgZ3JhbnVsYXJpdHkgPT09ICdkJyAmJiBvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZC5pbmRleE9mKHRhcmdldE1vbWVudC5kYXkoKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWRIb3VycyAmJiAoZ3JhbnVsYXJpdHkgPT09ICdoJyB8fCBncmFudWxhcml0eSA9PT0gJ20nIHx8IGdyYW51bGFyaXR5ID09PSAncycpICYmIGlzSW5EaXNhYmxlZEhvdXJzKHRhcmdldE1vbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkSG91cnMgJiYgKGdyYW51bGFyaXR5ID09PSAnaCcgfHwgZ3JhbnVsYXJpdHkgPT09ICdtJyB8fCBncmFudWxhcml0eSA9PT0gJ3MnKSAmJiAhaXNJbkVuYWJsZWRIb3Vycyh0YXJnZXRNb21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWRUaW1lSW50ZXJ2YWxzICYmIChncmFudWxhcml0eSA9PT0gJ2gnIHx8IGdyYW51bGFyaXR5ID09PSAnbScgfHwgZ3JhbnVsYXJpdHkgPT09ICdzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5kaXNhYmxlZFRpbWVJbnRlcnZhbHMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE1vbWVudC5pc0JldHdlZW4odGhpc1swXSwgdGhpc1sxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmaWxsTW9udGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5zID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzU2hvcnQgPSB2aWV3RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3knKS5zdGFydE9mKCdkJyk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobW9udGhzU2hvcnQuaXNTYW1lKHZpZXdEYXRlLCAneScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhbnMucHVzaCgkKCc8c3Bhbj4nKS5hdHRyKCdkYXRhLWFjdGlvbicsICdzZWxlY3RNb250aCcpLmFkZENsYXNzKCdtb250aCcpLnRleHQobW9udGhzU2hvcnQuZm9ybWF0KCdNTU0nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoc1Nob3J0LmFkZCgxLCAnTScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocyB0ZCcpLmVtcHR5KCkuYXBwZW5kKHNwYW5zKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHVwZGF0ZU1vbnRocyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb250aHNWaWV3ID0gd2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocycpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoc1ZpZXdIZWFkZXIgPSBtb250aHNWaWV3LmZpbmQoJ3RoJyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzID0gbW9udGhzVmlldy5maW5kKCd0Ym9keScpLmZpbmQoJ3NwYW4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb250aHNWaWV3SGVhZGVyLmVxKDApLmZpbmQoJ3NwYW4nKS5hdHRyKCd0aXRsZScsIG9wdGlvbnMudG9vbHRpcHMucHJldlllYXIpO1xyXG4gICAgICAgICAgICAgICAgbW9udGhzVmlld0hlYWRlci5lcSgxKS5hdHRyKCd0aXRsZScsIG9wdGlvbnMudG9vbHRpcHMuc2VsZWN0WWVhcik7XHJcbiAgICAgICAgICAgICAgICBtb250aHNWaWV3SGVhZGVyLmVxKDIpLmZpbmQoJ3NwYW4nKS5hdHRyKCd0aXRsZScsIG9wdGlvbnMudG9vbHRpcHMubmV4dFllYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1vbnRoc1ZpZXcuZmluZCgnLmRpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHZpZXdEYXRlLmNsb25lKCkuc3VidHJhY3QoMSwgJ3knKSwgJ3knKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoc1ZpZXdIZWFkZXIuZXEoMCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbW9udGhzVmlld0hlYWRlci5lcSgxKS50ZXh0KHZpZXdEYXRlLnllYXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHZpZXdEYXRlLmNsb25lKCkuYWRkKDEsICd5JyksICd5JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb250aHNWaWV3SGVhZGVyLmVxKDIpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1vbnRocy5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZS5pc1NhbWUodmlld0RhdGUsICd5JykgJiYgIXVuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzLmVxKGRhdGUubW9udGgoKSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1vbnRocy5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCh2aWV3RGF0ZS5jbG9uZSgpLm1vbnRoKGluZGV4KSwgJ00nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgdXBkYXRlWWVhcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeWVhcnNWaWV3ID0gd2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgeWVhcnNWaWV3SGVhZGVyID0geWVhcnNWaWV3LmZpbmQoJ3RoJyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZZWFyID0gdmlld0RhdGUuY2xvbmUoKS5zdWJ0cmFjdCg1LCAneScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFllYXIgPSB2aWV3RGF0ZS5jbG9uZSgpLmFkZCg2LCAneScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSAnJztcclxuXHJcbiAgICAgICAgICAgICAgICB5ZWFyc1ZpZXdIZWFkZXIuZXEoMCkuZmluZCgnc3BhbicpLmF0dHIoJ3RpdGxlJywgb3B0aW9ucy50b29sdGlwcy5wcmV2RGVjYWRlKTtcclxuICAgICAgICAgICAgICAgIHllYXJzVmlld0hlYWRlci5lcSgxKS5hdHRyKCd0aXRsZScsIG9wdGlvbnMudG9vbHRpcHMuc2VsZWN0RGVjYWRlKTtcclxuICAgICAgICAgICAgICAgIHllYXJzVmlld0hlYWRlci5lcSgyKS5maW5kKCdzcGFuJykuYXR0cigndGl0bGUnLCBvcHRpb25zLnRvb2x0aXBzLm5leHREZWNhZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHllYXJzVmlldy5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5taW5EYXRlICYmIG9wdGlvbnMubWluRGF0ZS5pc0FmdGVyKHN0YXJ0WWVhciwgJ3knKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXJzVmlld0hlYWRlci5lcSgwKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB5ZWFyc1ZpZXdIZWFkZXIuZXEoMSkudGV4dChzdGFydFllYXIueWVhcigpICsgJy0nICsgZW5kWWVhci55ZWFyKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERhdGUgJiYgb3B0aW9ucy5tYXhEYXRlLmlzQmVmb3JlKGVuZFllYXIsICd5JykpIHtcclxuICAgICAgICAgICAgICAgICAgICB5ZWFyc1ZpZXdIZWFkZXIuZXEoMikuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFzdGFydFllYXIuaXNBZnRlcihlbmRZZWFyLCAneScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gZGF0YS1hY3Rpb249XCJzZWxlY3RZZWFyXCIgY2xhc3M9XCJ5ZWFyJyArIChzdGFydFllYXIuaXNTYW1lKGRhdGUsICd5JykgJiYgIXVuc2V0ID8gJyBhY3RpdmUnIDogJycpICsgKCFpc1ZhbGlkKHN0YXJ0WWVhciwgJ3knKSA/ICcgZGlzYWJsZWQnIDogJycpICsgJ1wiPicgKyBzdGFydFllYXIueWVhcigpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WWVhci5hZGQoMSwgJ3knKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB5ZWFyc1ZpZXcuZmluZCgndGQnKS5odG1sKGh0bWwpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgdXBkYXRlRGVjYWRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNhZGVzVmlldyA9IHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kZWNhZGVzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXdIZWFkZXIgPSBkZWNhZGVzVmlldy5maW5kKCd0aCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGVjYWRlID0gbW9tZW50KHsgeTogdmlld0RhdGUueWVhcigpIC0gKHZpZXdEYXRlLnllYXIoKSAlIDEwMCkgLSAxIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZERlY2FkZSA9IHN0YXJ0RGVjYWRlLmNsb25lKCkuYWRkKDEwMCwgJ3knKSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydGVkQXQgPSBzdGFydERlY2FkZS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRhdGVEZWNhZGUgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhEYXRlRGVjYWRlID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kRGVjYWRlWWVhcixcclxuICAgICAgICAgICAgICAgICAgICBodG1sID0gJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXdIZWFkZXIuZXEoMCkuZmluZCgnc3BhbicpLmF0dHIoJ3RpdGxlJywgb3B0aW9ucy50b29sdGlwcy5wcmV2Q2VudHVyeSk7XHJcbiAgICAgICAgICAgICAgICBkZWNhZGVzVmlld0hlYWRlci5lcSgyKS5maW5kKCdzcGFuJykuYXR0cigndGl0bGUnLCBvcHRpb25zLnRvb2x0aXBzLm5leHRDZW50dXJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWNhZGVzVmlldy5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREZWNhZGUuaXNTYW1lKG1vbWVudCh7IHk6IDE5MDAgfSkpIHx8IChvcHRpb25zLm1pbkRhdGUgJiYgb3B0aW9ucy5taW5EYXRlLmlzQWZ0ZXIoc3RhcnREZWNhZGUsICd5JykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXdIZWFkZXIuZXEoMCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXdIZWFkZXIuZXEoMSkudGV4dChzdGFydERlY2FkZS55ZWFyKCkgKyAnLScgKyBlbmREZWNhZGUueWVhcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREZWNhZGUuaXNTYW1lKG1vbWVudCh7IHk6IDIwMDAgfSkpIHx8IChvcHRpb25zLm1heERhdGUgJiYgb3B0aW9ucy5tYXhEYXRlLmlzQmVmb3JlKGVuZERlY2FkZSwgJ3knKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNhZGVzVmlld0hlYWRlci5lcSgyKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXN0YXJ0RGVjYWRlLmlzQWZ0ZXIoZW5kRGVjYWRlLCAneScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kRGVjYWRlWWVhciA9IHN0YXJ0RGVjYWRlLnllYXIoKSArIDEyO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRhdGVEZWNhZGUgPSBvcHRpb25zLm1pbkRhdGUgJiYgb3B0aW9ucy5taW5EYXRlLmlzQWZ0ZXIoc3RhcnREZWNhZGUsICd5JykgJiYgb3B0aW9ucy5taW5EYXRlLnllYXIoKSA8PSBlbmREZWNhZGVZZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERhdGVEZWNhZGUgPSBvcHRpb25zLm1heERhdGUgJiYgb3B0aW9ucy5tYXhEYXRlLmlzQWZ0ZXIoc3RhcnREZWNhZGUsICd5JykgJiYgb3B0aW9ucy5tYXhEYXRlLnllYXIoKSA8PSBlbmREZWNhZGVZZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGRhdGEtYWN0aW9uPVwic2VsZWN0RGVjYWRlXCIgY2xhc3M9XCJkZWNhZGUnICsgKGRhdGUuaXNBZnRlcihzdGFydERlY2FkZSkgJiYgZGF0ZS55ZWFyKCkgPD0gZW5kRGVjYWRlWWVhciA/ICcgYWN0aXZlJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghaXNWYWxpZChzdGFydERlY2FkZSwgJ3knKSAmJiAhbWluRGF0ZURlY2FkZSAmJiAhbWF4RGF0ZURlY2FkZSA/ICcgZGlzYWJsZWQnIDogJycpICsgJ1wiIGRhdGEtc2VsZWN0aW9uPVwiJyArIChzdGFydERlY2FkZS55ZWFyKCkgKyA2KSArICdcIj4nICsgKHN0YXJ0RGVjYWRlLnllYXIoKSArIDEpICsgJyAtICcgKyAoc3RhcnREZWNhZGUueWVhcigpICsgMTIpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGVjYWRlLmFkZCgxMiwgJ3knKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuPjwvc3Bhbj48c3Bhbj48L3NwYW4+PHNwYW4+PC9zcGFuPic7IC8vcHVzaCB0aGUgZGFuZ2xpbmcgYmxvY2sgb3ZlciwgYXQgbGVhc3QgdGhpcyB3YXkgaXQncyBldmVuXHJcblxyXG4gICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXcuZmluZCgndGQnKS5odG1sKGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgZGVjYWRlc1ZpZXdIZWFkZXIuZXEoMSkudGV4dCgoc3RhcnRlZEF0LnllYXIoKSArIDEpICsgJy0nICsgKHN0YXJ0RGVjYWRlLnllYXIoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZmlsbERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF5c1ZpZXcgPSB3aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cycpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheXNWaWV3SGVhZGVyID0gZGF5c1ZpZXcuZmluZCgndGgnKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBodG1sID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgcm93LFxyXG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWVzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0RhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkYXlzVmlld0hlYWRlci5lcSgwKS5maW5kKCdzcGFuJykuYXR0cigndGl0bGUnLCBvcHRpb25zLnRvb2x0aXBzLnByZXZNb250aCk7XHJcbiAgICAgICAgICAgICAgICBkYXlzVmlld0hlYWRlci5lcSgxKS5hdHRyKCd0aXRsZScsIG9wdGlvbnMudG9vbHRpcHMuc2VsZWN0TW9udGgpO1xyXG4gICAgICAgICAgICAgICAgZGF5c1ZpZXdIZWFkZXIuZXEoMikuZmluZCgnc3BhbicpLmF0dHIoJ3RpdGxlJywgb3B0aW9ucy50b29sdGlwcy5uZXh0TW9udGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRheXNWaWV3LmZpbmQoJy5kaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgZGF5c1ZpZXdIZWFkZXIuZXEoMSkudGV4dCh2aWV3RGF0ZS5mb3JtYXQob3B0aW9ucy5kYXlWaWV3SGVhZGVyRm9ybWF0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHZpZXdEYXRlLmNsb25lKCkuc3VidHJhY3QoMSwgJ00nKSwgJ00nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheXNWaWV3SGVhZGVyLmVxKDApLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHZpZXdEYXRlLmNsb25lKCkuYWRkKDEsICdNJyksICdNJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXlzVmlld0hlYWRlci5lcSgyKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHZpZXdEYXRlLmNsb25lKCkuc3RhcnRPZignTScpLnN0YXJ0T2YoJ3cnKS5zdGFydE9mKCdkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQyOyBpKyspIHsgLy9hbHdheXMgZGlzcGxheSA0MiBkYXlzIChzaG91bGQgc2hvdyA2IHdlZWtzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZS53ZWVrZGF5KCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyPicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kKCc8dGQgY2xhc3M9XCJjd1wiPicgKyBjdXJyZW50RGF0ZS53ZWVrKCkgKyAnPC90ZD4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2gocm93KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZXMgPSBbJ2RheSddO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZS5pc0JlZm9yZSh2aWV3RGF0ZSwgJ00nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHNOYW1lcy5wdXNoKCdvbGQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRlLmlzQWZ0ZXIodmlld0RhdGUsICdNJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzTmFtZXMucHVzaCgnbmV3Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZS5pc1NhbWUoZGF0ZSwgJ2QnKSAmJiAhdW5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzTmFtZXMucHVzaCgnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChjdXJyZW50RGF0ZSwgJ2QnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHNOYW1lcy5wdXNoKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGUuaXNTYW1lKGdldE1vbWVudCgpLCAnZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsc05hbWVzLnB1c2goJ3RvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZS5kYXkoKSA9PT0gMCB8fCBjdXJyZW50RGF0ZS5kYXkoKSA9PT0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHNOYW1lcy5wdXNoKCd3ZWVrZW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RwLmNsYXNzaWZ5JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogY3VycmVudERhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IGNsc05hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgnPHRkIGRhdGEtYWN0aW9uPVwic2VsZWN0RGF5XCIgZGF0YS1kYXk9XCInICsgY3VycmVudERhdGUuZm9ybWF0KCdMJykgKyAnXCIgY2xhc3M9XCInICsgY2xzTmFtZXMuam9pbignICcpICsgJ1wiPicgKyBjdXJyZW50RGF0ZS5kYXRlKCkgKyAnPC90ZD4nKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5hZGQoMSwgJ2QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkYXlzVmlldy5maW5kKCd0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZU1vbnRocygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZVllYXJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGVjYWRlcygpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZmlsbEhvdXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyLWhvdXJzIHRhYmxlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhvdXIgPSB2aWV3RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ2QnKSxcclxuICAgICAgICAgICAgICAgICAgICBodG1sID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyPicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RGF0ZS5ob3VyKCkgPiAxMSAmJiAhdXNlMjRIb3Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIb3VyLmhvdXIoMTIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRIb3VyLmlzU2FtZSh2aWV3RGF0ZSwgJ2QnKSAmJiAodXNlMjRIb3VycyB8fCAodmlld0RhdGUuaG91cigpIDwgMTIgJiYgY3VycmVudEhvdXIuaG91cigpIDwgMTIpIHx8IHZpZXdEYXRlLmhvdXIoKSA+IDExKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SG91ci5ob3VyKCkgJSA0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9ICQoJzx0cj4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbC5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJzx0ZCBkYXRhLWFjdGlvbj1cInNlbGVjdEhvdXJcIiBjbGFzcz1cImhvdXInICsgKCFpc1ZhbGlkKGN1cnJlbnRIb3VyLCAnaCcpID8gJyBkaXNhYmxlZCcgOiAnJykgKyAnXCI+JyArIGN1cnJlbnRIb3VyLmZvcm1hdCh1c2UyNEhvdXJzID8gJ0hIJyA6ICdoaCcpICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhvdXIuYWRkKDEsICdoJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YWJsZS5lbXB0eSgpLmFwcGVuZChodG1sKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGZpbGxNaW51dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyLW1pbnV0ZXMgdGFibGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWludXRlID0gdmlld0RhdGUuY2xvbmUoKS5zdGFydE9mKCdoJyksXHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9ICQoJzx0cj4nKSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gb3B0aW9ucy5zdGVwcGluZyA9PT0gMSA/IDUgOiBvcHRpb25zLnN0ZXBwaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlICh2aWV3RGF0ZS5pc1NhbWUoY3VycmVudE1pbnV0ZSwgJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWludXRlLm1pbnV0ZSgpICUgKHN0ZXAgKiA0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSAkKCc8dHI+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kKCc8dGQgZGF0YS1hY3Rpb249XCJzZWxlY3RNaW51dGVcIiBjbGFzcz1cIm1pbnV0ZScgKyAoIWlzVmFsaWQoY3VycmVudE1pbnV0ZSwgJ20nKSA/ICcgZGlzYWJsZWQnIDogJycpICsgJ1wiPicgKyBjdXJyZW50TWludXRlLmZvcm1hdCgnbW0nKSArICc8L3RkPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNaW51dGUuYWRkKHN0ZXAsICdtJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YWJsZS5lbXB0eSgpLmFwcGVuZChodG1sKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGZpbGxTZWNvbmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyLXNlY29uZHMgdGFibGUnKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vjb25kID0gdmlld0RhdGUuY2xvbmUoKS5zdGFydE9mKCdtJyksXHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9ICQoJzx0cj4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodmlld0RhdGUuaXNTYW1lKGN1cnJlbnRTZWNvbmQsICdtJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlY29uZC5zZWNvbmQoKSAlIDIwID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9ICQoJzx0cj4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbC5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJzx0ZCBkYXRhLWFjdGlvbj1cInNlbGVjdFNlY29uZFwiIGNsYXNzPVwic2Vjb25kJyArICghaXNWYWxpZChjdXJyZW50U2Vjb25kLCAncycpID8gJyBkaXNhYmxlZCcgOiAnJykgKyAnXCI+JyArIGN1cnJlbnRTZWNvbmQuZm9ybWF0KCdzcycpICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlY29uZC5hZGQoNSwgJ3MnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YWJsZS5lbXB0eSgpLmFwcGVuZChodG1sKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGZpbGxUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvZ2dsZSwgbmV3RGF0ZSwgdGltZUNvbXBvbmVudHMgPSB3aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgc3BhbltkYXRhLXRpbWUtY29tcG9uZW50XScpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdXNlMjRIb3Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHdpZGdldC5maW5kKCcudGltZXBpY2tlciBbZGF0YS1hY3Rpb249dG9nZ2xlUGVyaW9kXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBkYXRlLmNsb25lKCkuYWRkKChkYXRlLmhvdXJzKCkgPj0gMTIpID8gLTEyIDogMTIsICdoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS50ZXh0KGRhdGUuZm9ybWF0KCdBJykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChuZXdEYXRlLCAnaCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGUuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1ob3Vyc10nKS50ZXh0KGRhdGUuZm9ybWF0KHVzZTI0SG91cnMgPyAnSEgnIDogJ2hoJykpO1xyXG4gICAgICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1taW51dGVzXScpLnRleHQoZGF0ZS5mb3JtYXQoJ21tJykpO1xyXG4gICAgICAgICAgICAgICAgdGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1zZWNvbmRzXScpLnRleHQoZGF0ZS5mb3JtYXQoJ3NzJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGxIb3VycygpO1xyXG4gICAgICAgICAgICAgICAgZmlsbE1pbnV0ZXMoKTtcclxuICAgICAgICAgICAgICAgIGZpbGxTZWNvbmRzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBmaWxsVGltZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0VmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0TW9tZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkRGF0ZSA9IHVuc2V0ID8gbnVsbCA6IGRhdGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBvZiBjYWxsaW5nIHNldFZhbHVlKG51bGwgb3IgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldE1vbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YSgnZGF0ZScsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcC5jaGFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGF0ZTogb2xkRGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNb21lbnQgPSB0YXJnZXRNb21lbnQuY2xvbmUoKS5sb2NhbGUob3B0aW9ucy5sb2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNUaW1lWm9uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TW9tZW50LnR6KG9wdGlvbnMudGltZVpvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0ZXBwaW5nICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TW9tZW50Lm1pbnV0ZXMoKE1hdGgucm91bmQodGFyZ2V0TW9tZW50Lm1pbnV0ZXMoKSAvIG9wdGlvbnMuc3RlcHBpbmcpICogb3B0aW9ucy5zdGVwcGluZykpLnNlY29uZHMoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcHRpb25zLm1pbkRhdGUgJiYgdGFyZ2V0TW9tZW50LmlzQmVmb3JlKG9wdGlvbnMubWluRGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TW9tZW50LmFkZChvcHRpb25zLnN0ZXBwaW5nLCAnbWludXRlcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCh0YXJnZXRNb21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IHRhcmdldE1vbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RGF0ZSA9IGRhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWwoZGF0ZS5mb3JtYXQoYWN0dWFsRm9ybWF0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhKCdkYXRlJywgZGF0ZS5mb3JtYXQoYWN0dWFsRm9ybWF0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcC5jaGFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZERhdGU6IG9sZERhdGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbCh1bnNldCA/ICcnIDogZGF0ZS5mb3JtYXQoYWN0dWFsRm9ybWF0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZ5RXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RwLmNoYW5nZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0YXJnZXRNb21lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREYXRlOiBvbGREYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcC5lcnJvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IHRhcmdldE1vbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGF0ZTogb2xkRGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhpZGVzIHRoZSB3aWRnZXQuIFBvc3NpYmx5IHdpbGwgZW1pdCBkcC5oaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBoaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBldmVudCBpZiBpbiB0aGUgbWlkZGxlIG9mIGEgcGlja2VyIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIHdpZGdldC5maW5kKCcuY29sbGFwc2UnKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGFwc2VEYXRhID0gJCh0aGlzKS5kYXRhKCdjb2xsYXBzZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZURhdGEgJiYgY29sbGFwc2VEYXRhLnRyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Lmhhc0NsYXNzKCdidG4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aWRnZXQuaGlkZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScsIHBsYWNlKTtcclxuICAgICAgICAgICAgICAgIHdpZGdldC5vZmYoJ2NsaWNrJywgJ1tkYXRhLWFjdGlvbl0nKTtcclxuICAgICAgICAgICAgICAgIHdpZGdldC5vZmYoJ21vdXNlZG93bicsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aWRnZXQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB3aWRnZXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBub3RpZnlFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RwLmhpZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUuY2xvbmUoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5wdXQuYmx1cigpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZpZXdEYXRlID0gZGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBjbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbHVlKG51bGwpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGFyc2VJbnB1dERhdGUgPSBmdW5jdGlvbiAoaW5wdXREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZUlucHV0RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb21lbnQuaXNNb21lbnQoaW5wdXREYXRlKSB8fCBpbnB1dERhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RGF0ZSA9IGdldE1vbWVudChpbnB1dERhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXREYXRlID0gb3B0aW9ucy5wYXJzZUlucHV0RGF0ZShpbnB1dERhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9pbnB1dERhdGUubG9jYWxlKG9wdGlvbnMubG9jYWxlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dERhdGU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogV2lkZ2V0IFVJIGludGVyYWN0aW9uIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgICAgIGFjdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdkZuYyA9IGRhdGVQaWNrZXJNb2Rlc1tjdXJyZW50Vmlld01vZGVdLm5hdkZuYztcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RGF0ZS5hZGQoZGF0ZVBpY2tlck1vZGVzW2N1cnJlbnRWaWV3TW9kZV0ubmF2U3RlcCwgbmF2Rm5jKTtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdVcGRhdGUobmF2Rm5jKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmF2Rm5jID0gZGF0ZVBpY2tlck1vZGVzW2N1cnJlbnRWaWV3TW9kZV0ubmF2Rm5jO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdEYXRlLnN1YnRyYWN0KGRhdGVQaWNrZXJNb2Rlc1tjdXJyZW50Vmlld01vZGVdLm5hdlN0ZXAsIG5hdkZuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VXBkYXRlKG5hdkZuYyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBpY2tlclN3aXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3dNb2RlKDEpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RNb250aDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9udGggPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCd0Ym9keScpLmZpbmQoJ3NwYW4nKS5pbmRleCgkKGUudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0RhdGUubW9udGgobW9udGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Vmlld01vZGUgPT09IG1pblZpZXdNb2RlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGRhdGUuY2xvbmUoKS55ZWFyKHZpZXdEYXRlLnllYXIoKSkubW9udGgodmlld0RhdGUubW9udGgoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdVcGRhdGUoJ00nKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZWN0WWVhcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KCQoZS50YXJnZXQpLnRleHQoKSwgMTApIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0RhdGUueWVhcih5ZWFyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZpZXdNb2RlID09PSBtaW5WaWV3TW9kZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShkYXRlLmNsb25lKCkueWVhcih2aWV3RGF0ZS55ZWFyKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlubGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZGUoLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2aWV3VXBkYXRlKCdZWVlZJyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGVjdERlY2FkZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KCQoZS50YXJnZXQpLmRhdGEoJ3NlbGVjdGlvbicpLCAxMCkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RGF0ZS55ZWFyKHllYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Vmlld01vZGUgPT09IG1pblZpZXdNb2RlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGRhdGUuY2xvbmUoKS55ZWFyKHZpZXdEYXRlLnllYXIoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdVcGRhdGUoJ1lZWVknKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZWN0RGF5OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSB2aWV3RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnLm9sZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheS5zdWJ0cmFjdCgxLCAnTScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoJChlLnRhcmdldCkuaXMoJy5uZXcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkuYWRkKDEsICdNJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGRheS5kYXRlKHBhcnNlSW50KCQoZS50YXJnZXQpLnRleHQoKSwgMTApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNUaW1lKCkgJiYgIW9wdGlvbnMua2VlcE9wZW4gJiYgIW9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGluY3JlbWVudEhvdXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBkYXRlLmNsb25lKCkuYWRkKDEsICdoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQobmV3RGF0ZSwgJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShuZXdEYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGluY3JlbWVudE1pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0ZSA9IGRhdGUuY2xvbmUoKS5hZGQob3B0aW9ucy5zdGVwcGluZywgJ20nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChuZXdEYXRlLCAnbScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKG5ld0RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50U2Vjb25kczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRlID0gZGF0ZS5jbG9uZSgpLmFkZCgxLCAncycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld0RhdGUsICdzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUobmV3RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRIb3VyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRlID0gZGF0ZS5jbG9uZSgpLnN1YnRyYWN0KDEsICdoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQobmV3RGF0ZSwgJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShuZXdEYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudE1pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0ZSA9IGRhdGUuY2xvbmUoKS5zdWJ0cmFjdChvcHRpb25zLnN0ZXBwaW5nLCAnbScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld0RhdGUsICdtJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUobmV3RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBkYXRlLmNsb25lKCkuc3VidHJhY3QoMSwgJ3MnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChuZXdEYXRlLCAncycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKG5ld0RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGVyaW9kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZS5jbG9uZSgpLmFkZCgoZGF0ZS5ob3VycygpID49IDEyKSA/IC0xMiA6IDEyLCAnaCcpKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGlja2VyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQoZS50YXJnZXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkcGFyZW50ID0gJHRoaXMuY2xvc2VzdCgndWwnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSAkcGFyZW50LmZpbmQoJy5pbicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSAkcGFyZW50LmZpbmQoJy5jb2xsYXBzZTpub3QoLmluKScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZURhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZCAmJiBleHBhbmRlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VEYXRhID0gZXhwYW5kZWQuZGF0YSgnY29sbGFwc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxhcHNlRGF0YSAmJiBjb2xsYXBzZURhdGEudHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZC5jb2xsYXBzZSkgeyAvLyBpZiBjb2xsYXBzZSBwbHVnaW4gaXMgYXZhaWxhYmxlIHRocm91Z2ggYm9vdHN0cmFwLmpzIHRoZW4gdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5jb2xsYXBzZSgnaGlkZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VkLmNvbGxhcHNlKCdzaG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBqdXN0IHRvZ2dsZSBpbiBjbGFzcyBvbiB0aGUgdHdvIHZpZXdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5yZW1vdmVDbGFzcygnaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZC5hZGRDbGFzcygnaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXMuaXMoJ3NwYW4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudG9nZ2xlQ2xhc3Mob3B0aW9ucy5pY29ucy50aW1lICsgJyAnICsgb3B0aW9ucy5pY29ucy5kYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJ3NwYW4nKS50b2dnbGVDbGFzcyhvcHRpb25zLmljb25zLnRpbWUgKyAnICcgKyBvcHRpb25zLmljb25zLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB1bmNvbW1lbnQgaWYgdG9nZ2xlZCBzdGF0ZSB3aWxsIGJlIHJlc3RvcmVkIGluIHNob3coKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgY29tcG9uZW50LmZpbmQoJ3NwYW4nKS50b2dnbGVDbGFzcyhvcHRpb25zLmljb25zLnRpbWUgKyAnICcgKyBvcHRpb25zLmljb25zLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNob3dQaWNrZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgPiBkaXY6bm90KC50aW1lcGlja2VyLXBpY2tlciknKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2hvd0hvdXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItaG91cnMnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNob3dNaW51dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItbWludXRlcycpLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2hvd1NlY29uZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1zZWNvbmRzJykuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RIb3VyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3VyID0gcGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlMjRIb3Vycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZS5ob3VycygpID49IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG91ciAhPT0gMTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZS5jbG9uZSgpLmhvdXJzKGhvdXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RNaW51dGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZS5jbG9uZSgpLm1pbnV0ZXMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RTZWNvbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZS5jbG9uZSgpLnNlY29uZHMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjbGVhcjogY2xlYXIsXHJcblxyXG4gICAgICAgICAgICAgICAgdG9kYXk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9kYXlzRGF0ZSA9IGdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRvZGF5c0RhdGUsICdkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUodG9kYXlzRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjbG9zZTogaGlkZVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZG9BY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCQoZS5jdXJyZW50VGFyZ2V0KS5pcygnLmRpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zWyQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdhY3Rpb24nKV0uYXBwbHkocGlja2VyLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNob3dzIHRoZSB3aWRnZXQuIFBvc3NpYmx5IHdpbGwgZW1pdCBkcC5zaG93IGFuZCBkcC5jaGFuZ2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE1vbWVudCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VDdXJyZW50R3JhbnVsYXJpdHkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd5ZWFyJzogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLm1vbnRoKDApLmRhdGUoMSkuaG91cnMoMCkuc2Vjb25kcygwKS5taW51dGVzKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbW9udGgnOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uZGF0ZSgxKS5ob3VycygwKS5zZWNvbmRzKDApLm1pbnV0ZXMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXknOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uaG91cnMoMCkuc2Vjb25kcygwKS5taW51dGVzKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaG91cic6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5zZWNvbmRzKDApLm1pbnV0ZXMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW51dGUnOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uc2Vjb25kcygwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnByb3AoJ2Rpc2FibGVkJykgfHwgKCFvcHRpb25zLmlnbm9yZVJlYWRvbmx5ICYmIGlucHV0LnByb3AoJ3JlYWRvbmx5JykpIHx8IHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudmFsKCkgIT09IHVuZGVmaW5lZCAmJiBpbnB1dC52YWwoKS50cmltKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUocGFyc2VJbnB1dERhdGUoaW5wdXQudmFsKCkudHJpbSgpKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVuc2V0ICYmIG9wdGlvbnMudXNlQ3VycmVudCAmJiAob3B0aW9ucy5pbmxpbmUgfHwgKGlucHV0LmlzKCdpbnB1dCcpICYmIGlucHV0LnZhbCgpLnRyaW0oKS5sZW5ndGggPT09IDApKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb21lbnQgPSBnZXRNb21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudXNlQ3VycmVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vbWVudCA9IHVzZUN1cnJlbnRHcmFudWxhcml0eVtvcHRpb25zLnVzZUN1cnJlbnRdKGN1cnJlbnRNb21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShjdXJyZW50TW9tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpZGdldCA9IGdldFRlbXBsYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmlsbERvdygpO1xyXG4gICAgICAgICAgICAgICAgZmlsbE1vbnRocygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdpZGdldC5maW5kKCcudGltZXBpY2tlci1ob3VycycpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHdpZGdldC5maW5kKCcudGltZXBpY2tlci1taW51dGVzJykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyLXNlY29uZHMnKS5oaWRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBzaG93TW9kZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbigncmVzaXplJywgcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0Lm9uKCdjbGljaycsICdbZGF0YS1hY3Rpb25dJywgZG9BY3Rpb24pOyAvLyB0aGlzIGhhbmRsZXMgY2xpY2tzIG9uIHRoZSB3aWRnZXRcclxuICAgICAgICAgICAgICAgIHdpZGdldC5vbignbW91c2Vkb3duJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Lmhhc0NsYXNzKCdidG4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwbGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNob3coKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvY3VzT25TaG93ICYmICFpbnB1dC5pcygnOmZvY3VzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5vdGlmeUV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZHAuc2hvdydcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTaG93cyBvciBoaWRlcyB0aGUgd2lkZ2V0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHdpZGdldCA/IGhpZGUoKSA6IHNob3coKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBrZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkTW9kaWZpZXJzID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleSA9IGUud2hpY2gsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5QmluZEtleXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsTW9kaWZpZXJzUHJlc3NlZCxcclxuICAgICAgICAgICAgICAgICAgICBwcmVzc2VkID0gJ3AnO1xyXG5cclxuICAgICAgICAgICAgICAgIGtleVN0YXRlW2N1cnJlbnRLZXldID0gcHJlc3NlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIGtleVN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVN0YXRlLmhhc093blByb3BlcnR5KGluZGV4KSAmJiBrZXlTdGF0ZVtpbmRleF0gPT09IHByZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChpbmRleCwgMTApICE9PSBjdXJyZW50S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzc2VkTW9kaWZpZXJzW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCBpbiBvcHRpb25zLmtleUJpbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5QmluZHMuaGFzT3duUHJvcGVydHkoaW5kZXgpICYmIHR5cGVvZiAob3B0aW9ucy5rZXlCaW5kc1tpbmRleF0pID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUJpbmRLZXlzID0gaW5kZXguc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleUJpbmRLZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMubGVuZ3RoICYmIGtleU1hcFtjdXJyZW50S2V5XSA9PT0ga2V5QmluZEtleXNba2V5QmluZEtleXMubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbE1vZGlmaWVyc1ByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbmRleDIgPSBrZXlCaW5kS2V5cy5sZW5ndGggLSAyOyBpbmRleDIgPj0gMDsgaW5kZXgyLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXlNYXBba2V5QmluZEtleXNbaW5kZXgyXV0gaW4gcHJlc3NlZE1vZGlmaWVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsTW9kaWZpZXJzUHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsTW9kaWZpZXJzUHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zLmtleUJpbmRzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChwaWNrZXIsIHdpZGdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBrZXl1cCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlTdGF0ZVtlLndoaWNoXSA9ICdyJztcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBjaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9ICQoZS50YXJnZXQpLnZhbCgpLnRyaW0oKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gdmFsID8gcGFyc2VJbnB1dERhdGUodmFsKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShwYXJzZWREYXRlKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBhdHRhY2hEYXRlUGlja2VyRWxlbWVudEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0Lm9uKHtcclxuICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJzogY2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICdibHVyJzogb3B0aW9ucy5kZWJ1ZyA/ICcnIDogaGlkZSxcclxuICAgICAgICAgICAgICAgICAgICAna2V5ZG93bic6IGtleWRvd24sXHJcbiAgICAgICAgICAgICAgICAgICAgJ2tleXVwJzoga2V5dXAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZvY3VzJzogb3B0aW9ucy5hbGxvd0lucHV0VG9nZ2xlID8gc2hvdyA6ICcnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvY3VzJzogc2hvd1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQub24oJ2NsaWNrJywgdG9nZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQub24oJ21vdXNlZG93bicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGRldGFjaERhdGVQaWNrZXJFbGVtZW50RXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQub2ZmKHtcclxuICAgICAgICAgICAgICAgICAgICAnY2hhbmdlJzogY2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICdibHVyJzogYmx1cixcclxuICAgICAgICAgICAgICAgICAgICAna2V5ZG93bic6IGtleWRvd24sXHJcbiAgICAgICAgICAgICAgICAgICAgJ2tleXVwJzoga2V5dXAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZvY3VzJzogb3B0aW9ucy5hbGxvd0lucHV0VG9nZ2xlID8gaGlkZSA6ICcnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm9mZih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb2N1cyc6IHNob3dcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm9mZignY2xpY2snLCB0b2dnbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vZmYoJ21vdXNlZG93bicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGluZGV4R2l2ZW5EYXRlcyA9IGZ1bmN0aW9uIChnaXZlbkRhdGVzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGdpdmVuIGVuYWJsZWREYXRlcyBhbmQgZGlzYWJsZWREYXRlcyBhcyBrZXlzLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXkgd2UgY2FuIGNoZWNrIHRoZWlyIGV4aXN0ZW5jZSBpbiBPKDEpIHRpbWUgaW5zdGVhZCBvZiBsb29waW5nIHRocm91Z2ggd2hvbGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGU6IG9wdGlvbnMuZW5hYmxlZERhdGVzWycyMDE0LTAyLTI3J10gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2l2ZW5EYXRlc0luZGV4ZWQgPSB7fTtcclxuICAgICAgICAgICAgICAgICQuZWFjaChnaXZlbkRhdGVzQXJyYXksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZERhdGUgPSBwYXJzZUlucHV0RGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZERhdGUuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuRGF0ZXNJbmRleGVkW2REYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5rZXlzKGdpdmVuRGF0ZXNJbmRleGVkKS5sZW5ndGgpID8gZ2l2ZW5EYXRlc0luZGV4ZWQgOiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGluZGV4R2l2ZW5Ib3VycyA9IGZ1bmN0aW9uIChnaXZlbkhvdXJzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGdpdmVuIGVuYWJsZWRIb3VycyBhbmQgZGlzYWJsZWRIb3VycyBhcyBrZXlzLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXkgd2UgY2FuIGNoZWNrIHRoZWlyIGV4aXN0ZW5jZSBpbiBPKDEpIHRpbWUgaW5zdGVhZCBvZiBsb29waW5nIHRocm91Z2ggd2hvbGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGU6IG9wdGlvbnMuZW5hYmxlZEhvdXJzWycyMDE0LTAyLTI3J10gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2l2ZW5Ib3Vyc0luZGV4ZWQgPSB7fTtcclxuICAgICAgICAgICAgICAgICQuZWFjaChnaXZlbkhvdXJzQXJyYXksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBnaXZlbkhvdXJzSW5kZXhlZFt0aGlzXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmtleXMoZ2l2ZW5Ib3Vyc0luZGV4ZWQpLmxlbmd0aCkgPyBnaXZlbkhvdXJzSW5kZXhlZCA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgaW5pdEZvcm1hdHRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ0wgTFQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGFjdHVhbEZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csIGZ1bmN0aW9uIChmb3JtYXRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdpbnB1dCA9IGRhdGUubG9jYWxlRGF0YSgpLmxvbmdEYXRlRm9ybWF0KGZvcm1hdElucHV0KSB8fCBmb3JtYXRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3aW5wdXQucmVwbGFjZSgvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLCBmdW5jdGlvbiAoZm9ybWF0SW5wdXQyKSB7IC8vdGVtcCBmaXggZm9yICM3NDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUubG9jYWxlRGF0YSgpLmxvbmdEYXRlRm9ybWF0KGZvcm1hdElucHV0MikgfHwgZm9ybWF0SW5wdXQyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlRm9ybWF0cyA9IG9wdGlvbnMuZXh0cmFGb3JtYXRzID8gb3B0aW9ucy5leHRyYUZvcm1hdHMuc2xpY2UoKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRm9ybWF0cy5pbmRleE9mKGZvcm1hdCkgPCAwICYmIHBhcnNlRm9ybWF0cy5pbmRleE9mKGFjdHVhbEZvcm1hdCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGb3JtYXRzLnB1c2goYWN0dWFsRm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB1c2UyNEhvdXJzID0gKGFjdHVhbEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2EnKSA8IDEgJiYgYWN0dWFsRm9ybWF0LnJlcGxhY2UoL1xcWy4qP1xcXS9nLCAnJykuaW5kZXhPZignaCcpIDwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCgneScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluVmlld01vZGVOdW1iZXIgPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCgnTScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluVmlld01vZGVOdW1iZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCgnZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluVmlld01vZGVOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZSA9IE1hdGgubWF4KG1pblZpZXdNb2RlTnVtYmVyLCBjdXJyZW50Vmlld01vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdW5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQdWJsaWMgQVBJIGZ1bmN0aW9uc1xyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW1wb3J0YW50OiBEbyBub3QgZXhwb3NlIGRpcmVjdCByZWZlcmVuY2VzIHRvIHByaXZhdGUgb2JqZWN0cyBvciB0aGUgb3B0aW9uc1xyXG4gICAgICAgICAqIG9iamVjdCB0byB0aGUgb3V0ZXIgd29ybGQuIEFsd2F5cyByZXR1cm4gYSBjbG9uZSB3aGVuIHJldHVybmluZyB2YWx1ZXMgb3IgbWFrZVxyXG4gICAgICAgICAqIGEgY2xvbmUgd2hlbiBzZXR0aW5nIGEgcHJpdmF0ZSB2YXJpYWJsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICBwaWNrZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+RGVzdHJveXMgdGhlIHdpZGdldCBhbmQgcmVtb3ZlcyBhbGwgYXR0YWNoZWQgZXZlbnQgbGlzdGVuZXJzPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgIGRldGFjaERhdGVQaWNrZXJFbGVtZW50RXZlbnRzKCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVEYXRhKCdkYXRlJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLnRvZ2dsZSA9IHRvZ2dsZTtcclxuXHJcbiAgICAgICAgcGlja2VyLnNob3cgPSBzaG93O1xyXG5cclxuICAgICAgICBwaWNrZXIuaGlkZSA9IGhpZGU7XHJcblxyXG4gICAgICAgIHBpY2tlci5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLy88c3VtbWFyeT5EaXNhYmxlcyB0aGUgaW5wdXQgZWxlbWVudCwgdGhlIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0bywgYnkgYWRkaW5nIGEgZGlzYWJsZWQ9XCJ0cnVlXCIgYXR0cmlidXRlIHRvIGl0LlxyXG4gICAgICAgICAgICAvLy9JZiB0aGUgd2lkZ2V0IHdhcyB2aXNpYmxlIGJlZm9yZSB0aGF0IGNhbGwgaXQgaXMgaGlkZGVuLiBQb3NzaWJseSBlbWl0cyBkcC5oaWRlPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Lmhhc0NsYXNzKCdidG4nKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlucHV0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+RW5hYmxlcyB0aGUgaW5wdXQgZWxlbWVudCwgdGhlIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0bywgYnkgcmVtb3ZpbmcgZGlzYWJsZWQgYXR0cmlidXRlIGZyb20gaXQuPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5oYXNDbGFzcygnYnRuJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnB1dC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuaWdub3JlUmVhZG9ubHkgPSBmdW5jdGlvbiAoaWdub3JlUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmlnbm9yZVJlYWRvbmx5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWdub3JlUmVhZG9ubHkgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWdub3JlUmVhZG9ubHkgKCkgZXhwZWN0cyBhIGJvb2xlYW4gcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5pZ25vcmVSZWFkb25seSA9IGlnbm9yZVJlYWRvbmx5O1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5vcHRpb25zID0gZnVuY3Rpb24gKG5ld09wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghKG5ld09wdGlvbnMgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zKCkgb3B0aW9ucyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAkLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwaWNrZXJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyW2tleV0odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIGtleSArICcgaXMgbm90IHJlY29nbml6ZWQhJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5kYXRlID0gZnVuY3Rpb24gKG5ld0RhdGUpIHtcclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZGF0ZVwiPlxyXG4gICAgICAgICAgICAvLy88c3VtbWFyeT5SZXR1cm5zIHRoZSBjb21wb25lbnQncyBtb2RlbCBjdXJyZW50IGRhdGUsIGEgbW9tZW50IG9iamVjdCBvciBudWxsIGlmIG5vdCBzZXQuPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cmV0dXJucyB0eXBlPVwiTW9tZW50XCI+ZGF0ZS5jbG9uZSgpPC9yZXR1cm5zPlxyXG4gICAgICAgICAgICAvLy88L3NpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+U2V0cyB0aGUgY29tcG9uZW50cyBtb2RlbCBjdXJyZW50IG1vbWVudCB0byBpdC4gUGFzc2luZyBhIG51bGwgdmFsdWUgdW5zZXRzIHRoZSBjb21wb25lbnRzIG1vZGVsIGN1cnJlbnQgbW9tZW50LiBQYXJzaW5nIG9mIHRoZSBuZXdEYXRlIHBhcmFtZXRlciBpcyBtYWRlIHVzaW5nIG1vbWVudCBsaWJyYXJ5IHdpdGggdGhlIG9wdGlvbnMuZm9ybWF0IGFuZCBvcHRpb25zLnVzZVN0cmljdCBjb21wb25lbnRzIGNvbmZpZ3VyYXRpb24uPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cGFyYW0gbmFtZT1cIm5ld0RhdGVcIiBsb2NpZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZGF0ZV9wOm5ld0RhdGVcIj5UYWtlcyBzdHJpbmcsIERhdGUsIG1vbWVudCwgbnVsbCBwYXJhbWV0ZXIuPC9wYXJhbT5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZXdEYXRlICE9PSBudWxsICYmIHR5cGVvZiBuZXdEYXRlICE9PSAnc3RyaW5nJyAmJiAhbW9tZW50LmlzTW9tZW50KG5ld0RhdGUpICYmICEobmV3RGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRlKCkgcGFyYW1ldGVyIG11c3QgYmUgb25lIG9mIFtudWxsLCBzdHJpbmcsIG1vbWVudCBvciBEYXRlXScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRWYWx1ZShuZXdEYXRlID09PSBudWxsID8gbnVsbCA6IHBhcnNlSW5wdXREYXRlKG5ld0RhdGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuZm9ybWF0ID0gZnVuY3Rpb24gKG5ld0Zvcm1hdCkge1xyXG4gICAgICAgICAgICAvLy88c3VtbWFyeT50ZXN0IHN1PC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cGFyYW0gbmFtZT1cIm5ld0Zvcm1hdFwiPmluZm8gYWJvdXQgcGFyYTwvcGFyYW0+XHJcbiAgICAgICAgICAgIC8vLzxyZXR1cm5zIHR5cGU9XCJzdHJpbmd8Ym9vbGVhblwiPnJldHVybnMgZm9vPC9yZXR1cm5zPlxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBuZXdGb3JtYXQgIT09ICdzdHJpbmcnKSAmJiAoKHR5cGVvZiBuZXdGb3JtYXQgIT09ICdib29sZWFuJykgfHwgKG5ld0Zvcm1hdCAhPT0gZmFsc2UpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZm9ybWF0KCkgZXhwZWN0cyBhIHN0cmluZyBvciBib29sZWFuOmZhbHNlIHBhcmFtZXRlciAnICsgbmV3Rm9ybWF0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBuZXdGb3JtYXQ7XHJcbiAgICAgICAgICAgIGlmIChhY3R1YWxGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIGluaXRGb3JtYXR0aW5nKCk7IC8vIHJlaW5pdCBmb3JtYXR0aW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIudGltZVpvbmUgPSBmdW5jdGlvbiAobmV3Wm9uZSkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudGltZVpvbmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Wm9uZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25ld1pvbmUoKSBleHBlY3RzIGEgc3RyaW5nIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnRpbWVab25lID0gbmV3Wm9uZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmRheVZpZXdIZWFkZXJGb3JtYXQgPSBmdW5jdGlvbiAobmV3Rm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlWaWV3SGVhZGVyRm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0Zvcm1hdCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RheVZpZXdIZWFkZXJGb3JtYXQoKSBleHBlY3RzIGEgc3RyaW5nIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLmRheVZpZXdIZWFkZXJGb3JtYXQgPSBuZXdGb3JtYXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmV4dHJhRm9ybWF0cyA9IGZ1bmN0aW9uIChmb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5leHRyYUZvcm1hdHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRzICE9PSBmYWxzZSAmJiAhKGZvcm1hdHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dHJhRm9ybWF0cygpIGV4cGVjdHMgYW4gYXJyYXkgb3IgZmFsc2UgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFGb3JtYXRzID0gZm9ybWF0cztcclxuICAgICAgICAgICAgaWYgKHBhcnNlRm9ybWF0cykge1xyXG4gICAgICAgICAgICAgICAgaW5pdEZvcm1hdHRpbmcoKTsgLy8gcmVpbml0IGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5kaXNhYmxlZERhdGVzID0gZnVuY3Rpb24gKGRhdGVzKSB7XHJcbiAgICAgICAgICAgIC8vLzxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCIkLmZuLmRhdGV0aW1lcGlja2VyLmRpc2FibGVkRGF0ZXNcIj5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+UmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50bHkgc2V0IGRpc2FibGVkIGRhdGVzIG9uIHRoZSBjb21wb25lbnQuPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cmV0dXJucyB0eXBlPVwiYXJyYXlcIj5vcHRpb25zLmRpc2FibGVkRGF0ZXM8L3JldHVybnM+XHJcbiAgICAgICAgICAgIC8vLzwvc2lnbmF0dXJlPlxyXG4gICAgICAgICAgICAvLy88c2lnbmF0dXJlPlxyXG4gICAgICAgICAgICAvLy88c3VtbWFyeT5TZXR0aW5nIHRoaXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG9wdGlvbnMubWluRGF0ZSwgb3B0aW9ucy5tYXhEYXRlIGNvbmZpZ3VyYXRpb24uIEFsc28gY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2ZcclxuICAgICAgICAgICAgLy8vb3B0aW9ucy5lbmFibGVkRGF0ZXMgaWYgc3VjaCBleGlzdC48L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLzxwYXJhbSBuYW1lPVwiZGF0ZXNcIiBsb2NpZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZGlzYWJsZWREYXRlc19wOmRhdGVzXCI+VGFrZXMgYW4gWyBzdHJpbmcgb3IgRGF0ZSBvciBtb21lbnQgXSBvZiB2YWx1ZXMgYW5kIGFsbG93cyB0aGUgdXNlciB0byBzZWxlY3Qgb25seSBmcm9tIHRob3NlIGRheXMuPC9wYXJhbT5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMuZGlzYWJsZWREYXRlcyA/ICQuZXh0ZW5kKHt9LCBvcHRpb25zLmRpc2FibGVkRGF0ZXMpIDogb3B0aW9ucy5kaXNhYmxlZERhdGVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFkYXRlcykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kaXNhYmxlZERhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoZGF0ZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc2FibGVkRGF0ZXMoKSBleHBlY3RzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGlzYWJsZWREYXRlcyA9IGluZGV4R2l2ZW5EYXRlcyhkYXRlcyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZERhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5lbmFibGVkRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZXMpIHtcclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZW5hYmxlZERhdGVzXCI+XHJcbiAgICAgICAgICAgIC8vLzxzdW1tYXJ5PlJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgY3VycmVudGx5IHNldCBlbmFibGVkIGRhdGVzIG9uIHRoZSBjb21wb25lbnQuPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cmV0dXJucyB0eXBlPVwiYXJyYXlcIj5vcHRpb25zLmVuYWJsZWREYXRlczwvcmV0dXJucz5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzdW1tYXJ5PlNldHRpbmcgdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgb3B0aW9ucy5taW5EYXRlLCBvcHRpb25zLm1heERhdGUgY29uZmlndXJhdGlvbi4gQWxzbyBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgY29uZmlndXJhdGlvbiBvZiBvcHRpb25zLmRpc2FibGVkRGF0ZXMgaWYgc3VjaCBleGlzdC48L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLzxwYXJhbSBuYW1lPVwiZGF0ZXNcIiBsb2NpZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZW5hYmxlZERhdGVzX3A6ZGF0ZXNcIj5UYWtlcyBhbiBbIHN0cmluZyBvciBEYXRlIG9yIG1vbWVudCBdIG9mIHZhbHVlcyBhbmQgYWxsb3dzIHRoZSB1c2VyIHRvIHNlbGVjdCBvbmx5IGZyb20gdGhvc2UgZGF5cy48L3BhcmFtPlxyXG4gICAgICAgICAgICAvLy88L3NpZ25hdHVyZT5cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5lbmFibGVkRGF0ZXMgPyAkLmV4dGVuZCh7fSwgb3B0aW9ucy5lbmFibGVkRGF0ZXMpIDogb3B0aW9ucy5lbmFibGVkRGF0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWRhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVuYWJsZWREYXRlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKGRhdGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmFibGVkRGF0ZXMoKSBleHBlY3RzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZERhdGVzID0gaW5kZXhHaXZlbkRhdGVzKGRhdGVzKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5kaXNhYmxlZERhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBmdW5jdGlvbiAoZGF5c09mV2Vla0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBkYXlzT2ZXZWVrRGlzYWJsZWQgPT09ICdib29sZWFuJykgJiYgIWRheXNPZldlZWtEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCEoZGF5c09mV2Vla0Rpc2FibGVkIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXlzT2ZXZWVrRGlzYWJsZWQoKSBleHBlY3RzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkID0gZGF5c09mV2Vla0Rpc2FibGVkLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBwYXJzZUludChjdXJyZW50VmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiA2IHx8IGN1cnJlbnRWYWx1ZSA8IDAgfHwgaXNOYU4oY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUuaW5kZXhPZihjdXJyZW50VmFsdWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUucHVzaChjdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgICAgIH0sIFtdKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUN1cnJlbnQgJiYgIW9wdGlvbnMua2VlcEludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmllcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzVmFsaWQoZGF0ZSwgJ2QnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuYWRkKDEsICdkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWVzID09PSAzMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVHJpZWQgMzEgdGltZXMgdG8gZmluZCBhIHZhbGlkIGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLm1heERhdGUgPSBmdW5jdGlvbiAobWF4RGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWF4RGF0ZSA/IG9wdGlvbnMubWF4RGF0ZS5jbG9uZSgpIDogb3B0aW9ucy5tYXhEYXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBtYXhEYXRlID09PSAnYm9vbGVhbicpICYmIG1heERhdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heERhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXhEYXRlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heERhdGUgPT09ICdub3cnIHx8IG1heERhdGUgPT09ICdtb21lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGF0ZSA9IGdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyc2VkRGF0ZSA9IHBhcnNlSW5wdXREYXRlKG1heERhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFwYXJzZWREYXRlLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4RGF0ZSgpIENvdWxkIG5vdCBwYXJzZSBkYXRlIHBhcmFtZXRlcjogJyArIG1heERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgJiYgcGFyc2VkRGF0ZS5pc0JlZm9yZShvcHRpb25zLm1pbkRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhEYXRlKCkgZGF0ZSBwYXJhbWV0ZXIgaXMgYmVmb3JlIG9wdGlvbnMubWluRGF0ZTogJyArIHBhcnNlZERhdGUuZm9ybWF0KGFjdHVhbEZvcm1hdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWF4RGF0ZSA9IHBhcnNlZERhdGU7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUN1cnJlbnQgJiYgIW9wdGlvbnMua2VlcEludmFsaWQgJiYgZGF0ZS5pc0FmdGVyKG1heERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShvcHRpb25zLm1heERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2aWV3RGF0ZS5pc0FmdGVyKHBhcnNlZERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RGF0ZSA9IHBhcnNlZERhdGUuY2xvbmUoKS5zdWJ0cmFjdChvcHRpb25zLnN0ZXBwaW5nLCAnbScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5taW5EYXRlID0gZnVuY3Rpb24gKG1pbkRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1pbkRhdGUgPyBvcHRpb25zLm1pbkRhdGUuY2xvbmUoKSA6IG9wdGlvbnMubWluRGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgbWluRGF0ZSA9PT0gJ2Jvb2xlYW4nKSAmJiBtaW5EYXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5taW5EYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluRGF0ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW5EYXRlID09PSAnbm93JyB8fCBtaW5EYXRlID09PSAnbW9tZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRhdGUgPSBnZXRNb21lbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnNlZERhdGUgPSBwYXJzZUlucHV0RGF0ZShtaW5EYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGFyc2VkRGF0ZS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pbkRhdGUoKSBDb3VsZCBub3QgcGFyc2UgZGF0ZSBwYXJhbWV0ZXI6ICcgKyBtaW5EYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXhEYXRlICYmIHBhcnNlZERhdGUuaXNBZnRlcihvcHRpb25zLm1heERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaW5EYXRlKCkgZGF0ZSBwYXJhbWV0ZXIgaXMgYWZ0ZXIgb3B0aW9ucy5tYXhEYXRlOiAnICsgcGFyc2VkRGF0ZS5mb3JtYXQoYWN0dWFsRm9ybWF0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5taW5EYXRlID0gcGFyc2VkRGF0ZTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlQ3VycmVudCAmJiAhb3B0aW9ucy5rZWVwSW52YWxpZCAmJiBkYXRlLmlzQmVmb3JlKG1pbkRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShvcHRpb25zLm1pbkRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2aWV3RGF0ZS5pc0JlZm9yZShwYXJzZWREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0RhdGUgPSBwYXJzZWREYXRlLmNsb25lKCkuYWRkKG9wdGlvbnMuc3RlcHBpbmcsICdtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmRlZmF1bHREYXRlID0gZnVuY3Rpb24gKGRlZmF1bHREYXRlKSB7XHJcbiAgICAgICAgICAgIC8vLzxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCIkLmZuLmRhdGV0aW1lcGlja2VyLmRlZmF1bHREYXRlXCI+XHJcbiAgICAgICAgICAgIC8vLzxzdW1tYXJ5PlJldHVybnMgYSBtb21lbnQgd2l0aCB0aGUgb3B0aW9ucy5kZWZhdWx0RGF0ZSBvcHRpb24gY29uZmlndXJhdGlvbiBvciBmYWxzZSBpZiBub3Qgc2V0PC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cmV0dXJucyB0eXBlPVwiTW9tZW50XCI+ZGF0ZS5jbG9uZSgpPC9yZXR1cm5zPlxyXG4gICAgICAgICAgICAvLy88L3NpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+V2lsbCBzZXQgdGhlIHBpY2tlcidzIGluaXRhbCBkYXRlLiBJZiBhIGJvb2xlYW46ZmFsc2UgdmFsdWUgaXMgcGFzc2VkIHRoZSBvcHRpb25zLmRlZmF1bHREYXRlIHBhcmFtZXRlciBpcyBjbGVhcmVkLjwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJkZWZhdWx0RGF0ZVwiIGxvY2lkPVwiJC5mbi5kYXRldGltZXBpY2tlci5kZWZhdWx0RGF0ZV9wOmRlZmF1bHREYXRlXCI+VGFrZXMgYSBzdHJpbmcsIERhdGUsIG1vbWVudCwgYm9vbGVhbjpmYWxzZTwvcGFyYW0+XHJcbiAgICAgICAgICAgIC8vLzwvc2lnbmF0dXJlPlxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdERhdGUgPyBvcHRpb25zLmRlZmF1bHREYXRlLmNsb25lKCkgOiBvcHRpb25zLmRlZmF1bHREYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGVmYXVsdERhdGUpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdERhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdERhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdERhdGUgPT09ICdub3cnIHx8IGRlZmF1bHREYXRlID09PSAnbW9tZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHREYXRlID0gZ2V0TW9tZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHREYXRlID0gZ2V0TW9tZW50KGRlZmF1bHREYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnNlZERhdGUgPSBwYXJzZUlucHV0RGF0ZShkZWZhdWx0RGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICghcGFyc2VkRGF0ZS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHREYXRlKCkgQ291bGQgbm90IHBhcnNlIGRhdGUgcGFyYW1ldGVyOiAnICsgZGVmYXVsdERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZChwYXJzZWREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVmYXVsdERhdGUoKSBkYXRlIHBhc3NlZCBpcyBpbnZhbGlkIGFjY29yZGluZyB0byBjb21wb25lbnQgc2V0dXAgdmFsaWRhdGlvbnMnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0RGF0ZSA9IHBhcnNlZERhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMuZGVmYXVsdERhdGUgJiYgb3B0aW9ucy5pbmxpbmUpIHx8IGlucHV0LnZhbCgpLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbHVlKG9wdGlvbnMuZGVmYXVsdERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmxvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFtb21lbnQubG9jYWxlRGF0YShsb2NhbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhbGUoKSBsb2NhbGUgJyArIGxvY2FsZSArICcgaXMgbm90IGxvYWRlZCBmcm9tIG1vbWVudCBsb2NhbGVzIScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZTtcclxuICAgICAgICAgICAgZGF0ZS5sb2NhbGUob3B0aW9ucy5sb2NhbGUpO1xyXG4gICAgICAgICAgICB2aWV3RGF0ZS5sb2NhbGUob3B0aW9ucy5sb2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFjdHVhbEZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdEZvcm1hdHRpbmcoKTsgLy8gcmVpbml0IGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICBzaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuc3RlcHBpbmcgPSBmdW5jdGlvbiAoc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnN0ZXBwaW5nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGVwcGluZyA9IHBhcnNlSW50KHN0ZXBwaW5nLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihzdGVwcGluZykgfHwgc3RlcHBpbmcgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwcGluZyA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5zdGVwcGluZyA9IHN0ZXBwaW5nO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci51c2VDdXJyZW50ID0gZnVuY3Rpb24gKHVzZUN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHVzZUN1cnJlbnRPcHRpb25zID0gWyd5ZWFyJywgJ21vbnRoJywgJ2RheScsICdob3VyJywgJ21pbnV0ZSddO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudXNlQ3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgdXNlQ3VycmVudCAhPT0gJ2Jvb2xlYW4nKSAmJiAodHlwZW9mIHVzZUN1cnJlbnQgIT09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXNlQ3VycmVudCgpIGV4cGVjdHMgYSBib29sZWFuIG9yIHN0cmluZyBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVzZUN1cnJlbnQgPT09ICdzdHJpbmcnICYmIHVzZUN1cnJlbnRPcHRpb25zLmluZGV4T2YodXNlQ3VycmVudC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZUN1cnJlbnQoKSBleHBlY3RzIGEgc3RyaW5nIHBhcmFtZXRlciBvZiAnICsgdXNlQ3VycmVudE9wdGlvbnMuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy51c2VDdXJyZW50ID0gdXNlQ3VycmVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuY29sbGFwc2UgPSBmdW5jdGlvbiAoY29sbGFwc2UpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbGxhcHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbGxhcHNlICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbGxhcHNlKCkgZXhwZWN0cyBhIGJvb2xlYW4gcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29sbGFwc2UgPT09IGNvbGxhcHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sbGFwc2UgPSBjb2xsYXBzZTtcclxuICAgICAgICAgICAgaWYgKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmljb25zID0gZnVuY3Rpb24gKGljb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIG9wdGlvbnMuaWNvbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIShpY29ucyBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ljb25zKCkgZXhwZWN0cyBwYXJhbWV0ZXIgdG8gYmUgYW4gT2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucy5pY29ucywgaWNvbnMpO1xyXG4gICAgICAgICAgICBpZiAod2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICBzaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIudG9vbHRpcHMgPSBmdW5jdGlvbiAodG9vbHRpcHMpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb3B0aW9ucy50b29sdGlwcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghKHRvb2x0aXBzIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9vbHRpcHMoKSBleHBlY3RzIHBhcmFtZXRlciB0byBiZSBhbiBPYmplY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLnRvb2x0aXBzLCB0b29sdGlwcyk7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci51c2VTdHJpY3QgPSBmdW5jdGlvbiAodXNlU3RyaWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy51c2VTdHJpY3Q7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlU3RyaWN0ICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZVN0cmljdCgpIGV4cGVjdHMgYSBib29sZWFuIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMudXNlU3RyaWN0ID0gdXNlU3RyaWN0O1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5zaWRlQnlTaWRlID0gZnVuY3Rpb24gKHNpZGVCeVNpZGUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNpZGVCeVNpZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2lkZUJ5U2lkZSAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaWRlQnlTaWRlKCkgZXhwZWN0cyBhIGJvb2xlYW4gcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5zaWRlQnlTaWRlID0gc2lkZUJ5U2lkZTtcclxuICAgICAgICAgICAgaWYgKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLnZpZXdNb2RlID0gZnVuY3Rpb24gKHZpZXdNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy52aWV3TW9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2aWV3TW9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZpZXdNb2RlKCkgZXhwZWN0cyBhIHN0cmluZyBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdNb2Rlcy5pbmRleE9mKHZpZXdNb2RlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZpZXdNb2RlKCkgcGFyYW1ldGVyIG11c3QgYmUgb25lIG9mICgnICsgdmlld01vZGVzLmpvaW4oJywgJykgKyAnKSB2YWx1ZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnZpZXdNb2RlID0gdmlld01vZGU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZSA9IE1hdGgubWF4KHZpZXdNb2Rlcy5pbmRleE9mKHZpZXdNb2RlKSwgbWluVmlld01vZGVOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgc2hvd01vZGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIudG9vbGJhclBsYWNlbWVudCA9IGZ1bmN0aW9uICh0b29sYmFyUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy50b29sYmFyUGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvb2xiYXJQbGFjZW1lbnQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b29sYmFyUGxhY2VtZW50KCkgZXhwZWN0cyBhIHN0cmluZyBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG9vbGJhclBsYWNlbWVudHMuaW5kZXhPZih0b29sYmFyUGxhY2VtZW50KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Rvb2xiYXJQbGFjZW1lbnQoKSBwYXJhbWV0ZXIgbXVzdCBiZSBvbmUgb2YgKCcgKyB0b29sYmFyUGxhY2VtZW50cy5qb2luKCcsICcpICsgJykgdmFsdWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLnRvb2xiYXJQbGFjZW1lbnQgPSB0b29sYmFyUGxhY2VtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLndpZGdldFBvc2l0aW9uaW5nID0gZnVuY3Rpb24gKHdpZGdldFBvc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIG9wdGlvbnMud2lkZ2V0UG9zaXRpb25pbmcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHt9KS50b1N0cmluZy5jYWxsKHdpZGdldFBvc2l0aW9uaW5nKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpZGdldFBvc2l0aW9uaW5nKCkgZXhwZWN0cyBhbiBvYmplY3QgdmFyaWFibGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2lkZ2V0UG9zaXRpb25pbmcuaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWRnZXRQb3NpdGlvbmluZy5ob3Jpem9udGFsICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpZGdldFBvc2l0aW9uaW5nKCkgaG9yaXpvbnRhbCB2YXJpYWJsZSBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aWRnZXRQb3NpdGlvbmluZy5ob3Jpem9udGFsID0gd2lkZ2V0UG9zaXRpb25pbmcuaG9yaXpvbnRhbC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWxNb2Rlcy5pbmRleE9mKHdpZGdldFBvc2l0aW9uaW5nLmhvcml6b250YWwpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpZGdldFBvc2l0aW9uaW5nKCkgZXhwZWN0cyBob3Jpem9udGFsIHBhcmFtZXRlciB0byBiZSBvbmUgb2YgKCcgKyBob3Jpem9udGFsTW9kZXMuam9pbignLCAnKSArICcpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLndpZGdldFBvc2l0aW9uaW5nLmhvcml6b250YWwgPSB3aWRnZXRQb3NpdGlvbmluZy5ob3Jpem9udGFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRQb3NpdGlvbmluZy52ZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWRnZXRQb3NpdGlvbmluZy52ZXJ0aWNhbCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aWRnZXRQb3NpdGlvbmluZygpIHZlcnRpY2FsIHZhcmlhYmxlIG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpZGdldFBvc2l0aW9uaW5nLnZlcnRpY2FsID0gd2lkZ2V0UG9zaXRpb25pbmcudmVydGljYWwudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbE1vZGVzLmluZGV4T2Yod2lkZ2V0UG9zaXRpb25pbmcudmVydGljYWwpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dpZGdldFBvc2l0aW9uaW5nKCkgZXhwZWN0cyB2ZXJ0aWNhbCBwYXJhbWV0ZXIgdG8gYmUgb25lIG9mICgnICsgdmVydGljYWxNb2Rlcy5qb2luKCcsICcpICsgJyknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMud2lkZ2V0UG9zaXRpb25pbmcudmVydGljYWwgPSB3aWRnZXRQb3NpdGlvbmluZy52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuY2FsZW5kYXJXZWVrcyA9IGZ1bmN0aW9uIChjYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYWxlbmRhcldlZWtzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGVuZGFyV2Vla3MgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsZW5kYXJXZWVrcygpIGV4cGVjdHMgcGFyYW1ldGVyIHRvIGJlIGEgYm9vbGVhbiB2YWx1ZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLmNhbGVuZGFyV2Vla3MgPSBjYWxlbmRhcldlZWtzO1xyXG4gICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuc2hvd1RvZGF5QnV0dG9uID0gZnVuY3Rpb24gKHNob3dUb2RheUJ1dHRvbikge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2hvd1RvZGF5QnV0dG9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNob3dUb2RheUJ1dHRvbiAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaG93VG9kYXlCdXR0b24oKSBleHBlY3RzIGEgYm9vbGVhbiBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5zaG93VG9kYXlCdXR0b24gPSBzaG93VG9kYXlCdXR0b247XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5zaG93Q2xlYXIgPSBmdW5jdGlvbiAoc2hvd0NsZWFyKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zaG93Q2xlYXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hvd0NsZWFyICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Nob3dDbGVhcigpIGV4cGVjdHMgYSBib29sZWFuIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnNob3dDbGVhciA9IHNob3dDbGVhcjtcclxuICAgICAgICAgICAgaWYgKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLndpZGdldFBhcmVudCA9IGZ1bmN0aW9uICh3aWRnZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLndpZGdldFBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWRnZXRQYXJlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB3aWRnZXRQYXJlbnQgPSAkKHdpZGdldFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRQYXJlbnQgIT09IG51bGwgJiYgKHR5cGVvZiB3aWRnZXRQYXJlbnQgIT09ICdzdHJpbmcnICYmICEod2lkZ2V0UGFyZW50IGluc3RhbmNlb2YgJCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aWRnZXRQYXJlbnQoKSBleHBlY3RzIGEgc3RyaW5nIG9yIGEgalF1ZXJ5IG9iamVjdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy53aWRnZXRQYXJlbnQgPSB3aWRnZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5rZWVwT3BlbiA9IGZ1bmN0aW9uIChrZWVwT3Blbikge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMua2VlcE9wZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VlcE9wZW4gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2VlcE9wZW4oKSBleHBlY3RzIGEgYm9vbGVhbiBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5rZWVwT3BlbiA9IGtlZXBPcGVuO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5mb2N1c09uU2hvdyA9IGZ1bmN0aW9uIChmb2N1c09uU2hvdykge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9jdXNPblNob3c7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9jdXNPblNob3cgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZm9jdXNPblNob3coKSBleHBlY3RzIGEgYm9vbGVhbiBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5mb2N1c09uU2hvdyA9IGZvY3VzT25TaG93O1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5pbmxpbmUgPSBmdW5jdGlvbiAoaW5saW5lKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5saW5lICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lubGluZSgpIGV4cGVjdHMgYSBib29sZWFuIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLmlubGluZSA9IGlubGluZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmtleUJpbmRzID0gZnVuY3Rpb24gKGtleUJpbmRzKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlCaW5kcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5rZXlCaW5kcyA9IGtleUJpbmRzO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5nZXRNb21lbnQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TW9tZW50KGQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5kZWJ1ZyA9IGZ1bmN0aW9uIChkZWJ1Zykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlYnVnICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlYnVnKCkgZXhwZWN0cyBhIGJvb2xlYW4gcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGVidWcgPSBkZWJ1ZztcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuYWxsb3dJbnB1dFRvZ2dsZSA9IGZ1bmN0aW9uIChhbGxvd0lucHV0VG9nZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5hbGxvd0lucHV0VG9nZ2xlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFsbG93SW5wdXRUb2dnbGUgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYWxsb3dJbnB1dFRvZ2dsZSgpIGV4cGVjdHMgYSBib29sZWFuIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93SW5wdXRUb2dnbGUgPSBhbGxvd0lucHV0VG9nZ2xlO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5zaG93Q2xvc2UgPSBmdW5jdGlvbiAoc2hvd0Nsb3NlKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zaG93Q2xvc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hvd0Nsb3NlICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Nob3dDbG9zZSgpIGV4cGVjdHMgYSBib29sZWFuIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnNob3dDbG9zZSA9IHNob3dDbG9zZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIua2VlcEludmFsaWQgPSBmdW5jdGlvbiAoa2VlcEludmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmtlZXBJbnZhbGlkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlZXBJbnZhbGlkICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tlZXBJbnZhbGlkKCkgZXhwZWN0cyBhIGJvb2xlYW4gcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5rZWVwSW52YWxpZCA9IGtlZXBJbnZhbGlkO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBpY2tlci5kYXRlcGlja2VySW5wdXQgPSBmdW5jdGlvbiAoZGF0ZXBpY2tlcklucHV0KSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRlcGlja2VySW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZXBpY2tlcklucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0ZXBpY2tlcklucHV0KCkgZXhwZWN0cyBhIHN0cmluZyBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRlcGlja2VySW5wdXQgPSBkYXRlcGlja2VySW5wdXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLnBhcnNlSW5wdXREYXRlID0gZnVuY3Rpb24gKHBhcnNlSW5wdXREYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5wYXJzZUlucHV0RGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZUlucHV0RGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VJbnB1dERhdGUoKSBzaG9sdWQgYmUgYXMgZnVuY3Rpb24nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucy5wYXJzZUlucHV0RGF0ZSA9IHBhcnNlSW5wdXREYXRlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwaWNrZXIuZGlzYWJsZWRUaW1lSW50ZXJ2YWxzID0gZnVuY3Rpb24gKGRpc2FibGVkVGltZUludGVydmFscykge1xyXG4gICAgICAgICAgICAvLy88c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiJC5mbi5kYXRldGltZXBpY2tlci5kaXNhYmxlZFRpbWVJbnRlcnZhbHNcIj5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+UmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50bHkgc2V0IGRpc2FibGVkIGRhdGVzIG9uIHRoZSBjb21wb25lbnQuPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy88cmV0dXJucyB0eXBlPVwiYXJyYXlcIj5vcHRpb25zLmRpc2FibGVkVGltZUludGVydmFsczwvcmV0dXJucz5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzdW1tYXJ5PlNldHRpbmcgdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgb3B0aW9ucy5taW5EYXRlLCBvcHRpb25zLm1heERhdGUgY29uZmlndXJhdGlvbi4gQWxzbyBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgY29uZmlndXJhdGlvbiBvZlxyXG4gICAgICAgICAgICAvLy9vcHRpb25zLmVuYWJsZWREYXRlcyBpZiBzdWNoIGV4aXN0Ljwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJkYXRlc1wiIGxvY2lkPVwiJC5mbi5kYXRldGltZXBpY2tlci5kaXNhYmxlZFRpbWVJbnRlcnZhbHNfcDpkYXRlc1wiPlRha2VzIGFuIFsgc3RyaW5nIG9yIERhdGUgb3IgbW9tZW50IF0gb2YgdmFsdWVzIGFuZCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IG9ubHkgZnJvbSB0aG9zZSBkYXlzLjwvcGFyYW0+XHJcbiAgICAgICAgICAgIC8vLzwvc2lnbmF0dXJlPlxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zLmRpc2FibGVkVGltZUludGVydmFscyA/ICQuZXh0ZW5kKHt9LCBvcHRpb25zLmRpc2FibGVkVGltZUludGVydmFscykgOiBvcHRpb25zLmRpc2FibGVkVGltZUludGVydmFscyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZGlzYWJsZWRUaW1lSW50ZXJ2YWxzKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVkVGltZUludGVydmFscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKGRpc2FibGVkVGltZUludGVydmFscyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlzYWJsZWRUaW1lSW50ZXJ2YWxzKCkgZXhwZWN0cyBhbiBhcnJheSBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLmRpc2FibGVkVGltZUludGVydmFscyA9IGRpc2FibGVkVGltZUludGVydmFscztcclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmRpc2FibGVkSG91cnMgPSBmdW5jdGlvbiAoaG91cnMpIHtcclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIiQuZm4uZGF0ZXRpbWVwaWNrZXIuZGlzYWJsZWRIb3Vyc1wiPlxyXG4gICAgICAgICAgICAvLy88c3VtbWFyeT5SZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnRseSBzZXQgZGlzYWJsZWQgaG91cnMgb24gdGhlIGNvbXBvbmVudC48L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLzxyZXR1cm5zIHR5cGU9XCJhcnJheVwiPm9wdGlvbnMuZGlzYWJsZWRIb3VyczwvcmV0dXJucz5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzaWduYXR1cmU+XHJcbiAgICAgICAgICAgIC8vLzxzdW1tYXJ5PlNldHRpbmcgdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgb3B0aW9ucy5taW5EYXRlLCBvcHRpb25zLm1heERhdGUgY29uZmlndXJhdGlvbi4gQWxzbyBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgY29uZmlndXJhdGlvbiBvZlxyXG4gICAgICAgICAgICAvLy9vcHRpb25zLmVuYWJsZWRIb3VycyBpZiBzdWNoIGV4aXN0Ljwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJob3Vyc1wiIGxvY2lkPVwiJC5mbi5kYXRldGltZXBpY2tlci5kaXNhYmxlZEhvdXJzX3A6aG91cnNcIj5UYWtlcyBhbiBbIGludCBdIG9mIHZhbHVlcyBhbmQgZGlzYWxsb3dzIHRoZSB1c2VyIHRvIHNlbGVjdCBvbmx5IGZyb20gdGhvc2UgaG91cnMuPC9wYXJhbT5cclxuICAgICAgICAgICAgLy8vPC9zaWduYXR1cmU+XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMuZGlzYWJsZWRIb3VycyA/ICQuZXh0ZW5kKHt9LCBvcHRpb25zLmRpc2FibGVkSG91cnMpIDogb3B0aW9ucy5kaXNhYmxlZEhvdXJzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFob3Vycykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kaXNhYmxlZEhvdXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoaG91cnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc2FibGVkSG91cnMoKSBleHBlY3RzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGlzYWJsZWRIb3VycyA9IGluZGV4R2l2ZW5Ib3Vycyhob3Vycyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZEhvdXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUN1cnJlbnQgJiYgIW9wdGlvbnMua2VlcEludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmllcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzVmFsaWQoZGF0ZSwgJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuYWRkKDEsICdoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWVzID09PSAyNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVHJpZWQgMjQgdGltZXMgdG8gZmluZCBhIHZhbGlkIGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGlja2VyLmVuYWJsZWRIb3VycyA9IGZ1bmN0aW9uIChob3Vycykge1xyXG4gICAgICAgICAgICAvLy88c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiJC5mbi5kYXRldGltZXBpY2tlci5lbmFibGVkSG91cnNcIj5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+UmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50bHkgc2V0IGVuYWJsZWQgaG91cnMgb24gdGhlIGNvbXBvbmVudC48L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLzxyZXR1cm5zIHR5cGU9XCJhcnJheVwiPm9wdGlvbnMuZW5hYmxlZEhvdXJzPC9yZXR1cm5zPlxyXG4gICAgICAgICAgICAvLy88L3NpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHNpZ25hdHVyZT5cclxuICAgICAgICAgICAgLy8vPHN1bW1hcnk+U2V0dGluZyB0aGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBvcHRpb25zLm1pbkRhdGUsIG9wdGlvbnMubWF4RGF0ZSBjb25maWd1cmF0aW9uLiBBbHNvIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiByZW1vdmVzIHRoZSBjb25maWd1cmF0aW9uIG9mIG9wdGlvbnMuZGlzYWJsZWRIb3VycyBpZiBzdWNoIGV4aXN0Ljwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJob3Vyc1wiIGxvY2lkPVwiJC5mbi5kYXRldGltZXBpY2tlci5lbmFibGVkSG91cnNfcDpob3Vyc1wiPlRha2VzIGFuIFsgaW50IF0gb2YgdmFsdWVzIGFuZCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IG9ubHkgZnJvbSB0aG9zZSBob3Vycy48L3BhcmFtPlxyXG4gICAgICAgICAgICAvLy88L3NpZ25hdHVyZT5cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5lbmFibGVkSG91cnMgPyAkLmV4dGVuZCh7fSwgb3B0aW9ucy5lbmFibGVkSG91cnMpIDogb3B0aW9ucy5lbmFibGVkSG91cnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWhvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVuYWJsZWRIb3VycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKGhvdXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmFibGVkSG91cnMoKSBleHBlY3RzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZEhvdXJzID0gaW5kZXhHaXZlbkhvdXJzKGhvdXJzKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5kaXNhYmxlZEhvdXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUN1cnJlbnQgJiYgIW9wdGlvbnMua2VlcEludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmllcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzVmFsaWQoZGF0ZSwgJ2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuYWRkKDEsICdoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWVzID09PSAyNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVHJpZWQgMjQgdGltZXMgdG8gZmluZCBhIHZhbGlkIGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwaWNrZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQncyBtb2RlbCBjdXJyZW50IHZpZXdEYXRlLCBhIG1vbWVudCBvYmplY3Qgb3IgbnVsbCBpZiBub3Qgc2V0LiBQYXNzaW5nIGEgbnVsbCB2YWx1ZSB1bnNldHMgdGhlIGNvbXBvbmVudHMgbW9kZWwgY3VycmVudCBtb21lbnQuIFBhcnNpbmcgb2YgdGhlIG5ld0RhdGUgcGFyYW1ldGVyIGlzIG1hZGUgdXNpbmcgbW9tZW50IGxpYnJhcnkgd2l0aCB0aGUgb3B0aW9ucy5mb3JtYXQgYW5kIG9wdGlvbnMudXNlU3RyaWN0IGNvbXBvbmVudHMgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge1Rha2VzIHN0cmluZywgdmlld0RhdGUsIG1vbWVudCwgbnVsbCBwYXJhbWV0ZXIufSBuZXdEYXRlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZpZXdEYXRlLmNsb25lKCl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGlja2VyLnZpZXdEYXRlID0gZnVuY3Rpb24gKG5ld0RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5ld0RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdEYXRlID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdEYXRlICE9PSAnc3RyaW5nJyAmJiAhbW9tZW50LmlzTW9tZW50KG5ld0RhdGUpICYmICEobmV3RGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aWV3RGF0ZSgpIHBhcmFtZXRlciBtdXN0IGJlIG9uZSBvZiBbc3RyaW5nLCBtb21lbnQgb3IgRGF0ZV0nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmlld0RhdGUgPSBwYXJzZUlucHV0RGF0ZShuZXdEYXRlKTtcclxuICAgICAgICAgICAgdmlld1VwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGluaXRpYWxpemluZyBlbGVtZW50IGFuZCBjb21wb25lbnQgYXR0cmlidXRlc1xyXG4gICAgICAgIGlmIChlbGVtZW50LmlzKCdpbnB1dCcpKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gZWxlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGVsZW1lbnQuZmluZChvcHRpb25zLmRhdGVwaWNrZXJJbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gZWxlbWVudC5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1MgY2xhc3MgXCInICsgb3B0aW9ucy5kYXRlcGlja2VySW5wdXQgKyAnXCIgY2Fubm90IGJlIGFwcGxpZWQgdG8gbm9uIGlucHV0IGVsZW1lbnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBtb3JlIHRoZW4gb25lICdpbnB1dC1ncm91cC1hZGRvbicgSXNzdWUgIzQ4XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmZpbmQoJy5kYXRlcGlja2VyYnV0dG9uJykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBlbGVtZW50LmZpbmQoJy5pbnB1dC1ncm91cC1hZGRvbicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZWxlbWVudC5maW5kKCcuZGF0ZXBpY2tlcmJ1dHRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5saW5lICYmICFpbnB1dC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIERhdGVUaW1lUGlja2VyIHdpdGhvdXQgYW4gaW5wdXQgZWxlbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzIGZvciBkYXRlIGhlcmUgbm93IGluc3RlYWQgb2YgaW4gdmFyIGRlY2xhcmF0aW9uXHJcbiAgICAgICAgZGF0ZSA9IGdldE1vbWVudCgpO1xyXG4gICAgICAgIHZpZXdEYXRlID0gZGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCBkYXRhVG9PcHRpb25zKCkpO1xyXG5cclxuICAgICAgICBwaWNrZXIub3B0aW9ucyhvcHRpb25zKTtcclxuXHJcbiAgICAgICAgaW5pdEZvcm1hdHRpbmcoKTtcclxuXHJcbiAgICAgICAgYXR0YWNoRGF0ZVBpY2tlckVsZW1lbnRFdmVudHMoKTtcclxuXHJcbiAgICAgICAgaWYgKGlucHV0LnByb3AoJ2Rpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgcGlja2VyLmRpc2FibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmlzKCdpbnB1dCcpICYmIGlucHV0LnZhbCgpLnRyaW0oKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgc2V0VmFsdWUocGFyc2VJbnB1dERhdGUoaW5wdXQudmFsKCkudHJpbSgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZGVmYXVsdERhdGUgJiYgaW5wdXQuYXR0cigncGxhY2Vob2xkZXInKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNldFZhbHVlKG9wdGlvbnMuZGVmYXVsdERhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGlja2VyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAqXHJcbiAgICAgKiBqUXVlcnkgcGx1Z2luIGNvbnN0cnVjdG9yIGFuZCBkZWZhdWx0cyBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNlZSAoaHR0cDovL2pxdWVyeS5jb20vKS5cclxuICAgICogQG5hbWUgalF1ZXJ5XHJcbiAgICAqIEBjbGFzc1xyXG4gICAgKiBTZWUgdGhlIGpRdWVyeSBMaWJyYXJ5ICAoaHR0cDovL2pxdWVyeS5jb20vKSBmb3IgZnVsbCBkZXRhaWxzLiAgVGhpcyBqdXN0XHJcbiAgICAqIGRvY3VtZW50cyB0aGUgZnVuY3Rpb24gYW5kIGNsYXNzZXMgdGhhdCBhcmUgYWRkZWQgdG8galF1ZXJ5IGJ5IHRoaXMgcGx1Zy1pbi5cclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFNlZSAoaHR0cDovL2pxdWVyeS5jb20vKVxyXG4gICAgICogQG5hbWUgZm5cclxuICAgICAqIEBjbGFzc1xyXG4gICAgICogU2VlIHRoZSBqUXVlcnkgTGlicmFyeSAgKGh0dHA6Ly9qcXVlcnkuY29tLykgZm9yIGZ1bGwgZGV0YWlscy4gIFRoaXMganVzdFxyXG4gICAgICogZG9jdW1lbnRzIHRoZSBmdW5jdGlvbiBhbmQgY2xhc3NlcyB0aGF0IGFyZSBhZGRlZCB0byBqUXVlcnkgYnkgdGhpcyBwbHVnLWluLlxyXG4gICAgICogQG1lbWJlck9mIGpRdWVyeVxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgY29tbWVudHNcclxuICAgICAqIEBjbGFzcyBkYXRldGltZXBpY2tlclxyXG4gICAgICogQG1lbWJlck9mIGpRdWVyeS5mblxyXG4gICAgICovXHJcbiAgICAkLmZuLmRhdGV0aW1lcGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgICBpc0luc3RhbmNlID0gdHJ1ZSxcclxuICAgICAgICAgICAgdGhpc01ldGhvZHMgPSBbJ2Rlc3Ryb3knLCAnaGlkZScsICdzaG93JywgJ3RvZ2dsZSddLFxyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgX29wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoISR0aGlzLmRhdGEoJ0RhdGVUaW1lUGlja2VyJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBwcml2YXRlIGNvcHkgb2YgdGhlIGRlZmF1bHRzIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIF9vcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sICQuZm4uZGF0ZXRpbWVwaWNrZXIuZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ0RhdGVUaW1lUGlja2VyJywgZGF0ZVRpbWVQaWNrZXIoJHRoaXMsIF9vcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gJHRoaXMuZGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcclxuICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlcihcIicgKyBvcHRpb25zICsgJ1wiKSBtZXRob2Qgd2FzIGNhbGxlZCBvbiBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHVzaW5nIERhdGVUaW1lUGlja2VyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBpbnN0YW5jZVtvcHRpb25zXS5hcHBseShpbnN0YW5jZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBpc0luc3RhbmNlID0gcmV0dXJuVmFsdWUgPT09IGluc3RhbmNlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0luc3RhbmNlIHx8ICQuaW5BcnJheShvcHRpb25zLCB0aGlzTWV0aG9kcykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBEYXRlVGltZVBpY2tlcjogJyArIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmRhdGV0aW1lcGlja2VyLmRlZmF1bHRzID0ge1xyXG4gICAgICAgIHRpbWVab25lOiAnJyxcclxuICAgICAgICBmb3JtYXQ6IGZhbHNlLFxyXG4gICAgICAgIGRheVZpZXdIZWFkZXJGb3JtYXQ6ICdNTU1NIFlZWVknLFxyXG4gICAgICAgIGV4dHJhRm9ybWF0czogZmFsc2UsXHJcbiAgICAgICAgc3RlcHBpbmc6IDEsXHJcbiAgICAgICAgbWluRGF0ZTogZmFsc2UsXHJcbiAgICAgICAgbWF4RGF0ZTogZmFsc2UsXHJcbiAgICAgICAgdXNlQ3VycmVudDogdHJ1ZSxcclxuICAgICAgICBjb2xsYXBzZTogdHJ1ZSxcclxuICAgICAgICBsb2NhbGU6IG1vbWVudC5sb2NhbGUoKSxcclxuICAgICAgICBkZWZhdWx0RGF0ZTogZmFsc2UsXHJcbiAgICAgICAgZGlzYWJsZWREYXRlczogZmFsc2UsXHJcbiAgICAgICAgZW5hYmxlZERhdGVzOiBmYWxzZSxcclxuICAgICAgICBpY29uczoge1xyXG4gICAgICAgICAgICB0aW1lOiAnZ2x5cGhpY29uIGdseXBoaWNvbi10aW1lJyxcclxuICAgICAgICAgICAgZGF0ZTogJ2dseXBoaWNvbiBnbHlwaGljb24tY2FsZW5kYXInLFxyXG4gICAgICAgICAgICB1cDogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cCcsXHJcbiAgICAgICAgICAgIGRvd246ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93bicsXHJcbiAgICAgICAgICAgIHByZXZpb3VzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnQnLFxyXG4gICAgICAgICAgICBuZXh0OiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0JyxcclxuICAgICAgICAgICAgdG9kYXk6ICdnbHlwaGljb24gZ2x5cGhpY29uLXNjcmVlbnNob3QnLFxyXG4gICAgICAgICAgICBjbGVhcjogJ2dseXBoaWNvbiBnbHlwaGljb24tdHJhc2gnLFxyXG4gICAgICAgICAgICBjbG9zZTogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9vbHRpcHM6IHtcclxuICAgICAgICAgICAgdG9kYXk6ICdHbyB0byB0b2RheScsXHJcbiAgICAgICAgICAgIGNsZWFyOiAnQ2xlYXIgc2VsZWN0aW9uJyxcclxuICAgICAgICAgICAgY2xvc2U6ICdDbG9zZSB0aGUgcGlja2VyJyxcclxuICAgICAgICAgICAgc2VsZWN0TW9udGg6ICdTZWxlY3QgTW9udGgnLFxyXG4gICAgICAgICAgICBwcmV2TW9udGg6ICdQcmV2aW91cyBNb250aCcsXHJcbiAgICAgICAgICAgIG5leHRNb250aDogJ05leHQgTW9udGgnLFxyXG4gICAgICAgICAgICBzZWxlY3RZZWFyOiAnU2VsZWN0IFllYXInLFxyXG4gICAgICAgICAgICBwcmV2WWVhcjogJ1ByZXZpb3VzIFllYXInLFxyXG4gICAgICAgICAgICBuZXh0WWVhcjogJ05leHQgWWVhcicsXHJcbiAgICAgICAgICAgIHNlbGVjdERlY2FkZTogJ1NlbGVjdCBEZWNhZGUnLFxyXG4gICAgICAgICAgICBwcmV2RGVjYWRlOiAnUHJldmlvdXMgRGVjYWRlJyxcclxuICAgICAgICAgICAgbmV4dERlY2FkZTogJ05leHQgRGVjYWRlJyxcclxuICAgICAgICAgICAgcHJldkNlbnR1cnk6ICdQcmV2aW91cyBDZW50dXJ5JyxcclxuICAgICAgICAgICAgbmV4dENlbnR1cnk6ICdOZXh0IENlbnR1cnknLFxyXG4gICAgICAgICAgICBwaWNrSG91cjogJ1BpY2sgSG91cicsXHJcbiAgICAgICAgICAgIGluY3JlbWVudEhvdXI6ICdJbmNyZW1lbnQgSG91cicsXHJcbiAgICAgICAgICAgIGRlY3JlbWVudEhvdXI6ICdEZWNyZW1lbnQgSG91cicsXHJcbiAgICAgICAgICAgIHBpY2tNaW51dGU6ICdQaWNrIE1pbnV0ZScsXHJcbiAgICAgICAgICAgIGluY3JlbWVudE1pbnV0ZTogJ0luY3JlbWVudCBNaW51dGUnLFxyXG4gICAgICAgICAgICBkZWNyZW1lbnRNaW51dGU6ICdEZWNyZW1lbnQgTWludXRlJyxcclxuICAgICAgICAgICAgcGlja1NlY29uZDogJ1BpY2sgU2Vjb25kJyxcclxuICAgICAgICAgICAgaW5jcmVtZW50U2Vjb25kOiAnSW5jcmVtZW50IFNlY29uZCcsXHJcbiAgICAgICAgICAgIGRlY3JlbWVudFNlY29uZDogJ0RlY3JlbWVudCBTZWNvbmQnLFxyXG4gICAgICAgICAgICB0b2dnbGVQZXJpb2Q6ICdUb2dnbGUgUGVyaW9kJyxcclxuICAgICAgICAgICAgc2VsZWN0VGltZTogJ1NlbGVjdCBUaW1lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXNlU3RyaWN0OiBmYWxzZSxcclxuICAgICAgICBzaWRlQnlTaWRlOiBmYWxzZSxcclxuICAgICAgICBkYXlzT2ZXZWVrRGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxyXG4gICAgICAgIHZpZXdNb2RlOiAnZGF5cycsXHJcbiAgICAgICAgdG9vbGJhclBsYWNlbWVudDogJ2RlZmF1bHQnLFxyXG4gICAgICAgIHNob3dUb2RheUJ1dHRvbjogZmFsc2UsXHJcbiAgICAgICAgc2hvd0NsZWFyOiBmYWxzZSxcclxuICAgICAgICBzaG93Q2xvc2U6IGZhbHNlLFxyXG4gICAgICAgIHdpZGdldFBvc2l0aW9uaW5nOiB7XHJcbiAgICAgICAgICAgIGhvcml6b250YWw6ICdhdXRvJyxcclxuICAgICAgICAgICAgdmVydGljYWw6ICdhdXRvJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2lkZ2V0UGFyZW50OiBudWxsLFxyXG4gICAgICAgIGlnbm9yZVJlYWRvbmx5OiBmYWxzZSxcclxuICAgICAgICBrZWVwT3BlbjogZmFsc2UsXHJcbiAgICAgICAgZm9jdXNPblNob3c6IHRydWUsXHJcbiAgICAgICAgaW5saW5lOiBmYWxzZSxcclxuICAgICAgICBrZWVwSW52YWxpZDogZmFsc2UsXHJcbiAgICAgICAgZGF0ZXBpY2tlcklucHV0OiAnLmRhdGVwaWNrZXJpbnB1dCcsXHJcbiAgICAgICAga2V5QmluZHM6IHtcclxuICAgICAgICAgICAgdXA6IGZ1bmN0aW9uICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGUoKSB8fCB0aGlzLmdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlcicpLmlzKCc6dmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5zdWJ0cmFjdCg3LCAnZCcpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5hZGQodGhpcy5zdGVwcGluZygpLCAnbScpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24gKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0ZSgpIHx8IHRoaXMuZ2V0TW9tZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyJykuaXMoJzp2aXNpYmxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoZC5jbG9uZSgpLmFkZCg3LCAnZCcpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLnN0ZXBwaW5nKCksICdtJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnY29udHJvbCB1cCc6IGZ1bmN0aW9uICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGUoKSB8fCB0aGlzLmdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlcicpLmlzKCc6dmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5zdWJ0cmFjdCgxLCAneScpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5hZGQoMSwgJ2gnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdjb250cm9sIGRvd24nOiBmdW5jdGlvbiAod2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRlKCkgfHwgdGhpcy5nZXRNb21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuZmluZCgnLmRhdGVwaWNrZXInKS5pcygnOnZpc2libGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZShkLmNsb25lKCkuYWRkKDEsICd5JykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWZ0OiBmdW5jdGlvbiAod2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRlKCkgfHwgdGhpcy5nZXRNb21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuZmluZCgnLmRhdGVwaWNrZXInKS5pcygnOnZpc2libGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZShkLmNsb25lKCkuc3VidHJhY3QoMSwgJ2QnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJpZ2h0OiBmdW5jdGlvbiAod2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRlKCkgfHwgdGhpcy5nZXRNb21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuZmluZCgnLmRhdGVwaWNrZXInKS5pcygnOnZpc2libGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZShkLmNsb25lKCkuYWRkKDEsICdkJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYWdlVXA6IGZ1bmN0aW9uICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGUoKSB8fCB0aGlzLmdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlcicpLmlzKCc6dmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5zdWJ0cmFjdCgxLCAnTScpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFnZURvd246IGZ1bmN0aW9uICh3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGUoKSB8fCB0aGlzLmdldE1vbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZGdldC5maW5kKCcuZGF0ZXBpY2tlcicpLmlzKCc6dmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKGQuY2xvbmUoKS5hZGQoMSwgJ00nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXNjYXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy90YWI6IGZ1bmN0aW9uICh3aWRnZXQpIHsgLy90aGlzIGJyZWFrIHRoZSBmbG93IG9mIHRoZSBmb3JtLiBkaXNhYmxpbmcgZm9yIG5vd1xyXG4gICAgICAgICAgICAvLyAgICB2YXIgdG9nZ2xlID0gd2lkZ2V0LmZpbmQoJy5waWNrZXItc3dpdGNoIGFbZGF0YS1hY3Rpb249XCJ0b2dnbGVQaWNrZXJcIl0nKTtcclxuICAgICAgICAgICAgLy8gICAgaWYodG9nZ2xlLmxlbmd0aCA+IDApIHRvZ2dsZS5jbGljaygpO1xyXG4gICAgICAgICAgICAvL30sXHJcbiAgICAgICAgICAgICdjb250cm9sIHNwYWNlJzogZnVuY3Rpb24gKHdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyJykuaXMoJzp2aXNpYmxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmluZCgnLmJ0bltkYXRhLWFjdGlvbj1cInRvZ2dsZVBlcmlvZFwiXScpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSh0aGlzLmdldE1vbWVudCgpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVidWc6IGZhbHNlLFxyXG4gICAgICAgIGFsbG93SW5wdXRUb2dnbGU6IGZhbHNlLFxyXG4gICAgICAgIGRpc2FibGVkVGltZUludGVydmFsczogZmFsc2UsXHJcbiAgICAgICAgZGlzYWJsZWRIb3VyczogZmFsc2UsXHJcbiAgICAgICAgZW5hYmxlZEhvdXJzOiBmYWxzZSxcclxuICAgICAgICB2aWV3RGF0ZTogZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuICQuZm4uZGF0ZXRpbWVwaWNrZXI7XHJcbn0pKTtcclxuIiwidmFyIG9iamVjdEV4dGVuZCA9IGV4dGVuZDtcblxuLypcbiAgdmFyIG9iaiA9IHthOiAzLCBiOiA1fTtcbiAgZXh0ZW5kKG9iaiwge2E6IDQsIGM6IDh9KTsgLy8ge2E6IDQsIGI6IDUsIGM6IDh9XG4gIG9iajsgLy8ge2E6IDQsIGI6IDUsIGM6IDh9XG5cbiAgdmFyIG9iaiA9IHthOiAzLCBiOiA1fTtcbiAgZXh0ZW5kKHt9LCBvYmosIHthOiA0LCBjOiA4fSk7IC8vIHthOiA0LCBiOiA1LCBjOiA4fVxuICBvYmo7IC8vIHthOiAzLCBiOiA1fVxuXG4gIHZhciBhcnIgPSBbMSwgMiwgM107XG4gIHZhciBvYmogPSB7YTogMywgYjogNX07XG4gIGV4dGVuZChvYmosIHtjOiBhcnJ9KTsgLy8ge2E6IDMsIGI6IDUsIGM6IFsxLCAyLCAzXX1cbiAgYXJyLnB1c2goNCk7XG4gIG9iajsgLy8ge2E6IDMsIGI6IDUsIGM6IFsxLCAyLCAzLCA0XX1cblxuICB2YXIgYXJyID0gWzEsIDIsIDNdO1xuICB2YXIgb2JqID0ge2E6IDMsIGI6IDV9O1xuICBleHRlbmQodHJ1ZSwgb2JqLCB7YzogYXJyfSk7IC8vIHthOiAzLCBiOiA1LCBjOiBbMSwgMiwgM119XG4gIGFyci5wdXNoKDQpO1xuICBvYmo7IC8vIHthOiAzLCBiOiA1LCBjOiBbMSwgMiwgM119XG5cbiAgZXh0ZW5kKHthOiA0LCBiOiA1fSk7IC8vIHthOiA0LCBiOiA1fVxuICBleHRlbmQoe2E6IDQsIGI6IDV9LCAzKTsge2E6IDQsIGI6IDV9XG4gIGV4dGVuZCh7YTogNCwgYjogNX0sIHRydWUpOyB7YTogNCwgYjogNX1cbiAgZXh0ZW5kKCdoZWxsbycsIHthOiA0LCBiOiA1fSk7IC8vIHRocm93c1xuICBleHRlbmQoMywge2E6IDQsIGI6IDV9KTsgLy8gdGhyb3dzXG4qL1xuXG5mdW5jdGlvbiBleHRlbmQoLyogW2RlZXBdLCBvYmoxLCBvYmoyLCBbb2Jqbl0gKi8pIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBkZWVwID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PSAnYm9vbGVhbicpIHtcbiAgICBkZWVwID0gYXJncy5zaGlmdCgpO1xuICB9XG4gIHZhciByZXN1bHQgPSBhcmdzWzBdO1xuICBpZiAoaXNVbmV4dGVuZGFibGUocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWUgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIgZXh0ZW5kZXJzID0gYXJncy5zbGljZSgxKTtcbiAgdmFyIGxlbiA9IGV4dGVuZGVycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZXh0ZW5kZXIgPSBleHRlbmRlcnNbaV07XG4gICAgZm9yICh2YXIga2V5IGluIGV4dGVuZGVyKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVuZGVyLCBrZXkpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4dGVuZGVyW2tleV07XG4gICAgICAgIGlmIChkZWVwICYmIGlzQ2xvbmVhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBiYXNlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gZXh0ZW5kKFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgJiYgIWlzVW5leHRlbmRhYmxlKHJlc3VsdFtrZXldKVxuICAgICAgICAgICAgICA/IHJlc3VsdFtrZXldXG4gICAgICAgICAgICAgIDogYmFzZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2xvbmVhYmxlKG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8IHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNVbmV4dGVuZGFibGUodmFsKSB7XG4gIHJldHVybiAhdmFsIHx8ICh0eXBlb2YgdmFsICE9ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgIT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCB7b2JqZWN0RXh0ZW5kIGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0ICRld0JLeSRqdXN0ZXh0ZW5kIGZyb20gXCJqdXN0LWV4dGVuZFwiO1xuXG5mdW5jdGlvbiAkcGFyY2VsJGludGVyb3BEZWZhdWx0KGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5fX2VzTW9kdWxlID8gYS5kZWZhdWx0IDogYTtcbn1cblxuY2xhc3MgJDQwNDBhY2ZkODU4NDMzOGQkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSB7XG4gICAgLy8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBnaXZlbiBldmVudFxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge1xuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgbmFtZXNwYWNlIGZvciB0aGlzIGV2ZW50XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSkgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykgZm9yIChsZXQgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKWNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAvLyB0cmlnZ2VyIGEgY29ycmVzcG9uZGluZyBET00gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQodGhpcy5tYWtlRXZlbnQoXCJkcm9wem9uZTpcIiArIGV2ZW50LCB7XG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1ha2VFdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgcGFyYW1zKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJRSAxMSBzdXBwb3J0XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBmb3IgZ2l2ZW4gZXZlbnQuIElmIGZuIGlzIG5vdCBwcm92aWRlZCwgYWxsIGV2ZW50XG4gICAgLy8gbGlzdGVuZXJzIGZvciB0aGF0IGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC4gSWYgbmVpdGhlciBpcyBwcm92aWRlZCwgYWxsXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvZmYoZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSBmbikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5cblxudmFyICRmZDYwMzFmODhkY2UyZTMyJGV4cG9ydHMgPSB7fTtcbiRmZDYwMzFmODhkY2UyZTMyJGV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImR6LXByZXZpZXcgZHotZmlsZS1wcmV2aWV3XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImR6LWltYWdlXFxcIj48aW1nIGRhdGEtZHotdGh1bWJuYWlsPVxcXCJcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotZGV0YWlsc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImR6LXNpemVcXFwiPjxzcGFuIGRhdGEtZHotc2l6ZT1cXFwiXFxcIj48L3NwYW4+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImR6LWZpbGVuYW1lXFxcIj48c3BhbiBkYXRhLWR6LW5hbWU9XFxcIlxcXCI+PC9zcGFuPjwvZGl2PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1wcm9ncmVzc1xcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJkei11cGxvYWRcXFwiIGRhdGEtZHotdXBsb2FkcHJvZ3Jlc3M9XFxcIlxcXCI+PC9zcGFuPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1lcnJvci1tZXNzYWdlXFxcIj48c3BhbiBkYXRhLWR6LWVycm9ybWVzc2FnZT1cXFwiXFxcIj48L3NwYW4+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1zdWNjZXNzLW1hcmtcXFwiPlxcbiAgICA8c3ZnIHdpZHRoPVxcXCI1NFxcXCIgaGVpZ2h0PVxcXCI1NFxcXCIgdmlld0JveD1cXFwiMCAwIDU0IDU0XFxcIiBmaWxsPVxcXCJ3aGl0ZVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgICA8cGF0aCBkPVxcXCJNMTAuMjA3MSAyOS43OTI5TDE0LjI5MjkgMjUuNzA3MUMxNC42ODM0IDI1LjMxNjYgMTUuMzE2NiAyNS4zMTY2IDE1LjcwNzEgMjUuNzA3MUwyMS4yOTI5IDMxLjI5MjlDMjEuNjgzNCAzMS42ODM0IDIyLjMxNjYgMzEuNjgzNCAyMi43MDcxIDMxLjI5MjlMMzguMjkyOSAxNS43MDcxQzM4LjY4MzQgMTUuMzE2NiAzOS4zMTY2IDE1LjMxNjYgMzkuNzA3MSAxNS43MDcxTDQzLjc5MjkgMTkuNzkyOUM0NC4xODM0IDIwLjE4MzQgNDQuMTgzNCAyMC44MTY2IDQzLjc5MjkgMjEuMjA3MUwyMi43MDcxIDQyLjI5MjlDMjIuMzE2NiA0Mi42ODM0IDIxLjY4MzQgNDIuNjgzNCAyMS4yOTI5IDQyLjI5MjlMMTAuMjA3MSAzMS4yMDcxQzkuODE2NTggMzAuODE2NiA5LjgxNjU4IDMwLjE4MzQgMTAuMjA3MSAyOS43OTI5WlxcXCI+PC9wYXRoPlxcbiAgICA8L3N2Zz5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotZXJyb3ItbWFya1xcXCI+XFxuICAgIDxzdmcgd2lkdGg9XFxcIjU0XFxcIiBoZWlnaHQ9XFxcIjU0XFxcIiB2aWV3Qm94PVxcXCIwIDAgNTQgNTRcXFwiIGZpbGw9XFxcIndoaXRlXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk0yNi4yOTI5IDIwLjI5MjlMMTkuMjA3MSAxMy4yMDcxQzE4LjgxNjYgMTIuODE2NiAxOC4xODM0IDEyLjgxNjYgMTcuNzkyOSAxMy4yMDcxTDEzLjIwNzEgMTcuNzkyOUMxMi44MTY2IDE4LjE4MzQgMTIuODE2NiAxOC44MTY2IDEzLjIwNzEgMTkuMjA3MUwyMC4yOTI5IDI2LjI5MjlDMjAuNjgzNCAyNi42ODM0IDIwLjY4MzQgMjcuMzE2NiAyMC4yOTI5IDI3LjcwNzFMMTMuMjA3MSAzNC43OTI5QzEyLjgxNjYgMzUuMTgzNCAxMi44MTY2IDM1LjgxNjYgMTMuMjA3MSAzNi4yMDcxTDE3Ljc5MjkgNDAuNzkyOUMxOC4xODM0IDQxLjE4MzQgMTguODE2NiA0MS4xODM0IDE5LjIwNzEgNDAuNzkyOUwyNi4yOTI5IDMzLjcwNzFDMjYuNjgzNCAzMy4zMTY2IDI3LjMxNjYgMzMuMzE2NiAyNy43MDcxIDMzLjcwNzFMMzQuNzkyOSA0MC43OTI5QzM1LjE4MzQgNDEuMTgzNCAzNS44MTY2IDQxLjE4MzQgMzYuMjA3MSA0MC43OTI5TDQwLjc5MjkgMzYuMjA3MUM0MS4xODM0IDM1LjgxNjYgNDEuMTgzNCAzNS4xODM0IDQwLjc5MjkgMzQuNzkyOUwzMy43MDcxIDI3LjcwNzFDMzMuMzE2NiAyNy4zMTY2IDMzLjMxNjYgMjYuNjgzNCAzMy43MDcxIDI2LjI5MjlMNDAuNzkyOSAxOS4yMDcxQzQxLjE4MzQgMTguODE2NiA0MS4xODM0IDE4LjE4MzQgNDAuNzkyOSAxNy43OTI5TDM2LjIwNzEgMTMuMjA3MUMzNS44MTY2IDEyLjgxNjYgMzUuMTgzNCAxMi44MTY2IDM0Ljc5MjkgMTMuMjA3MUwyNy43MDcxIDIwLjI5MjlDMjcuMzE2NiAyMC42ODM0IDI2LjY4MzQgMjAuNjgzNCAyNi4yOTI5IDIwLjI5MjlaXFxcIj48L3BhdGg+XFxuICAgIDwvc3ZnPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxubGV0ICQ0Y2EzNjcxODI3NzZmODBiJHZhciRkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvKipcbiAgICogSGFzIHRvIGJlIHNwZWNpZmllZCBvbiBlbGVtZW50cyBvdGhlciB0aGFuIGZvcm0gKG9yIHdoZW4gdGhlIGZvcm0gZG9lc24ndFxuICAgKiBoYXZlIGFuIGBhY3Rpb25gIGF0dHJpYnV0ZSkuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBmaWxlc2AgYW5kXG4gICAqIGBkYXRhQmxvY2tzYCAgYW5kIG11c3QgcmV0dXJuIHRoZSB1cmwgYXMgc3RyaW5nLlxuICAgKi8gdXJsOiBudWxsLFxuICAgIC8qKlxuICAgKiBDYW4gYmUgY2hhbmdlZCB0byBgXCJwdXRcImAgaWYgbmVjZXNzYXJ5LiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGZ1bmN0aW9uXG4gICAqIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgZmlsZXNgIGFuZCBtdXN0IHJldHVybiB0aGUgbWV0aG9kIChzaW5jZSBgdjMuMTIuMGApLlxuICAgKi8gbWV0aG9kOiBcInBvc3RcIixcbiAgICAvKipcbiAgICogV2lsbCBiZSBzZXQgb24gdGhlIFhIUmVxdWVzdC5cbiAgICovIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgLyoqXG4gICAqIFRoZSB0aW1lb3V0IGZvciB0aGUgWEhSIHJlcXVlc3RzIGluIG1pbGxpc2Vjb25kcyAoc2luY2UgYHY0LjQuMGApLlxuICAgKiBJZiBzZXQgdG8gbnVsbCBvciAwLCBubyB0aW1lb3V0IGlzIGdvaW5nIHRvIGJlIHNldC5cbiAgICovIHRpbWVvdXQ6IG51bGwsXG4gICAgLyoqXG4gICAqIEhvdyBtYW55IGZpbGUgdXBsb2FkcyB0byBwcm9jZXNzIGluIHBhcmFsbGVsIChTZWUgdGhlXG4gICAqIEVucXVldWluZyBmaWxlIHVwbG9hZHMgZG9jdW1lbnRhdGlvbiBzZWN0aW9uIGZvciBtb3JlIGluZm8pXG4gICAqLyBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2VuZCBtdWx0aXBsZSBmaWxlcyBpbiBvbmUgcmVxdWVzdC4gSWZcbiAgICogdGhpcyBpdCBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgZmFsbGJhY2sgZmlsZSBpbnB1dCBlbGVtZW50IHdpbGxcbiAgICogaGF2ZSB0aGUgYG11bHRpcGxlYCBhdHRyaWJ1dGUgYXMgd2VsbC4gVGhpcyBvcHRpb24gd2lsbFxuICAgKiBhbHNvIHRyaWdnZXIgYWRkaXRpb25hbCBldmVudHMgKGxpa2UgYHByb2Nlc3NpbmdtdWx0aXBsZWApLiBTZWUgdGhlIGV2ZW50c1xuICAgKiBkb2N1bWVudGF0aW9uIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqLyB1cGxvYWRNdWx0aXBsZTogZmFsc2UsXG4gICAgLyoqXG4gICAqIFdoZXRoZXIgeW91IHdhbnQgZmlsZXMgdG8gYmUgdXBsb2FkZWQgaW4gY2h1bmtzIHRvIHlvdXIgc2VydmVyLiBUaGlzIGNhbid0IGJlXG4gICAqIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgdXBsb2FkTXVsdGlwbGVgLlxuICAgKlxuICAgKiBTZWUgW2NodW5rc1VwbG9hZGVkXSgjY29uZmlnLWNodW5rc1VwbG9hZGVkKSBmb3IgdGhlIGNhbGxiYWNrIHRvIGZpbmFsaXNlIGFuIHVwbG9hZC5cbiAgICovIGNodW5raW5nOiBmYWxzZSxcbiAgICAvKipcbiAgICogSWYgYGNodW5raW5nYCBpcyBlbmFibGVkLCB0aGlzIGRlZmluZXMgd2hldGhlciAqKmV2ZXJ5KiogZmlsZSBzaG91bGQgYmUgY2h1bmtlZCxcbiAgICogZXZlbiBpZiB0aGUgZmlsZSBzaXplIGlzIGJlbG93IGNodW5rU2l6ZS4gVGhpcyBtZWFucywgdGhhdCB0aGUgYWRkaXRpb25hbCBjaHVua1xuICAgKiBmb3JtIGRhdGEgd2lsbCBiZSBzdWJtaXR0ZWQgYW5kIHRoZSBgY2h1bmtzVXBsb2FkZWRgIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZC5cbiAgICovIGZvcmNlQ2h1bmtpbmc6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBJZiBgY2h1bmtpbmdgIGlzIGB0cnVlYCwgdGhlbiB0aGlzIGRlZmluZXMgdGhlIGNodW5rIHNpemUgaW4gYnl0ZXMuXG4gICAqLyBjaHVua1NpemU6IDIwOTcxNTIsXG4gICAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGluZGl2aWR1YWwgY2h1bmtzIG9mIGEgZmlsZSBhcmUgYmVpbmcgdXBsb2FkZWQgc2ltdWx0YW5lb3VzbHkuXG4gICAqLyBwYXJhbGxlbENodW5rVXBsb2FkczogZmFsc2UsXG4gICAgLyoqXG4gICAqIFdoZXRoZXIgYSBjaHVuayBzaG91bGQgYmUgcmV0cmllZCBpZiBpdCBmYWlscy5cbiAgICovIHJldHJ5Q2h1bmtzOiBmYWxzZSxcbiAgICAvKipcbiAgICogSWYgYHJldHJ5Q2h1bmtzYCBpcyB0cnVlLCBob3cgbWFueSB0aW1lcyBzaG91bGQgaXQgYmUgcmV0cmllZC5cbiAgICovIHJldHJ5Q2h1bmtzTGltaXQ6IDMsXG4gICAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGZpbGVzaXplIChpbiBNaUIpIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB1cGxvYWRlZC5cbiAgICovIG1heEZpbGVzaXplOiAyNTYsXG4gICAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHBhcmFtIHRoYXQgZ2V0cyB0cmFuc2ZlcnJlZC5cbiAgICogKipOT1RFKio6IElmIHlvdSBoYXZlIHRoZSBvcHRpb24gIGB1cGxvYWRNdWx0aXBsZWAgc2V0IHRvIGB0cnVlYCwgdGhlblxuICAgKiBEcm9wem9uZSB3aWxsIGFwcGVuZCBgW11gIHRvIHRoZSBuYW1lLlxuICAgKi8gcGFyYW1OYW1lOiBcImZpbGVcIixcbiAgICAvKipcbiAgICogV2hldGhlciB0aHVtYm5haWxzIGZvciBpbWFnZXMgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgKi8gY3JlYXRlSW1hZ2VUaHVtYm5haWxzOiB0cnVlLFxuICAgIC8qKlxuICAgKiBJbiBNQi4gV2hlbiB0aGUgZmlsZW5hbWUgZXhjZWVkcyB0aGlzIGxpbWl0LCB0aGUgdGh1bWJuYWlsIHdpbGwgbm90IGJlIGdlbmVyYXRlZC5cbiAgICovIG1heFRodW1ibmFpbEZpbGVzaXplOiAxMCxcbiAgICAvKipcbiAgICogSWYgYG51bGxgLCB0aGUgcmF0aW8gb2YgdGhlIGltYWdlIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgaXQuXG4gICAqLyB0aHVtYm5haWxXaWR0aDogMTIwLFxuICAgIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBgdGh1bWJuYWlsV2lkdGhgLiBJZiBib3RoIGFyZSBudWxsLCBpbWFnZXMgd2lsbCBub3QgYmUgcmVzaXplZC5cbiAgICovIHRodW1ibmFpbEhlaWdodDogMTIwLFxuICAgIC8qKlxuICAgKiBIb3cgdGhlIGltYWdlcyBzaG91bGQgYmUgc2NhbGVkIGRvd24gaW4gY2FzZSBib3RoLCBgdGh1bWJuYWlsV2lkdGhgIGFuZCBgdGh1bWJuYWlsSGVpZ2h0YCBhcmUgcHJvdmlkZWQuXG4gICAqIENhbiBiZSBlaXRoZXIgYGNvbnRhaW5gIG9yIGBjcm9wYC5cbiAgICovIHRodW1ibmFpbE1ldGhvZDogXCJjcm9wXCIsXG4gICAgLyoqXG4gICAqIElmIHNldCwgaW1hZ2VzIHdpbGwgYmUgcmVzaXplZCB0byB0aGVzZSBkaW1lbnNpb25zIGJlZm9yZSBiZWluZyAqKnVwbG9hZGVkKiouXG4gICAqIElmIG9ubHkgb25lLCBgcmVzaXplV2lkdGhgICoqb3IqKiBgcmVzaXplSGVpZ2h0YCBpcyBwcm92aWRlZCwgdGhlIG9yaWdpbmFsIGFzcGVjdFxuICAgKiByYXRpbyBvZiB0aGUgZmlsZSB3aWxsIGJlIHByZXNlcnZlZC5cbiAgICpcbiAgICogVGhlIGBvcHRpb25zLnRyYW5zZm9ybUZpbGVgIGZ1bmN0aW9uIHVzZXMgdGhlc2Ugb3B0aW9ucywgc28gaWYgdGhlIGB0cmFuc2Zvcm1GaWxlYCBmdW5jdGlvblxuICAgKiBpcyBvdmVycmlkZGVuLCB0aGVzZSBvcHRpb25zIGRvbid0IGRvIGFueXRoaW5nLlxuICAgKi8gcmVzaXplV2lkdGg6IG51bGwsXG4gICAgLyoqXG4gICAqIFNlZSBgcmVzaXplV2lkdGhgLlxuICAgKi8gcmVzaXplSGVpZ2h0OiBudWxsLFxuICAgIC8qKlxuICAgKiBUaGUgbWltZSB0eXBlIG9mIHRoZSByZXNpemVkIGltYWdlIChiZWZvcmUgaXQgZ2V0cyB1cGxvYWRlZCB0byB0aGUgc2VydmVyKS5cbiAgICogSWYgYG51bGxgIHRoZSBvcmlnaW5hbCBtaW1lIHR5cGUgd2lsbCBiZSB1c2VkLiBUbyBmb3JjZSBqcGVnLCBmb3IgZXhhbXBsZSwgdXNlIGBpbWFnZS9qcGVnYC5cbiAgICogU2VlIGByZXNpemVXaWR0aGAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqLyByZXNpemVNaW1lVHlwZTogbnVsbCxcbiAgICAvKipcbiAgICogVGhlIHF1YWxpdHkgb2YgdGhlIHJlc2l6ZWQgaW1hZ2VzLiBTZWUgYHJlc2l6ZVdpZHRoYC5cbiAgICovIHJlc2l6ZVF1YWxpdHk6IDAuOCxcbiAgICAvKipcbiAgICogSG93IHRoZSBpbWFnZXMgc2hvdWxkIGJlIHNjYWxlZCBkb3duIGluIGNhc2UgYm90aCwgYHJlc2l6ZVdpZHRoYCBhbmQgYHJlc2l6ZUhlaWdodGAgYXJlIHByb3ZpZGVkLlxuICAgKiBDYW4gYmUgZWl0aGVyIGBjb250YWluYCBvciBgY3JvcGAuXG4gICAqLyByZXNpemVNZXRob2Q6IFwiY29udGFpblwiLFxuICAgIC8qKlxuICAgKiBUaGUgYmFzZSB0aGF0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSAqKmRpc3BsYXllZCoqIGZpbGVzaXplLiBZb3UgY2FuXG4gICAqIGNoYW5nZSB0aGlzIHRvIDEwMjQgaWYgeW91IHdvdWxkIHJhdGhlciBkaXNwbGF5IGtpYmlieXRlcywgbWViaWJ5dGVzLFxuICAgKiBldGMuLi4gMTAyNCBpcyB0ZWNobmljYWxseSBpbmNvcnJlY3QsIGJlY2F1c2UgYDEwMjQgYnl0ZXNgIGFyZSBgMSBraWJpYnl0ZWBcbiAgICogbm90IGAxIGtpbG9ieXRlYC4gWW91IGNhbiBjaGFuZ2UgdGhpcyB0byBgMTAyNGAgaWYgeW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICogdmFsaWRpdHkuXG4gICAqLyBmaWxlc2l6ZUJhc2U6IDEwMDAsXG4gICAgLyoqXG4gICAqIElmIG5vdCBgbnVsbGAgZGVmaW5lcyBob3cgbWFueSBmaWxlcyB0aGlzIERyb3B6b25lIGhhbmRsZXMuIElmIGl0IGV4Y2VlZHMsXG4gICAqIHRoZSBldmVudCBgbWF4ZmlsZXNleGNlZWRlZGAgd2lsbCBiZSBjYWxsZWQuIFRoZSBkcm9wem9uZSBlbGVtZW50IGdldHMgdGhlXG4gICAqIGNsYXNzIGBkei1tYXgtZmlsZXMtcmVhY2hlZGAgYWNjb3JkaW5nbHkgc28geW91IGNhbiBwcm92aWRlIHZpc3VhbFxuICAgKiBmZWVkYmFjay5cbiAgICovIG1heEZpbGVzOiBudWxsLFxuICAgIC8qKlxuICAgKiBBbiBvcHRpb25hbCBvYmplY3QgdG8gc2VuZCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gdGhlIHNlcnZlci4gRWc6XG4gICAqIGB7IFwiTXktQXdlc29tZS1IZWFkZXJcIjogXCJoZWFkZXIgdmFsdWVcIiB9YFxuICAgKi8gaGVhZGVyczogbnVsbCxcbiAgICAvKipcbiAgICogU2hvdWxkIHRoZSBkZWZhdWx0IGhlYWRlcnMgYmUgc2V0IG9yIG5vdD9cbiAgICogQWNjZXB0OiBhcHBsaWNhdGlvbi9qc29uIDwtIGZvciByZXF1ZXN0aW5nIGpzb24gcmVzcG9uc2VcbiAgICogQ2FjaGUtQ29udHJvbDogbm8tY2FjaGUgPC0gUmVxdWVzdCBzaG91bGRudCBiZSBjYWNoZWRcbiAgICogWC1SZXF1ZXN0ZWQtV2l0aDogWE1MSHR0cFJlcXVlc3QgPC0gV2Ugc2VudCB0aGUgcmVxdWVzdCB2aWEgWE1MSHR0cFJlcXVlc3RcbiAgICovIGRlZmF1bHRIZWFkZXJzOiB0cnVlLFxuICAgIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBkcm9wem9uZSBlbGVtZW50IGl0c2VsZiB3aWxsIGJlIGNsaWNrYWJsZSwgaWYgYGZhbHNlYFxuICAgKiBub3RoaW5nIHdpbGwgYmUgY2xpY2thYmxlLlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBIVE1MIGVsZW1lbnQsIGEgQ1NTIHNlbGVjdG9yIChmb3IgbXVsdGlwbGUgZWxlbWVudHMpXG4gICAqIG9yIGFuIGFycmF5IG9mIHRob3NlLiBJbiB0aGF0IGNhc2UsIGFsbCBvZiB0aG9zZSBlbGVtZW50cyB3aWxsIHRyaWdnZXIgYW5cbiAgICogdXBsb2FkIHdoZW4gY2xpY2tlZC5cbiAgICovIGNsaWNrYWJsZTogdHJ1ZSxcbiAgICAvKipcbiAgICogV2hldGhlciBoaWRkZW4gZmlsZXMgaW4gZGlyZWN0b3JpZXMgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAqLyBpZ25vcmVIaWRkZW5GaWxlczogdHJ1ZSxcbiAgICAvKipcbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYGFjY2VwdGAgY2hlY2tzIHRoZSBmaWxlJ3MgbWltZSB0eXBlIG9yXG4gICAqIGV4dGVuc2lvbiBhZ2FpbnN0IHRoaXMgbGlzdC4gVGhpcyBpcyBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG1pbWVcbiAgICogdHlwZXMgb3IgZmlsZSBleHRlbnNpb25zLlxuICAgKlxuICAgKiBFZy46IGBpbWFnZS8qLGFwcGxpY2F0aW9uL3BkZiwucHNkYFxuICAgKlxuICAgKiBJZiB0aGUgRHJvcHpvbmUgaXMgYGNsaWNrYWJsZWAgdGhpcyBvcHRpb24gd2lsbCBhbHNvIGJlIHVzZWQgYXNcbiAgICogW2BhY2NlcHRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLWFjY2VwdClcbiAgICogcGFyYW1ldGVyIG9uIHRoZSBoaWRkZW4gZmlsZSBpbnB1dCBhcyB3ZWxsLlxuICAgKi8gYWNjZXB0ZWRGaWxlczogbnVsbCxcbiAgICAvKipcbiAgICogKipEZXByZWNhdGVkISoqXG4gICAqIFVzZSBhY2NlcHRlZEZpbGVzIGluc3RlYWQuXG4gICAqLyBhY2NlcHRlZE1pbWVUeXBlczogbnVsbCxcbiAgICAvKipcbiAgICogSWYgZmFsc2UsIGZpbGVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIGJ1dCB0aGUgcXVldWUgd2lsbCBub3QgYmVcbiAgICogcHJvY2Vzc2VkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgbmVlZCBzb21lIGFkZGl0aW9uYWwgdXNlciBpbnB1dCBiZWZvcmUgc2VuZGluZ1xuICAgKiBmaWxlcyAob3IgaWYgeW91IHdhbnQgd2FudCBhbGwgZmlsZXMgc2VudCBhdCBvbmNlKS5cbiAgICogSWYgeW91J3JlIHJlYWR5IHRvIHNlbmQgdGhlIGZpbGUgc2ltcGx5IGNhbGwgYG15RHJvcHpvbmUucHJvY2Vzc1F1ZXVlKClgLlxuICAgKlxuICAgKiBTZWUgdGhlIFtlbnF1ZXVpbmcgZmlsZSB1cGxvYWRzXSgjZW5xdWV1aW5nLWZpbGUtdXBsb2FkcykgZG9jdW1lbnRhdGlvblxuICAgKiBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi8gYXV0b1Byb2Nlc3NRdWV1ZTogdHJ1ZSxcbiAgICAvKipcbiAgICogSWYgZmFsc2UsIGZpbGVzIGFkZGVkIHRvIHRoZSBkcm9wem9uZSB3aWxsIG5vdCBiZSBxdWV1ZWQgYnkgZGVmYXVsdC5cbiAgICogWW91J2xsIGhhdmUgdG8gY2FsbCBgZW5xdWV1ZUZpbGUoZmlsZSlgIG1hbnVhbGx5LlxuICAgKi8gYXV0b1F1ZXVlOiB0cnVlLFxuICAgIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoaXMgd2lsbCBhZGQgYSBsaW5rIHRvIGV2ZXJ5IGZpbGUgcHJldmlldyB0byByZW1vdmUgb3IgY2FuY2VsIChpZlxuICAgKiBhbHJlYWR5IHVwbG9hZGluZykgdGhlIGZpbGUuIFRoZSBgZGljdENhbmNlbFVwbG9hZGAsIGBkaWN0Q2FuY2VsVXBsb2FkQ29uZmlybWF0aW9uYFxuICAgKiBhbmQgYGRpY3RSZW1vdmVGaWxlYCBvcHRpb25zIGFyZSB1c2VkIGZvciB0aGUgd29yZGluZy5cbiAgICovIGFkZFJlbW92ZUxpbmtzOiBmYWxzZSxcbiAgICAvKipcbiAgICogRGVmaW5lcyB3aGVyZSB0byBkaXNwbGF5IHRoZSBmaWxlIHByZXZpZXdzIOKAkyBpZiBgbnVsbGAgdGhlXG4gICAqIERyb3B6b25lIGVsZW1lbnQgaXRzZWxmIGlzIHVzZWQuIENhbiBiZSBhIHBsYWluIGBIVE1MRWxlbWVudGAgb3IgYSBDU1NcbiAgICogc2VsZWN0b3IuIFRoZSBlbGVtZW50IHNob3VsZCBoYXZlIHRoZSBgZHJvcHpvbmUtcHJldmlld3NgIGNsYXNzIHNvXG4gICAqIHRoZSBwcmV2aWV3cyBhcmUgZGlzcGxheWVkIHByb3Blcmx5LlxuICAgKi8gcHJldmlld3NDb250YWluZXI6IG51bGwsXG4gICAgLyoqXG4gICAqIFNldCB0aGlzIHRvIGB0cnVlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwcmV2aWV3cyB0byBiZSBzaG93bi5cbiAgICovIGRpc2FibGVQcmV2aWV3czogZmFsc2UsXG4gICAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhlIGhpZGRlbiBpbnB1dCBmaWVsZCAod2hpY2ggaXMgdXNlZCB3aGVuIGNsaWNraW5nIG9uIHRoZVxuICAgKiBkcm9wem9uZSB0byB0cmlnZ2VyIGZpbGUgc2VsZWN0aW9uKSB3aWxsIGJlIGFwcGVuZGVkIHRvLiBUaGlzIG1pZ2h0XG4gICAqIGJlIGltcG9ydGFudCBpbiBjYXNlIHlvdSB1c2UgZnJhbWV3b3JrcyB0byBzd2l0Y2ggdGhlIGNvbnRlbnQgb2YgeW91ciBwYWdlLlxuICAgKlxuICAgKiBDYW4gYmUgYSBzZWxlY3RvciBzdHJpbmcsIG9yIGFuIGVsZW1lbnQgZGlyZWN0bHkuXG4gICAqLyBoaWRkZW5JbnB1dENvbnRhaW5lcjogXCJib2R5XCIsXG4gICAgLyoqXG4gICAqIElmIG51bGwsIG5vIGNhcHR1cmUgdHlwZSB3aWxsIGJlIHNwZWNpZmllZFxuICAgKiBJZiBjYW1lcmEsIG1vYmlsZSBkZXZpY2VzIHdpbGwgc2tpcCB0aGUgZmlsZSBzZWxlY3Rpb24gYW5kIGNob29zZSBjYW1lcmFcbiAgICogSWYgbWljcm9waG9uZSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIHRoZSBtaWNyb3Bob25lXG4gICAqIElmIGNhbWNvcmRlciwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIHRoZSBjYW1lcmEgaW4gdmlkZW8gbW9kZVxuICAgKiBPbiBhcHBsZSBkZXZpY2VzIG11bHRpcGxlIG11c3QgYmUgc2V0IHRvIGZhbHNlLiAgQWNjZXB0ZWRGaWxlcyBtYXkgbmVlZCB0b1xuICAgKiBiZSBzZXQgdG8gYW4gYXBwcm9wcmlhdGUgbWltZSB0eXBlIChlLmcuIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiwgb3IgXCJ2aWRlby8qXCIpLlxuICAgKi8gY2FwdHVyZTogbnVsbCxcbiAgICAvKipcbiAgICogKipEZXByZWNhdGVkKiouIFVzZSBgcmVuYW1lRmlsZWAgaW5zdGVhZC5cbiAgICovIHJlbmFtZUZpbGVuYW1lOiBudWxsLFxuICAgIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBiZWZvcmUgdGhlIGZpbGUgaXMgdXBsb2FkZWQgdG8gdGhlIHNlcnZlciBhbmQgcmVuYW1lcyB0aGUgZmlsZS5cbiAgICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBgRmlsZWAgYXMgYXJndW1lbnQgYW5kIGNhbiB1c2UgdGhlIGBmaWxlLm5hbWVgLiBUaGUgYWN0dWFsIG5hbWUgb2YgdGhlXG4gICAqIGZpbGUgdGhhdCBnZXRzIHVzZWQgZHVyaW5nIHRoZSB1cGxvYWQgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggYGZpbGUudXBsb2FkLmZpbGVuYW1lYC5cbiAgICovIHJlbmFtZUZpbGU6IG51bGwsXG4gICAgLyoqXG4gICAqIElmIGB0cnVlYCB0aGUgZmFsbGJhY2sgd2lsbCBiZSBmb3JjZWQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgdG8gdGVzdCB5b3VyIHNlcnZlclxuICAgKiBpbXBsZW1lbnRhdGlvbnMgZmlyc3QgYW5kIG1ha2Ugc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgd29ya3MgYXNcbiAgICogZXhwZWN0ZWQgd2l0aG91dCBkcm9wem9uZSBpZiB5b3UgZXhwZXJpZW5jZSBwcm9ibGVtcywgYW5kIHRvIHRlc3RcbiAgICogaG93IHlvdXIgZmFsbGJhY2tzIHdpbGwgbG9vay5cbiAgICovIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBUaGUgdGV4dCB1c2VkIGJlZm9yZSBhbnkgZmlsZXMgYXJlIGRyb3BwZWQuXG4gICAqLyBkaWN0RGVmYXVsdE1lc3NhZ2U6IFwiRHJvcCBmaWxlcyBoZXJlIHRvIHVwbG9hZFwiLFxuICAgIC8qKlxuICAgKiBUaGUgdGV4dCB0aGF0IHJlcGxhY2VzIHRoZSBkZWZhdWx0IG1lc3NhZ2UgdGV4dCBpdCB0aGUgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKi8gZGljdEZhbGxiYWNrTWVzc2FnZTogXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkcmFnJ24nZHJvcCBmaWxlIHVwbG9hZHMuXCIsXG4gICAgLyoqXG4gICAqIFRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBhZGRlZCBiZWZvcmUgdGhlIGZhbGxiYWNrIGZvcm0uXG4gICAqIElmIHlvdSBwcm92aWRlIGEgIGZhbGxiYWNrIGVsZW1lbnQgeW91cnNlbGYsIG9yIGlmIHRoaXMgb3B0aW9uIGlzIGBudWxsYCB0aGlzIHdpbGxcbiAgICogYmUgaWdub3JlZC5cbiAgICovIGRpY3RGYWxsYmFja1RleHQ6IFwiUGxlYXNlIHVzZSB0aGUgZmFsbGJhY2sgZm9ybSBiZWxvdyB0byB1cGxvYWQgeW91ciBmaWxlcyBsaWtlIGluIHRoZSBvbGRlbiBkYXlzLlwiLFxuICAgIC8qKlxuICAgKiBJZiB0aGUgZmlsZXNpemUgaXMgdG9vIGJpZy5cbiAgICogYHt7ZmlsZXNpemV9fWAgYW5kIGB7e21heEZpbGVzaXplfX1gIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgcmVzcGVjdGl2ZSBjb25maWd1cmF0aW9uIHZhbHVlcy5cbiAgICovIGRpY3RGaWxlVG9vQmlnOiBcIkZpbGUgaXMgdG9vIGJpZyAoe3tmaWxlc2l6ZX19TWlCKS4gTWF4IGZpbGVzaXplOiB7e21heEZpbGVzaXplfX1NaUIuXCIsXG4gICAgLyoqXG4gICAqIElmIHRoZSBmaWxlIGRvZXNuJ3QgbWF0Y2ggdGhlIGZpbGUgdHlwZS5cbiAgICovIGRpY3RJbnZhbGlkRmlsZVR5cGU6IFwiWW91IGNhbid0IHVwbG9hZCBmaWxlcyBvZiB0aGlzIHR5cGUuXCIsXG4gICAgLyoqXG4gICAqIElmIHRoZSBzZXJ2ZXIgcmVzcG9uc2Ugd2FzIGludmFsaWQuXG4gICAqIGB7e3N0YXR1c0NvZGV9fWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzZXJ2ZXJzIHN0YXR1cyBjb2RlLlxuICAgKi8gZGljdFJlc3BvbnNlRXJyb3I6IFwiU2VydmVyIHJlc3BvbmRlZCB3aXRoIHt7c3RhdHVzQ29kZX19IGNvZGUuXCIsXG4gICAgLyoqXG4gICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCBmb3IgdGhlIGNhbmNlbCB1cGxvYWQgbGluay5cbiAgICovIGRpY3RDYW5jZWxVcGxvYWQ6IFwiQ2FuY2VsIHVwbG9hZFwiLFxuICAgIC8qKlxuICAgKiBUaGUgdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBpZiBhbiB1cGxvYWQgd2FzIG1hbnVhbGx5IGNhbmNlbGVkXG4gICAqLyBkaWN0VXBsb2FkQ2FuY2VsZWQ6IFwiVXBsb2FkIGNhbmNlbGVkLlwiLFxuICAgIC8qKlxuICAgKiBJZiBgYWRkUmVtb3ZlTGlua3NgIGlzIHRydWUsIHRoZSB0ZXh0IHRvIGJlIHVzZWQgZm9yIGNvbmZpcm1hdGlvbiB3aGVuIGNhbmNlbGxpbmcgdXBsb2FkLlxuICAgKi8gZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbjogXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2FuY2VsIHRoaXMgdXBsb2FkP1wiLFxuICAgIC8qKlxuICAgKiBJZiBgYWRkUmVtb3ZlTGlua3NgIGlzIHRydWUsIHRoZSB0ZXh0IHRvIGJlIHVzZWQgdG8gcmVtb3ZlIGEgZmlsZS5cbiAgICovIGRpY3RSZW1vdmVGaWxlOiBcIlJlbW92ZSBmaWxlXCIsXG4gICAgLyoqXG4gICAqIElmIHRoaXMgaXMgbm90IG51bGwsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCBiZWZvcmUgcmVtb3ZpbmcgYSBmaWxlLlxuICAgKi8gZGljdFJlbW92ZUZpbGVDb25maXJtYXRpb246IG51bGwsXG4gICAgLyoqXG4gICAqIERpc3BsYXllZCBpZiBgbWF4RmlsZXNgIGlzIHN0IGFuZCBleGNlZWRlZC5cbiAgICogVGhlIHN0cmluZyBge3ttYXhGaWxlc319YCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjb25maWd1cmF0aW9uIHZhbHVlLlxuICAgKi8gZGljdE1heEZpbGVzRXhjZWVkZWQ6IFwiWW91IGNhbiBub3QgdXBsb2FkIGFueSBtb3JlIGZpbGVzLlwiLFxuICAgIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIHRyYW5zbGF0ZSB0aGUgZGlmZmVyZW50IHVuaXRzLiBTdGFydGluZyB3aXRoIGB0YmAgZm9yIHRlcmFieXRlcyBhbmQgZ29pbmcgZG93biB0b1xuICAgKiBgYmAgZm9yIGJ5dGVzLlxuICAgKi8gZGljdEZpbGVTaXplVW5pdHM6IHtcbiAgICAgICAgdGI6IFwiVEJcIixcbiAgICAgICAgZ2I6IFwiR0JcIixcbiAgICAgICAgbWI6IFwiTUJcIixcbiAgICAgICAga2I6IFwiS0JcIixcbiAgICAgICAgYjogXCJiXCJcbiAgICB9LFxuICAgIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkcm9wem9uZSBpbml0aWFsaXplZFxuICAgKiBZb3UgY2FuIGFkZCBldmVudCBsaXN0ZW5lcnMgaGVyZVxuICAgKi8gaW5pdCAoKSB7XG4gICAgfSxcbiAgICAvKipcbiAgICogQ2FuIGJlIGFuICoqb2JqZWN0Kiogb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRyYW5zZmVyIHRvIHRoZSBzZXJ2ZXIsICoqb3IqKiBhIGBGdW5jdGlvbmBcbiAgICogdGhhdCBnZXRzIGludm9rZWQgd2l0aCB0aGUgYGZpbGVzYCwgYHhocmAgYW5kLCBpZiBpdCdzIGEgY2h1bmtlZCB1cGxvYWQsIGBjaHVua2AgYXJndW1lbnRzLiBJbiBjYXNlXG4gICAqIG9mIGEgZnVuY3Rpb24sIHRoaXMgbmVlZHMgdG8gcmV0dXJuIGEgbWFwLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdGhpbmcgZm9yIG5vcm1hbCB1cGxvYWRzLCBidXQgYWRkcyByZWxldmFudCBpbmZvcm1hdGlvbiBmb3JcbiAgICogY2h1bmtlZCB1cGxvYWRzLlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGFkZGluZyBoaWRkZW4gaW5wdXQgZmllbGRzIGluIHRoZSBmb3JtIGVsZW1lbnQuXG4gICAqLyBwYXJhbXMgKGZpbGVzLCB4aHIsIGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuaykgcmV0dXJuIHtcbiAgICAgICAgICAgIGR6dXVpZDogY2h1bmsuZmlsZS51cGxvYWQudXVpZCxcbiAgICAgICAgICAgIGR6Y2h1bmtpbmRleDogY2h1bmsuaW5kZXgsXG4gICAgICAgICAgICBkenRvdGFsZmlsZXNpemU6IGNodW5rLmZpbGUuc2l6ZSxcbiAgICAgICAgICAgIGR6Y2h1bmtzaXplOiB0aGlzLm9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICAgICAgZHp0b3RhbGNodW5rY291bnQ6IGNodW5rLmZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCxcbiAgICAgICAgICAgIGR6Y2h1bmtieXRlb2Zmc2V0OiBjaHVuay5pbmRleCAqIHRoaXMub3B0aW9ucy5jaHVua1NpemVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBhIFtmaWxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9GaWxlKVxuICAgKiBhbmQgYSBgZG9uZWAgZnVuY3Rpb24gYXMgcGFyYW1ldGVycy5cbiAgICpcbiAgICogSWYgdGhlIGRvbmUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgdGhlIGZpbGUgaXMgXCJhY2NlcHRlZFwiIGFuZCB3aWxsXG4gICAqIGJlIHByb2Nlc3NlZC4gSWYgeW91IHBhc3MgYW4gZXJyb3IgbWVzc2FnZSwgdGhlIGZpbGUgaXMgcmVqZWN0ZWQsIGFuZCB0aGUgZXJyb3JcbiAgICogbWVzc2FnZSB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGZpbGUgaXMgdG9vIGJpZyBvciBkb2Vzbid0IG1hdGNoIHRoZSBtaW1lIHR5cGVzLlxuICAgKi8gYWNjZXB0IChmaWxlLCBkb25lKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICogVGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYWxsIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgZm9yIGEgZmlsZS5cbiAgICogSXQgZ2V0cyB0aGUgZmlsZSBmb3Igd2hpY2ggdGhlIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlcixcbiAgICogYW5kIHRoZSBgZG9uZWAgZnVuY3Rpb24gYXMgc2Vjb25kLiBgZG9uZSgpYCBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gZXZlcnl0aGluZ1xuICAgKiBuZWVkZWQgdG8gZmluaXNoIHRoZSB1cGxvYWQgcHJvY2VzcyBpcyBkb25lLlxuICAgKi8gY2h1bmtzVXBsb2FkZWQ6IGZ1bmN0aW9uKGZpbGUsIGRvbmUpIHtcbiAgICAgICAgZG9uZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAqIFNlbmRzIHRoZSBmaWxlIGFzIGJpbmFyeSBibG9iIGluIGJvZHkgaW5zdGVhZCBvZiBmb3JtIGRhdGEuXG4gICAqIElmIHRoaXMgaXMgc2V0LCB0aGUgYHBhcmFtc2Agb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAgICogSXQncyBhbiBlcnJvciB0byBzZXQgdGhpcyB0byBgdHJ1ZWAgYWxvbmcgd2l0aCBgdXBsb2FkTXVsdGlwbGVgIHNpbmNlXG4gICAqIG11bHRpcGxlIGZpbGVzIGNhbm5vdCBiZSBpbiBhIHNpbmdsZSBiaW5hcnkgYm9keS5cbiAgICovIGJpbmFyeUJvZHk6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNob3dzIHRoZSBmYWxsYmFjayBpbnB1dCBmaWVsZCBhbmQgYWRkc1xuICAgKiBhIHRleHQuXG4gICAqLyBmYWxsYmFjayAoKSB7XG4gICAgICAgIC8vIFRoaXMgY29kZSBzaG91bGQgcGFzcyBpbiBJRTcuLi4gOihcbiAgICAgICAgbGV0IG1lc3NhZ2VFbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gYCR7dGhpcy5lbGVtZW50LmNsYXNzTmFtZX0gZHotYnJvd3Nlci1ub3Qtc3VwcG9ydGVkYDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpKWlmICgvKF58IClkei1tZXNzYWdlKCR8ICkvLnRlc3QoY2hpbGQuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLmNsYXNzTmFtZSA9IFwiZHotbWVzc2FnZVwiOyAvLyBSZW1vdmVzIHRoZSAnZHotZGVmYXVsdCcgY2xhc3NcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50ID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwiZHotbWVzc2FnZVwiPjxzcGFuPjwvc3Bhbj48L2Rpdj4nKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSBtZXNzYWdlRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIilbMF07XG4gICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICBpZiAoc3Bhbi50ZXh0Q29udGVudCAhPSBudWxsKSBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja01lc3NhZ2U7XG4gICAgICAgICAgICBlbHNlIGlmIChzcGFuLmlubmVyVGV4dCAhPSBudWxsKSBzcGFuLmlubmVyVGV4dCA9IHRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRGYWxsYmFja0Zvcm0oKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICogR2V0cyBjYWxsZWQgdG8gY2FsY3VsYXRlIHRoZSB0aHVtYm5haWwgZGltZW5zaW9ucy5cbiAgICpcbiAgICogSXQgZ2V0cyBgZmlsZWAsIGB3aWR0aGAgYW5kIGBoZWlnaHRgIChib3RoIG1heSBiZSBgbnVsbGApIGFzIHBhcmFtZXRlcnMgYW5kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nOlxuICAgKlxuICAgKiAgLSBgc3JjV2lkdGhgICYgYHNyY0hlaWdodGAgKHJlcXVpcmVkKVxuICAgKiAgLSBgdHJnV2lkdGhgICYgYHRyZ0hlaWdodGAgKHJlcXVpcmVkKVxuICAgKiAgLSBgc3JjWGAgJiBgc3JjWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcbiAgICogIC0gYHRyZ1hgICYgYHRyZ1lgIChvcHRpb25hbCwgZGVmYXVsdCBgMGApXG4gICAqXG4gICAqIFRob3NlIHZhbHVlcyBhcmUgZ29pbmcgdG8gYmUgdXNlZCBieSBgY3R4LmRyYXdJbWFnZSgpYC5cbiAgICovIHJlc2l6ZSAoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kKSB7XG4gICAgICAgIGxldCBpbmZvID0ge1xuICAgICAgICAgICAgc3JjWDogMCxcbiAgICAgICAgICAgIHNyY1k6IDAsXG4gICAgICAgICAgICBzcmNXaWR0aDogZmlsZS53aWR0aCxcbiAgICAgICAgICAgIHNyY0hlaWdodDogZmlsZS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNyY1JhdGlvID0gZmlsZS53aWR0aCAvIGZpbGUuaGVpZ2h0O1xuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBkaW1lbnNpb25zIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdpZHRoID0gaW5mby5zcmNXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGluZm8uc3JjSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoID09IG51bGwpIHdpZHRoID0gaGVpZ2h0ICogc3JjUmF0aW87XG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSBoZWlnaHQgPSB3aWR0aCAvIHNyY1JhdGlvO1xuICAgICAgICAvLyBNYWtlIHN1cmUgaW1hZ2VzIGFyZW4ndCB1cHNjYWxlZFxuICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCBpbmZvLnNyY1dpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBpbmZvLnNyY0hlaWdodCk7XG4gICAgICAgIGxldCB0cmdSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBpZiAoaW5mby5zcmNXaWR0aCA+IHdpZHRoIHx8IGluZm8uc3JjSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBJbWFnZSBpcyBiaWdnZXIgYW5kIG5lZWRzIHJlc2NhbGluZ1xuICAgICAgICAgICAgaWYgKHJlc2l6ZU1ldGhvZCA9PT0gXCJjcm9wXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNyY0hlaWdodCA9IGZpbGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNyY1dpZHRoID0gaW5mby5zcmNIZWlnaHQgKiB0cmdSYXRpbztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNyY1dpZHRoID0gZmlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5zcmNIZWlnaHQgPSBpbmZvLnNyY1dpZHRoIC8gdHJnUmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNpemVNZXRob2QgPT09IFwiY29udGFpblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWV0aG9kICdjb250YWluJ1xuICAgICAgICAgICAgICAgIGlmIChzcmNSYXRpbyA+IHRyZ1JhdGlvKSBoZWlnaHQgPSB3aWR0aCAvIHNyY1JhdGlvO1xuICAgICAgICAgICAgICAgIGVsc2Ugd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcmVzaXplTWV0aG9kICcke3Jlc2l6ZU1ldGhvZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5zcmNYID0gKGZpbGUud2lkdGggLSBpbmZvLnNyY1dpZHRoKSAvIDI7XG4gICAgICAgIGluZm8uc3JjWSA9IChmaWxlLmhlaWdodCAtIGluZm8uc3JjSGVpZ2h0KSAvIDI7XG4gICAgICAgIGluZm8udHJnV2lkdGggPSB3aWR0aDtcbiAgICAgICAgaW5mby50cmdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH0sXG4gICAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgZmlsZSAoZm9yIGV4YW1wbGUsIHJlc2l6ZSBhbiBpbWFnZSBpZiBuZWNlc3NhcnkpLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1c2VzIGByZXNpemVXaWR0aGAgYW5kIGByZXNpemVIZWlnaHRgIChpZiBwcm92aWRlZCkgYW5kIHJlc2l6ZXNcbiAgICogaW1hZ2VzIGFjY29yZGluZyB0byB0aG9zZSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBHZXRzIHRoZSBgZmlsZWAgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgYW5kIGEgYGRvbmUoKWAgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCwgdGhhdCBuZWVkc1xuICAgKiB0byBiZSBpbnZva2VkIHdpdGggdGhlIGZpbGUgd2hlbiB0aGUgdHJhbnNmb3JtYXRpb24gaXMgZG9uZS5cbiAgICovIHRyYW5zZm9ybUZpbGUgKGZpbGUsIGRvbmUpIHtcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMucmVzaXplV2lkdGggfHwgdGhpcy5vcHRpb25zLnJlc2l6ZUhlaWdodCkgJiYgZmlsZS50eXBlLm1hdGNoKC9pbWFnZS4qLykpIHJldHVybiB0aGlzLnJlc2l6ZUltYWdlKGZpbGUsIHRoaXMub3B0aW9ucy5yZXNpemVXaWR0aCwgdGhpcy5vcHRpb25zLnJlc2l6ZUhlaWdodCwgdGhpcy5vcHRpb25zLnJlc2l6ZU1ldGhvZCwgZG9uZSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIGRvbmUoZmlsZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICogQSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgdGVtcGxhdGUgdXNlZCBmb3IgZWFjaCBkcm9wcGVkXG4gICAqIGZpbGUuIENoYW5nZSBpdCB0byBmdWxmaWxsIHlvdXIgbmVlZHMgYnV0IG1ha2Ugc3VyZSB0byBwcm9wZXJseVxuICAgKiBwcm92aWRlIGFsbCBlbGVtZW50cy5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFuIGFjdHVhbCBIVE1MIGVsZW1lbnQgaW5zdGVhZCBvZiBwcm92aWRpbmcgYSBTdHJpbmdcbiAgICogYXMgYSBjb25maWcgb3B0aW9uLCB5b3UgY291bGQgY3JlYXRlIGEgZGl2IHdpdGggdGhlIGlkIGB0cGxgLFxuICAgKiBwdXQgdGhlIHRlbXBsYXRlIGluc2lkZSBpdCBhbmQgcHJvdmlkZSB0aGUgZWxlbWVudCBsaWtlIHRoaXM6XG4gICAqXG4gICAqICAgICBkb2N1bWVudFxuICAgKiAgICAgICAucXVlcnlTZWxlY3RvcignI3RwbCcpXG4gICAqICAgICAgIC5pbm5lckhUTUxcbiAgICpcbiAgICovIHByZXZpZXdUZW1wbGF0ZTogKC8qQF9fUFVSRV9fKi8kcGFyY2VsJGludGVyb3BEZWZhdWx0KCRmZDYwMzFmODhkY2UyZTMyJGV4cG9ydHMpKSxcbiAgICAvKlxuICAgVGhvc2UgZnVuY3Rpb25zIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdG8gdGhlIGV2ZW50cyBvbiBpbml0IGFuZCBoYW5kbGUgYWxsXG4gICB0aGUgdXNlciBpbnRlcmZhY2Ugc3BlY2lmaWMgc3R1ZmYuIE92ZXJ3cml0aW5nIHRoZW0gd29uJ3QgYnJlYWsgdGhlIHVwbG9hZFxuICAgYnV0IGNhbiBicmVhayB0aGUgd2F5IGl0J3MgZGlzcGxheWVkLlxuICAgWW91IGNhbiBvdmVyd3JpdGUgdGhlbSBpZiB5b3UgZG9uJ3QgbGlrZSB0aGUgZGVmYXVsdCBiZWhhdmlvci4gSWYgeW91IGp1c3RcbiAgIHdhbnQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgZXZlbnQgaGFuZGxlciwgcmVnaXN0ZXIgaXQgb24gdGhlIGRyb3B6b25lIG9iamVjdFxuICAgYW5kIGRvbid0IG92ZXJ3cml0ZSB0aG9zZSBvcHRpb25zLlxuICAgKi8gLy8gVGhvc2UgYXJlIHNlbGYgZXhwbGFuYXRvcnkgYW5kIHNpbXBseSBjb25jZXJuIHRoZSBEcmFnbkRyb3AuXG4gICAgZHJvcCAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1kcmFnLWhvdmVyXCIpO1xuICAgIH0sXG4gICAgZHJhZ3N0YXJ0IChlKSB7XG4gICAgfSxcbiAgICBkcmFnZW5kIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWRyYWctaG92ZXJcIik7XG4gICAgfSxcbiAgICBkcmFnZW50ZXIgKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotZHJhZy1ob3ZlclwiKTtcbiAgICB9LFxuICAgIGRyYWdvdmVyIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWRyYWctaG92ZXJcIik7XG4gICAgfSxcbiAgICBkcmFnbGVhdmUgKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKTtcbiAgICB9LFxuICAgIHBhc3RlIChlKSB7XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIGZpbGVzIGxlZnQgaW4gdGhlIGRyb3B6b25lIGFueW1vcmUsIGFuZCB0aGVcbiAgICAvLyBkcm9wem9uZSBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGlmIGluIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgIHJlc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotc3RhcnRlZFwiKTtcbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuIGEgZmlsZSBpcyBhZGRlZCB0byB0aGUgcXVldWVcbiAgICAvLyBSZWNlaXZlcyBgZmlsZWBcbiAgICBhZGRlZGZpbGUgKGZpbGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gdGhpcy5wcmV2aWV3c0NvbnRhaW5lcikgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1zdGFydGVkXCIpO1xuICAgICAgICBpZiAodGhpcy5wcmV2aWV3c0NvbnRhaW5lciAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVQcmV2aWV3cykge1xuICAgICAgICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudCA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMucHJldmlld1RlbXBsYXRlLnRyaW0oKSk7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdUZW1wbGF0ZSA9IGZpbGUucHJldmlld0VsZW1lbnQ7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB0aGlzLnByZXZpZXdzQ29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGUucHJldmlld0VsZW1lbnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZSBvZiBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1uYW1lXVwiKSlub2RlLnRleHRDb250ZW50ID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgZm9yIChub2RlIG9mIGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXNpemVdXCIpKW5vZGUuaW5uZXJIVE1MID0gdGhpcy5maWxlc2l6ZShmaWxlLnNpemUpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRSZW1vdmVMaW5rcykge1xuICAgICAgICAgICAgICAgIGZpbGUuX3JlbW92ZUxpbmsgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNyZWF0ZUVsZW1lbnQoYDxhIGNsYXNzPVwiZHotcmVtb3ZlXCIgaHJlZj1cImphdmFzY3JpcHQ6dW5kZWZpbmVkO1wiIGRhdGEtZHotcmVtb3ZlPiR7dGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlfTwvYT5gKTtcbiAgICAgICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmFwcGVuZENoaWxkKGZpbGUuX3JlbW92ZUxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlbW92ZUZpbGVFdmVudCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkcpIHJldHVybiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNvbmZpcm0odGhpcy5vcHRpb25zLmRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb24sICgpPT50aGlzLnJlbW92ZUZpbGUoZmlsZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlQ29uZmlybWF0aW9uKSByZXR1cm4gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jb25maXJtKHRoaXMub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbiwgKCk9PnRoaXMucmVtb3ZlRmlsZShmaWxlKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB0aGlzLnJlbW92ZUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IHJlbW92ZUxpbmsgb2YgZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotcmVtb3ZlXVwiKSlyZW1vdmVMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCByZW1vdmVGaWxlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgYSBmaWxlIGlzIHJlbW92ZWQuXG4gICAgcmVtb3ZlZGZpbGUgKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQgIT0gbnVsbCAmJiBmaWxlLnByZXZpZXdFbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkgZmlsZS5wcmV2aWV3RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZpbGUucHJldmlld0VsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKTtcbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuIGEgdGh1bWJuYWlsIGhhcyBiZWVuIGdlbmVyYXRlZFxuICAgIC8vIFJlY2VpdmVzIGBmaWxlYCBhbmQgYGRhdGFVcmxgXG4gICAgdGh1bWJuYWlsIChmaWxlLCBkYXRhVXJsKSB7XG4gICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1maWxlLXByZXZpZXdcIik7XG4gICAgICAgICAgICBmb3IgKGxldCB0aHVtYm5haWxFbGVtZW50IG9mIGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXRodW1ibmFpbF1cIikpe1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbEVsZW1lbnQuYWx0ID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbEVsZW1lbnQuc3JjID0gZGF0YVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpPT5maWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1pbWFnZS1wcmV2aWV3XCIpXG4gICAgICAgICAgICAsIDEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgYW4gZXJyb3Igb2NjdXJzXG4gICAgLy8gUmVjZWl2ZXMgYGZpbGVgIGFuZCBgbWVzc2FnZWBcbiAgICBlcnJvciAoZmlsZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xuICAgICAgICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotZXJyb3JcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIgJiYgbWVzc2FnZS5lcnJvcikgbWVzc2FnZSA9IG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LWVycm9ybWVzc2FnZV1cIikpbm9kZS50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVycm9ybXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBmaWxlIGdldHMgcHJvY2Vzc2VkLiBTaW5jZSB0aGVyZSBpcyBhIGN1ZSwgbm90IGFsbCBhZGRlZFxuICAgIC8vIGZpbGVzIGFyZSBwcm9jZXNzZWQgaW1tZWRpYXRlbHkuXG4gICAgLy8gUmVjZWl2ZXMgYGZpbGVgXG4gICAgcHJvY2Vzc2luZyAoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xuICAgICAgICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotcHJvY2Vzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSByZXR1cm4gZmlsZS5fcmVtb3ZlTGluay5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJvY2Vzc2luZ211bHRpcGxlICgpIHtcbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgdXBsb2FkIHByb2dyZXNzIGdldHMgdXBkYXRlZC5cbiAgICAvLyBSZWNlaXZlcyBgZmlsZWAsIGBwcm9ncmVzc2AgKHBlcmNlbnRhZ2UgMC0xMDApIGFuZCBgYnl0ZXNTZW50YC5cbiAgICAvLyBUbyBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBvZiB0aGUgZmlsZSwgdXNlIGBmaWxlLnNpemVgXG4gICAgdXBsb2FkcHJvZ3Jlc3MgKGZpbGUsIHByb2dyZXNzLCBieXRlc1NlbnQpIHtcbiAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIGZvciAobGV0IG5vZGUgb2YgZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotdXBsb2FkcHJvZ3Jlc3NdXCIpKW5vZGUubm9kZU5hbWUgPT09IFwiUFJPR1JFU1NcIiA/IG5vZGUudmFsdWUgPSBwcm9ncmVzcyA6IG5vZGUuc3R5bGUud2lkdGggPSBgJHtwcm9ncmVzc30lYDtcbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgdG90YWwgdXBsb2FkIHByb2dyZXNzIGdldHMgdXBkYXRlZC5cbiAgICAvLyBDYWxsZWQgd2l0aCB0b3RhbFVwbG9hZFByb2dyZXNzICgwLTEwMCksIHRvdGFsQnl0ZXMgYW5kIHRvdGFsQnl0ZXNTZW50XG4gICAgdG90YWx1cGxvYWRwcm9ncmVzcyAoKSB7XG4gICAgfSxcbiAgICAvLyBDYWxsZWQganVzdCBiZWZvcmUgdGhlIGZpbGUgaXMgc2VudC4gR2V0cyB0aGUgYHhocmAgb2JqZWN0IGFzIHNlY29uZFxuICAgIC8vIHBhcmFtZXRlciwgc28geW91IGNhbiBtb2RpZnkgaXQgKGZvciBleGFtcGxlIHRvIGFkZCBhIENTUkYgdG9rZW4pIGFuZCBhXG4gICAgLy8gYGZvcm1EYXRhYCBvYmplY3QgdG8gYWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgc2VuZGluZyAoKSB7XG4gICAgfSxcbiAgICBzZW5kaW5nbXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgLy8gV2hlbiB0aGUgY29tcGxldGUgdXBsb2FkIGlzIGZpbmlzaGVkIGFuZCBzdWNjZXNzZnVsXG4gICAgLy8gUmVjZWl2ZXMgYGZpbGVgXG4gICAgc3VjY2VzcyAoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkgcmV0dXJuIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LXN1Y2Nlc3NcIik7XG4gICAgfSxcbiAgICBzdWNjZXNzbXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgLy8gV2hlbiB0aGUgdXBsb2FkIGlzIGNhbmNlbGVkLlxuICAgIGNhbmNlbGVkIChmaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJlcnJvclwiLCBmaWxlLCB0aGlzLm9wdGlvbnMuZGljdFVwbG9hZENhbmNlbGVkKTtcbiAgICB9LFxuICAgIGNhbmNlbGVkbXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgLy8gV2hlbiB0aGUgdXBsb2FkIGlzIGZpbmlzaGVkLCBlaXRoZXIgd2l0aCBzdWNjZXNzIG9yIGFuIGVycm9yLlxuICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxuICAgIGNvbXBsZXRlIChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSBmaWxlLl9yZW1vdmVMaW5rLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZTtcbiAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1jb21wbGV0ZVwiKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlbXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgbWF4ZmlsZXNleGNlZWRlZCAoKSB7XG4gICAgfSxcbiAgICBtYXhmaWxlc3JlYWNoZWQgKCkge1xuICAgIH0sXG4gICAgcXVldWVjb21wbGV0ZSAoKSB7XG4gICAgfSxcbiAgICBhZGRlZGZpbGVzICgpIHtcbiAgICB9XG59O1xudmFyICQ0Y2EzNjcxODI3NzZmODBiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkgPSAkNGNhMzY3MTgyNzc2ZjgwYiR2YXIkZGVmYXVsdE9wdGlvbnM7XG5cblxuY2xhc3MgJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSBleHRlbmRzICQ0MDQwYWNmZDg1ODQzMzhkJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkge1xuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XG4gICAgICAgIC8vIEV4cG9zaW5nIHRoZSBlbWl0dGVyIGNsYXNzLCBtYWlubHkgZm9yIHRlc3RzXG4gICAgICAgIHRoaXMucHJvdG90eXBlLkVtaXR0ZXIgPSAkNDA0MGFjZmQ4NTg0MzM4ZCRleHBvcnQkMmUyYmNkODczOWFlMDM5O1xuICAgICAgICAvKlxuICAgICBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50cyB5b3UgY2FuIHJlZ2lzdGVyIG9uIGEgZHJvcHpvbmUgb2JqZWN0LlxuXG4gICAgIFlvdSBjYW4gcmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXM6XG5cbiAgICAgZHJvcHpvbmUub24oXCJkcmFnRW50ZXJcIiwgZnVuY3Rpb24oKSB7IH0pO1xuXG4gICAgICovIHRoaXMucHJvdG90eXBlLmV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiZHJvcFwiLFxuICAgICAgICAgICAgXCJkcmFnc3RhcnRcIixcbiAgICAgICAgICAgIFwiZHJhZ2VuZFwiLFxuICAgICAgICAgICAgXCJkcmFnZW50ZXJcIixcbiAgICAgICAgICAgIFwiZHJhZ292ZXJcIixcbiAgICAgICAgICAgIFwiZHJhZ2xlYXZlXCIsXG4gICAgICAgICAgICBcImFkZGVkZmlsZVwiLFxuICAgICAgICAgICAgXCJhZGRlZGZpbGVzXCIsXG4gICAgICAgICAgICBcInJlbW92ZWRmaWxlXCIsXG4gICAgICAgICAgICBcInRodW1ibmFpbFwiLFxuICAgICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgXCJlcnJvcm11bHRpcGxlXCIsXG4gICAgICAgICAgICBcInByb2Nlc3NpbmdcIixcbiAgICAgICAgICAgIFwicHJvY2Vzc2luZ211bHRpcGxlXCIsXG4gICAgICAgICAgICBcInVwbG9hZHByb2dyZXNzXCIsXG4gICAgICAgICAgICBcInRvdGFsdXBsb2FkcHJvZ3Jlc3NcIixcbiAgICAgICAgICAgIFwic2VuZGluZ1wiLFxuICAgICAgICAgICAgXCJzZW5kaW5nbXVsdGlwbGVcIixcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgXCJzdWNjZXNzbXVsdGlwbGVcIixcbiAgICAgICAgICAgIFwiY2FuY2VsZWRcIixcbiAgICAgICAgICAgIFwiY2FuY2VsZWRtdWx0aXBsZVwiLFxuICAgICAgICAgICAgXCJjb21wbGV0ZVwiLFxuICAgICAgICAgICAgXCJjb21wbGV0ZW11bHRpcGxlXCIsXG4gICAgICAgICAgICBcInJlc2V0XCIsXG4gICAgICAgICAgICBcIm1heGZpbGVzZXhjZWVkZWRcIixcbiAgICAgICAgICAgIFwibWF4ZmlsZXNyZWFjaGVkXCIsXG4gICAgICAgICAgICBcInF1ZXVlY29tcGxldGVcIiwgXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl90aHVtYm5haWxRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGhhdmUgYmVlbiBhY2NlcHRlZFxuICAgIGdldEFjY2VwdGVkRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcigoZmlsZSk9PmZpbGUuYWNjZXB0ZWRcbiAgICAgICAgKS5tYXAoKGZpbGUpPT5maWxlXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYWxsIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHJlamVjdGVkXG4gICAgLy8gTm90IHN1cmUgd2hlbiB0aGF0J3MgZ29pbmcgdG8gYmUgdXNlZnVsLCBidXQgYWRkZWQgZm9yIGNvbXBsZXRlbmVzcy5cbiAgICBnZXRSZWplY3RlZEZpbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoKGZpbGUpPT4hZmlsZS5hY2NlcHRlZFxuICAgICAgICApLm1hcCgoZmlsZSk9PmZpbGVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZ2V0RmlsZXNXaXRoU3RhdHVzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoKGZpbGUpPT5maWxlLnN0YXR1cyA9PT0gc3RhdHVzXG4gICAgICAgICkubWFwKChmaWxlKT0+ZmlsZVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGFyZSBpbiB0aGUgcXVldWVcbiAgICBnZXRRdWV1ZWRGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuUVVFVUVEKTtcbiAgICB9XG4gICAgZ2V0VXBsb2FkaW5nRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzV2l0aFN0YXR1cygkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORyk7XG4gICAgfVxuICAgIGdldEFkZGVkRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzV2l0aFN0YXR1cygkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFEREVEKTtcbiAgICB9XG4gICAgLy8gRmlsZXMgdGhhdCBhcmUgZWl0aGVyIHF1ZXVlZCBvciB1cGxvYWRpbmdcbiAgICBnZXRBY3RpdmVGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKChmaWxlKT0+ZmlsZS5zdGF0dXMgPT09ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HIHx8IGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlFVRVVFRFxuICAgICAgICApLm1hcCgoZmlsZSk9PmZpbGVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBEcm9wem9uZSBpcyBpbml0aWFsaXplZC4gWW91XG4gICAgLy8gY2FuIChhbmQgc2hvdWxkKSBzZXR1cCBldmVudCBsaXN0ZW5lcnMgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gICAgaW5pdCgpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBpdCBpc24ndCBzZXQgYWxyZWFkeVxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09IFwiZm9ybVwiKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZHJvcHpvbmVcIikgJiYgIXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmR6LW1lc3NhZ2VcIikpIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNyZWF0ZUVsZW1lbnQoYDxkaXYgY2xhc3M9XCJkei1kZWZhdWx0IGR6LW1lc3NhZ2VcIj48YnV0dG9uIGNsYXNzPVwiZHotYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiPiR7dGhpcy5vcHRpb25zLmRpY3REZWZhdWx0TWVzc2FnZX08L2J1dHRvbj48L2Rpdj5gKSk7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHNldHVwSGlkZGVuRmlsZUlucHV0ID0gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWRkZW5GaWxlSW5wdXQpIHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJmaWxlXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgPT09IG51bGwgfHwgdGhpcy5vcHRpb25zLm1heEZpbGVzID4gMSkgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgXCJtdWx0aXBsZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5jbGFzc05hbWUgPSBcImR6LWhpZGRlbi1pbnB1dFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyAhPT0gbnVsbCkgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwiYWNjZXB0XCIsIHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmUgIT09IG51bGwpIHRoaXMuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcImNhcHR1cmVcIiwgdGhpcy5vcHRpb25zLmNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2luZyBzdXJlIHRoYXQgbm8gb25lIGNhbiBcInRhYlwiIGludG8gdGhpcyBmaWVsZC5cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vdCBzZXR0aW5nIGBkaXNwbGF5PVwibm9uZVwiYCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjZXB0IGNsaWNrc1xuICAgICAgICAgICAgICAgIC8vIG9uIGVsZW1lbnRzIHRoYXQgYXJlbid0IGRpc3BsYXllZC5cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmdldEVsZW1lbnQodGhpcy5vcHRpb25zLmhpZGRlbklucHV0Q29udGFpbmVyLCBcImhpZGRlbklucHV0Q29udGFpbmVyXCIpLmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuRmlsZUlucHV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpPT57XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGZpbGVzOiBmaWxlcyAgfSA9IHRoaXMuaGlkZGVuRmlsZUlucHV0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXRoaXMuYWRkRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWRkZWRmaWxlc1wiLCBmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwSGlkZGVuRmlsZUlucHV0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0dXBIaWRkZW5GaWxlSW5wdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLlVSTCA9IHdpbmRvdy5VUkwgIT09IG51bGwgPyB3aW5kb3cuVVJMIDogd2luZG93LndlYmtpdFVSTDtcbiAgICAgICAgLy8gU2V0dXAgYWxsIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgRHJvcHpvbmUgb2JqZWN0IGl0c2VsZi5cbiAgICAgICAgLy8gVGhleSdyZSBub3QgaW4gQHNldHVwRXZlbnRMaXN0ZW5lcnMoKSBiZWNhdXNlIHRoZXkgc2hvdWxkbid0IGJlIHJlbW92ZWRcbiAgICAgICAgLy8gYWdhaW4gd2hlbiB0aGUgZHJvcHpvbmUgZ2V0cyBkaXNhYmxlZC5cbiAgICAgICAgZm9yIChsZXQgZXZlbnROYW1lIG9mIHRoaXMuZXZlbnRzKXRoaXMub24oZXZlbnROYW1lLCB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSk7XG4gICAgICAgIHRoaXMub24oXCJ1cGxvYWRwcm9ncmVzc1wiLCAoKT0+dGhpcy51cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5vbihcInJlbW92ZWRmaWxlXCIsICgpPT50aGlzLnVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLm9uKFwiY2FuY2VsZWRcIiwgKGZpbGUpPT50aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKVxuICAgICAgICApO1xuICAgICAgICAvLyBFbWl0IGEgYHF1ZXVlY29tcGxldGVgIGV2ZW50IGlmIGFsbCBmaWxlcyBmaW5pc2hlZCB1cGxvYWRpbmcuXG4gICAgICAgIHRoaXMub24oXCJjb21wbGV0ZVwiLCAoZmlsZSk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFkZGVkRmlsZXMoKS5sZW5ndGggPT09IDAgJiYgdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmdldFF1ZXVlZEZpbGVzKCkubGVuZ3RoID09PSAwKSAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlZmVycmVkIHNvIHRoYXQgYHF1ZXVlY29tcGxldGVgIHJlYWxseSB0cmlnZ2VycyBhZnRlciBgY29tcGxldGVgXG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKT0+dGhpcy5lbWl0KFwicXVldWVjb21wbGV0ZVwiKVxuICAgICAgICAgICAgLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zRmlsZXMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIudHlwZXMpIC8vIEJlY2F1c2UgZS5kYXRhVHJhbnNmZXIudHlwZXMgaXMgYW4gT2JqZWN0IGluXG4gICAgICAgICAgICAvLyBJRSwgd2UgbmVlZCB0byBpdGVyYXRlIGxpa2UgdGhpcyBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAvLyB1c2luZyBlLmRhdGFUcmFuc2Zlci50eXBlcy5zb21lKClcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlLmRhdGFUcmFuc2Zlci50eXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLnR5cGVzW2ldID09PSBcIkZpbGVzXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbm9Qcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBmaWxlcywgd2UgZG9uJ3Qgd2FudCB0byBzdG9wXG4gICAgICAgICAgICAvLyBwcm9wYWdhdGlvbiBzbyB3ZSBkb24ndCBpbnRlcmZlcmUgd2l0aCBvdGhlclxuICAgICAgICAgICAgLy8gZHJhZyBhbmQgZHJvcCBiZWhhdmlvdXIuXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zRmlsZXMoZSkpIHJldHVybjtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImRyYWdzdGFydFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2VudGVyOiAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KFwiZHJhZ2VudGVyXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkcmFnb3ZlcjogKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlcyBpdCBwb3NzaWJsZSB0byBkcmFnIGZpbGVzIGZyb20gY2hyb21lJ3MgZG93bmxvYWQgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NTI2NDMwL2RyYWctYW5kLWRyb3AtZmlsZS11cGxvYWRzLWZyb20tY2hyb21lLWRvd25sb2Fkcy1iYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBpcyByZXF1aXJlZCB0byBwcmV2ZW50IGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMSAoU0NSSVBUNjU1MzUgZXhjZXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVmY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmY3QgPSBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIiA9PT0gZWZjdCB8fCBcImxpbmtNb3ZlXCIgPT09IGVmY3QgPyBcIm1vdmVcIiA6IFwiY29weVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJkcmFnb3ZlclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2xlYXZlOiAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJkcmFnbGVhdmVcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRyb3A6IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3AoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRyYWdlbmQ6IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImRyYWdlbmRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKChjbGlja2FibGVFbGVtZW50KT0+e1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNsaWNrYWJsZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiAoZXZ0KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB0aGUgYWN0dWFsIGRyb3B6b25lIG9yIHRoZSBtZXNzYWdlIGVsZW1lbnQgc2hvdWxkIHRyaWdnZXIgZmlsZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlja2FibGVFbGVtZW50ICE9PSB0aGlzLmVsZW1lbnQgfHwgZXZ0LnRhcmdldCA9PT0gdGhpcy5lbGVtZW50IHx8ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZWxlbWVudEluc2lkZShldnQudGFyZ2V0LCB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5kei1tZXNzYWdlXCIpKSkgdGhpcy5oaWRkZW5GaWxlSW5wdXQuY2xpY2soKTsgLy8gRm9yd2FyZCB0aGUgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluaXQuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLy8gTm90IGZ1bGx5IHRlc3RlZCB5ZXRcbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxGaWxlcyh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuRmlsZUlucHV0ICE9IG51bGwgPyB0aGlzLmhpZGRlbkZpbGVJbnB1dC5wYXJlbnROb2RlIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGlkZGVuRmlsZUlucHV0KTtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5lbGVtZW50LmRyb3B6b25lO1xuICAgICAgICByZXR1cm4gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5pbnN0YW5jZXMuc3BsaWNlKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaW5zdGFuY2VzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH1cbiAgICB1cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzKCkge1xuICAgICAgICBsZXQgdG90YWxVcGxvYWRQcm9ncmVzcztcbiAgICAgICAgbGV0IHRvdGFsQnl0ZXNTZW50ID0gMDtcbiAgICAgICAgbGV0IHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICBsZXQgYWN0aXZlRmlsZXMgPSB0aGlzLmdldEFjdGl2ZUZpbGVzKCk7XG4gICAgICAgIGlmIChhY3RpdmVGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGUgb2YgdGhpcy5nZXRBY3RpdmVGaWxlcygpKXtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzU2VudCArPSBmaWxlLnVwbG9hZC5ieXRlc1NlbnQ7XG4gICAgICAgICAgICAgICAgdG90YWxCeXRlcyArPSBmaWxlLnVwbG9hZC50b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgPSAxMDAgKiB0b3RhbEJ5dGVzU2VudCAvIHRvdGFsQnl0ZXM7XG4gICAgICAgIH0gZWxzZSB0b3RhbFVwbG9hZFByb2dyZXNzID0gMTAwO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KFwidG90YWx1cGxvYWRwcm9ncmVzc1wiLCB0b3RhbFVwbG9hZFByb2dyZXNzLCB0b3RhbEJ5dGVzLCB0b3RhbEJ5dGVzU2VudCk7XG4gICAgfVxuICAgIC8vIEBvcHRpb25zLnBhcmFtTmFtZSBjYW4gYmUgYSBmdW5jdGlvbiB0YWtpbmcgb25lIHBhcmFtZXRlciByYXRoZXIgdGhhbiBhIHN0cmluZy5cbiAgICAvLyBBIHBhcmFtZXRlciBuYW1lIGZvciBhIGZpbGUgaXMgb2J0YWluZWQgc2ltcGx5IGJ5IGNhbGxpbmcgdGhpcyB3aXRoIGFuIGluZGV4IG51bWJlci5cbiAgICBfZ2V0UGFyYW1OYW1lKG4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1OYW1lID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0aGlzLm9wdGlvbnMucGFyYW1OYW1lKG4pO1xuICAgICAgICBlbHNlIHJldHVybiBgJHt0aGlzLm9wdGlvbnMucGFyYW1OYW1lfSR7dGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlID8gYFske259XWAgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIElmIEBvcHRpb25zLnJlbmFtZUZpbGUgaXMgYSBmdW5jdGlvbixcbiAgICAvLyB0aGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlbmFtZSB0aGUgZmlsZS5uYW1lIGJlZm9yZSBhcHBlbmRpbmcgaXQgdG8gdGhlIGZvcm1EYXRhXG4gICAgX3JlbmFtZUZpbGUoZmlsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmaWxlLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVuYW1lRmlsZShmaWxlKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGZvcm0gdGhhdCBjYW4gYmUgdXNlZCBhcyBmYWxsYmFjayBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IERyYWduRHJvcFxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGRyb3B6b25lIGlzIGFscmVhZHkgYSBmb3JtLCBvbmx5IHRoZSBpbnB1dCBmaWVsZCBhbmQgYnV0dG9uIGFyZSByZXR1cm5lZC4gT3RoZXJ3aXNlIGEgY29tcGxldGUgZm9ybSBlbGVtZW50IGlzIHByb3ZpZGVkLlxuICAgIC8vIFRoaXMgY29kZSBoYXMgdG8gcGFzcyBpbiBJRTcgOihcbiAgICBnZXRGYWxsYmFja0Zvcm0oKSB7XG4gICAgICAgIGxldCBleGlzdGluZ0ZhbGxiYWNrLCBmb3JtO1xuICAgICAgICBpZiAoZXhpc3RpbmdGYWxsYmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdGYWxsYmFjaygpKSByZXR1cm4gZXhpc3RpbmdGYWxsYmFjaztcbiAgICAgICAgbGV0IGZpZWxkc1N0cmluZyA9ICc8ZGl2IGNsYXNzPVwiZHotZmFsbGJhY2tcIj4nO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQpIGZpZWxkc1N0cmluZyArPSBgPHA+JHt0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrVGV4dH08L3A+YDtcbiAgICAgICAgZmllbGRzU3RyaW5nICs9IGA8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwiJHt0aGlzLl9nZXRQYXJhbU5hbWUoMCl9XCIgJHt0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgPyAnbXVsdGlwbGU9XCJtdWx0aXBsZVwiJyA6IHVuZGVmaW5lZH0gLz48aW5wdXQgdHlwZT1cInN1Ym1pdFwiIHZhbHVlPVwiVXBsb2FkIVwiPjwvZGl2PmA7XG4gICAgICAgIGxldCBmaWVsZHMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNyZWF0ZUVsZW1lbnQoZmllbGRzU3RyaW5nKTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lICE9PSBcIkZPUk1cIikge1xuICAgICAgICAgICAgZm9ybSA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudChgPGZvcm0gYWN0aW9uPVwiJHt0aGlzLm9wdGlvbnMudXJsfVwiIGVuY3R5cGU9XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgbWV0aG9kPVwiJHt0aGlzLm9wdGlvbnMubWV0aG9kfVwiPjwvZm9ybT5gKTtcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoZmllbGRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbmN0eXBlIGFuZCBtZXRob2QgYXR0cmlidXRlcyBhcmUgc2V0IHByb3Blcmx5XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIHRoaXMub3B0aW9ucy5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtICE9IG51bGwgPyBmb3JtIDogZmllbGRzO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBmYWxsYmFjayBlbGVtZW50cyBpZiB0aGV5IGV4aXN0IGFscmVhZHlcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBoYXMgdG8gcGFzcyBpbiBJRTcgOihcbiAgICBnZXRFeGlzdGluZ0ZhbGxiYWNrKCkge1xuICAgICAgICBsZXQgZ2V0RmFsbGJhY2sgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgZWwgb2YgZWxlbWVudHMpe1xuICAgICAgICAgICAgICAgIGlmICgvKF58IClmYWxsYmFjaygkfCApLy50ZXN0KGVsLmNsYXNzTmFtZSkpIHJldHVybiBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgdGFnTmFtZSBvZiBbXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgXCJmb3JtXCJcbiAgICAgICAgXSl7XG4gICAgICAgICAgICB2YXIgZmFsbGJhY2s7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2sgPSBnZXRGYWxsYmFjayh0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkpKSByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWN0aXZhdGVzIGFsbCBsaXN0ZW5lcnMgc3RvcmVkIGluIEBsaXN0ZW5lcnNcbiAgICBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMubWFwKChlbGVtZW50TGlzdGVuZXJzKT0+KCgpPT57XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgZXZlbnQgaW4gZWxlbWVudExpc3RlbmVycy5ldmVudHMpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSBlbGVtZW50TGlzdGVuZXJzLmV2ZW50c1tldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnRMaXN0ZW5lcnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gRGVhY3RpdmF0ZXMgYWxsIGxpc3RlbmVycyBzdG9yZWQgaW4gQGxpc3RlbmVyc1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMubWFwKChlbGVtZW50TGlzdGVuZXJzKT0+KCgpPT57XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgZXZlbnQgaW4gZWxlbWVudExpc3RlbmVycy5ldmVudHMpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSBlbGVtZW50TGlzdGVuZXJzLmV2ZW50c1tldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnRMaXN0ZW5lcnMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjYW5jZWxzIGFsbCBmaWxlcyBpbiB0aGUgcXVldWUgb3IgYmVpbmcgcHJvY2Vzc2VkLlxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWNsaWNrYWJsZVwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlcy5tYXAoKGZpbGUpPT50aGlzLmNhbmNlbFVwbG9hZChmaWxlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1jbGlja2FibGVcIilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgbmljZWx5IGZvcm1hdHRlZCBmaWxlc2l6ZVxuICAgIGZpbGVzaXplKHNpemUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkU2l6ZSA9IDA7XG4gICAgICAgIGxldCBzZWxlY3RlZFVuaXQgPSBcImJcIjtcbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgdW5pdHMgPSBbXG4gICAgICAgICAgICAgICAgXCJ0YlwiLFxuICAgICAgICAgICAgICAgIFwiZ2JcIixcbiAgICAgICAgICAgICAgICBcIm1iXCIsXG4gICAgICAgICAgICAgICAgXCJrYlwiLFxuICAgICAgICAgICAgICAgIFwiYlwiXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBsZXQgdW5pdCA9IHVuaXRzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBjdXRvZmYgPSBNYXRoLnBvdyh0aGlzLm9wdGlvbnMuZmlsZXNpemVCYXNlLCA0IC0gaSkgLyAxMDtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+PSBjdXRvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRTaXplID0gc2l6ZSAvIE1hdGgucG93KHRoaXMub3B0aW9ucy5maWxlc2l6ZUJhc2UsIDQgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRVbml0ID0gdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWRTaXplID0gTWF0aC5yb3VuZCgxMCAqIHNlbGVjdGVkU2l6ZSkgLyAxMDsgLy8gQ3V0dGluZyBvZiBkaWdpdHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxzdHJvbmc+JHtzZWxlY3RlZFNpemV9PC9zdHJvbmc+ICR7dGhpcy5vcHRpb25zLmRpY3RGaWxlU2l6ZVVuaXRzW3NlbGVjdGVkVW5pdF19YDtcbiAgICB9XG4gICAgLy8gQWRkcyBvciByZW1vdmVzIHRoZSBgZHotbWF4LWZpbGVzLXJlYWNoZWRgIGNsYXNzIGZyb20gdGhlIGZvcm0uXG4gICAgX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1heEZpbGVzICE9IG51bGwgJiYgdGhpcy5nZXRBY2NlcHRlZEZpbGVzKCkubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhGaWxlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aCA9PT0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB0aGlzLmVtaXQoXCJtYXhmaWxlc3JlYWNoZWRcIiwgdGhpcy5maWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1tYXgtZmlsZXMtcmVhY2hlZFwiKTtcbiAgICAgICAgfSBlbHNlIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LW1heC1maWxlcy1yZWFjaGVkXCIpO1xuICAgIH1cbiAgICBkcm9wKGUpIHtcbiAgICAgICAgaWYgKCFlLmRhdGFUcmFuc2ZlcikgcmV0dXJuO1xuICAgICAgICB0aGlzLmVtaXQoXCJkcm9wXCIsIGUpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBGaWxlTGlzdCB0byBhbiBBcnJheVxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgSUUxMVxuICAgICAgICBsZXQgZmlsZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aDsgaSsrKWZpbGVzW2ldID0gZS5kYXRhVHJhbnNmZXIuZmlsZXNbaV07XG4gICAgICAgIC8vIEV2ZW4gaWYgaXQncyBhIGZvbGRlciwgZmlsZXMubGVuZ3RoIHdpbGwgY29udGFpbiB0aGUgZm9sZGVycy5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaXRlbXM6IGl0ZW1zICB9ID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoICYmIGl0ZW1zWzBdLndlYmtpdEdldEFzRW50cnkgIT0gbnVsbCkgLy8gVGhlIGJyb3dzZXIgc3VwcG9ydHMgZHJvcHBpbmcgb2YgZm9sZGVycywgc28gaGFuZGxlIGl0ZW1zIGluc3RlYWQgb2YgZmlsZXNcbiAgICAgICAgICAgIHRoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5oYW5kbGVGaWxlcyhmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiYWRkZWRmaWxlc1wiLCBmaWxlcyk7XG4gICAgfVxuICAgIHBhc3RlKGUpIHtcbiAgICAgICAgaWYgKCQzZWQyNjlmMmYwZmIyMjRiJHZhciRfX2d1YXJkX18oZSAhPSBudWxsID8gZS5jbGlwYm9hcmREYXRhIDogdW5kZWZpbmVkLCAoeCk9PnguaXRlbXNcbiAgICAgICAgKSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIHRoaXMuZW1pdChcInBhc3RlXCIsIGUpO1xuICAgICAgICBsZXQgeyBpdGVtczogaXRlbXMgIH0gPSBlLmNsaXBib2FyZERhdGE7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHJldHVybiB0aGlzLl9hZGRGaWxlc0Zyb21JdGVtcyhpdGVtcyk7XG4gICAgfVxuICAgIGhhbmRsZUZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpdGhpcy5hZGRGaWxlKGZpbGUpO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgZm9sZGVyIGlzIGRyb3BwZWQgKG9yIGZpbGVzIGFyZSBwYXN0ZWQpLCBpdGVtcyBtdXN0IGJlIGhhbmRsZWRcbiAgICAvLyBpbnN0ZWFkIG9mIGZpbGVzLlxuICAgIF9hZGRGaWxlc0Zyb21JdGVtcyhpdGVtcykge1xuICAgICAgICByZXR1cm4gKCgpPT57XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ud2Via2l0R2V0QXNFbnRyeSAhPSBudWxsICYmIChlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSByZXN1bHQucHVzaCh0aGlzLmFkZEZpbGUoaXRlbS5nZXRBc0ZpbGUoKSkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkgLy8gQXBwZW5kIGFsbCBmaWxlcyBmcm9tIHRoYXQgZGlyZWN0b3J5IHRvIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgZW50cnkubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmdldEFzRmlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmtpbmQgPT0gbnVsbCB8fCBpdGVtLmtpbmQgPT09IFwiZmlsZVwiKSByZXN1bHQucHVzaCh0aGlzLmFkZEZpbGUoaXRlbS5nZXRBc0ZpbGUoKSkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvLyBHb2VzIHRocm91Z2ggdGhlIGRpcmVjdG9yeSwgYW5kIGFkZHMgZWFjaCBmaWxlIGl0IGZpbmRzIHJlY3Vyc2l2ZWx5XG4gICAgX2FkZEZpbGVzRnJvbURpcmVjdG9yeShkaXJlY3RvcnksIHBhdGgpIHtcbiAgICAgICAgbGV0IGRpclJlYWRlciA9IGRpcmVjdG9yeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IChlcnJvcik9PiQzZWQyNjlmMmYwZmIyMjRiJHZhciRfX2d1YXJkTWV0aG9kX18oY29uc29sZSwgXCJsb2dcIiwgKG8pPT5vLmxvZyhlcnJvcilcbiAgICAgICAgICAgIClcbiAgICAgICAgO1xuICAgICAgICB2YXIgcmVhZEVudHJpZXMgPSAoKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGRpclJlYWRlci5yZWFkRW50cmllcygoZW50cmllcyk9PntcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkgZW50cnkuZmlsZSgoZmlsZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUhpZGRlbkZpbGVzICYmIGZpbGUubmFtZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLlwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5mdWxsUGF0aCA9IGAke3BhdGh9LyR7ZmlsZS5uYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHRoaXMuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgYCR7cGF0aH0vJHtlbnRyeS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgcmVhZEVudHJpZXMoKSBhZ2Fpbiwgc2luY2UgYnJvd3NlciBvbmx5IGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgMTAwIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RpcmVjdG9yeVJlYWRlciNyZWFkRW50cmllc1xuICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWFkRW50cmllcygpO1xuICAgIH1cbiAgICAvLyBJZiBgZG9uZSgpYCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudCB0aGUgZmlsZSBpcyBhY2NlcHRlZFxuICAgIC8vIElmIHlvdSBjYWxsIGl0IHdpdGggYW4gZXJyb3IgbWVzc2FnZSwgdGhlIGZpbGUgaXMgcmVqZWN0ZWRcbiAgICAvLyAoVGhpcyBhbGxvd3MgZm9yIGFzeW5jaHJvbm91cyB2YWxpZGF0aW9uKVxuICAgIC8vXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIGZpbGVzaXplLCBhbmQgaWYgdGhlIGZpbGUudHlwZSBwYXNzZXMgdGhlXG4gICAgLy8gYGFjY2VwdGVkRmlsZXNgIGNoZWNrLlxuICAgIGFjY2VwdChmaWxlLCBkb25lKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUgJiYgZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLm1heEZpbGVzaXplICogMTA0ODU3NikgZG9uZSh0aGlzLm9wdGlvbnMuZGljdEZpbGVUb29CaWcucmVwbGFjZShcInt7ZmlsZXNpemV9fVwiLCBNYXRoLnJvdW5kKGZpbGUuc2l6ZSAvIDEwMjQgLyAxMC4yNCkgLyAxMDApLnJlcGxhY2UoXCJ7e21heEZpbGVzaXplfX1cIiwgdGhpcy5vcHRpb25zLm1heEZpbGVzaXplKSk7XG4gICAgICAgIGVsc2UgaWYgKCEkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmlzVmFsaWRGaWxlKGZpbGUsIHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzKSkgZG9uZSh0aGlzLm9wdGlvbnMuZGljdEludmFsaWRGaWxlVHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlcyAhPSBudWxsICYmIHRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4RmlsZXMpIHtcbiAgICAgICAgICAgIGRvbmUodGhpcy5vcHRpb25zLmRpY3RNYXhGaWxlc0V4Y2VlZGVkLnJlcGxhY2UoXCJ7e21heEZpbGVzfX1cIiwgdGhpcy5vcHRpb25zLm1heEZpbGVzKSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJtYXhmaWxlc2V4Y2VlZGVkXCIsIGZpbGUpO1xuICAgICAgICB9IGVsc2UgdGhpcy5vcHRpb25zLmFjY2VwdC5jYWxsKHRoaXMsIGZpbGUsIGRvbmUpO1xuICAgIH1cbiAgICBhZGRGaWxlKGZpbGUpIHtcbiAgICAgICAgZmlsZS51cGxvYWQgPSB7XG4gICAgICAgICAgICB1dWlkOiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LnV1aWR2NCgpLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSB0b3RhbCB1cGxvYWQgc2l6ZSB0byBmaWxlLnNpemUgZm9yIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIEl0J3MgYWN0dWFsIGRpZmZlcmVudCB0aGFuIHRoZSBzaXplIHRvIGJlIHRyYW5zbWl0dGVkLlxuICAgICAgICAgICAgdG90YWw6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIGJ5dGVzU2VudDogMCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLl9yZW5hbWVGaWxlKGZpbGUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgZmlsZS5zdGF0dXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFEREVEO1xuICAgICAgICB0aGlzLmVtaXQoXCJhZGRlZGZpbGVcIiwgZmlsZSk7XG4gICAgICAgIHRoaXMuX2VucXVldWVUaHVtYm5haWwoZmlsZSk7XG4gICAgICAgIHRoaXMuYWNjZXB0KGZpbGUsIChlcnJvcik9PntcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZpbGUuYWNjZXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvclByb2Nlc3NpbmcoW1xuICAgICAgICAgICAgICAgICAgICBmaWxlXG4gICAgICAgICAgICAgICAgXSwgZXJyb3IpOyAvLyBXaWxsIHNldCB0aGUgZmlsZS5zdGF0dXNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZS5hY2NlcHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUXVldWUpIHRoaXMuZW5xdWV1ZUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgIC8vIFdpbGwgc2V0IC5hY2NlcHRlZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBXcmFwcGVyIGZvciBlbnF1ZXVlRmlsZVxuICAgIGVucXVldWVGaWxlcyhmaWxlcykge1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXRoaXMuZW5xdWV1ZUZpbGUoZmlsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbnF1ZXVlRmlsZShmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5BRERFRCAmJiBmaWxlLmFjY2VwdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmaWxlLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuUVVFVUVEO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSByZXR1cm4gc2V0VGltZW91dCgoKT0+dGhpcy5wcm9jZXNzUXVldWUoKVxuICAgICAgICAgICAgLCAwKTsgLy8gRGVmZXJyaW5nIHRoZSBjYWxsXG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGZpbGUgY2FuJ3QgYmUgcXVldWVkIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgb3Igd2FzIHJlamVjdGVkLlwiKTtcbiAgICB9XG4gICAgX2VucXVldWVUaHVtYm5haWwoZmlsZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNyZWF0ZUltYWdlVGh1bWJuYWlscyAmJiBmaWxlLnR5cGUubWF0Y2goL2ltYWdlLiovKSAmJiBmaWxlLnNpemUgPD0gdGhpcy5vcHRpb25zLm1heFRodW1ibmFpbEZpbGVzaXplICogMTA0ODU3Nikge1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJuYWlsUXVldWUucHVzaChmaWxlKTtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpPT50aGlzLl9wcm9jZXNzVGh1bWJuYWlsUXVldWUoKVxuICAgICAgICAgICAgLCAwKTsgLy8gRGVmZXJyaW5nIHRoZSBjYWxsXG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdUaHVtYm5haWwgfHwgdGhpcy5fdGh1bWJuYWlsUXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdUaHVtYm5haWwgPSB0cnVlO1xuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuX3RodW1ibmFpbFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChmaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy50aHVtYm5haWxNZXRob2QsIHRydWUsIChkYXRhVXJsKT0+e1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidGh1bWJuYWlsXCIsIGZpbGUsIGRhdGFVcmwpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQ2FuIGJlIGNhbGxlZCBieSB0aGUgdXNlciB0byByZW1vdmUgYSBmaWxlXG4gICAgcmVtb3ZlRmlsZShmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkcpIHRoaXMuY2FuY2VsVXBsb2FkKGZpbGUpO1xuICAgICAgICB0aGlzLmZpbGVzID0gJDNlZDI2OWYyZjBmYjIyNGIkdmFyJHdpdGhvdXQodGhpcy5maWxlcywgZmlsZSk7XG4gICAgICAgIHRoaXMuZW1pdChcInJlbW92ZWRmaWxlXCIsIGZpbGUpO1xuICAgICAgICBpZiAodGhpcy5maWxlcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmVtaXQoXCJyZXNldFwiKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlcyBhbGwgZmlsZXMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IHByb2Nlc3NlZCBmcm9tIHRoZSBsaXN0XG4gICAgcmVtb3ZlQWxsRmlsZXMoY2FuY2VsSWZOZWNlc3NhcnkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiBmaWxlcyBzaW5jZSByZW1vdmVGaWxlKCkgY2hhbmdlcyB0aGUgQGZpbGVzIGFycmF5LlxuICAgICAgICBpZiAoY2FuY2VsSWZOZWNlc3NhcnkgPT0gbnVsbCkgY2FuY2VsSWZOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiB0aGlzLmZpbGVzLnNsaWNlKCkpaWYgKGZpbGUuc3RhdHVzICE9PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORyB8fCBjYW5jZWxJZk5lY2Vzc2FyeSkgdGhpcy5yZW1vdmVGaWxlKGZpbGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmVzaXplcyBhbiBpbWFnZSBiZWZvcmUgaXQgZ2V0cyBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcbiAgICAvLyBgb3B0aW9ucy50cmFuc2Zvcm1GaWxlYCBpZiBgcmVzaXplV2lkdGhgIG9yIGByZXNpemVIZWlnaHRgIGFyZSBzZXQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGhcbiAgICAvLyB0aGUgcmVzaXplZCBibG9iLlxuICAgIHJlc2l6ZUltYWdlKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgdHJ1ZSwgKGRhdGFVcmwsIGNhbnZhcyk9PntcbiAgICAgICAgICAgIGlmIChjYW52YXMgPT0gbnVsbCkgLy8gVGhlIGltYWdlIGhhcyBub3QgYmVlbiByZXNpemVkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmlsZSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyByZXNpemVNaW1lVHlwZTogcmVzaXplTWltZVR5cGUgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU1pbWVUeXBlID09IG51bGwpIHJlc2l6ZU1pbWVUeXBlID0gZmlsZS50eXBlO1xuICAgICAgICAgICAgICAgIGxldCByZXNpemVkRGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwocmVzaXplTWltZVR5cGUsIHRoaXMub3B0aW9ucy5yZXNpemVRdWFsaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT09IFwiaW1hZ2UvanBlZ1wiIHx8IHJlc2l6ZU1pbWVUeXBlID09PSBcImltYWdlL2pwZ1wiKSAvLyBOb3cgYWRkIHRoZSBvcmlnaW5hbCBFWElGIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcmVzaXplZERhdGFVUkwgPSAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkRXhpZlJlc3RvcmUucmVzdG9yZShmaWxlLmRhdGFVUkwsIHJlc2l6ZWREYXRhVVJMKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5kYXRhVVJJdG9CbG9iKHJlc2l6ZWREYXRhVVJMKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUaHVtYm5haWwoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCBmaXhPcmllbnRhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpPT57XG4gICAgICAgICAgICBmaWxlLmRhdGFVUkwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIC8vIERvbid0IGJvdGhlciBjcmVhdGluZyBhIHRodW1ibmFpbCBmb3IgU1ZHIGltYWdlcyBzaW5jZSB0aGV5J3JlIHZlY3RvclxuICAgICAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgY2FsbGJhY2soZmlsZVJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGh1bWJuYWlsRnJvbVVybChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9XG4gICAgLy8gYG1vY2tGaWxlYCBuZWVkcyB0byBoYXZlIHRoZXNlIGF0dHJpYnV0ZXM6XG4gICAgLy9cbiAgICAvLyAgICAgeyBuYW1lOiAnbmFtZScsIHNpemU6IDEyMzQ1LCBpbWFnZVVybDogJycgfVxuICAgIC8vXG4gICAgLy8gYGNhbGxiYWNrYCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGJlZW4gZG93bmxvYWRlZCBhbmQgZGlzcGxheWVkLlxuICAgIC8vIGBjcm9zc09yaWdpbmAgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGltZ2AgdGFnIHdoZW4gYWNjZXNzaW5nIHRoZSBmaWxlLlxuICAgIGRpc3BsYXlFeGlzdGluZ0ZpbGUobW9ja0ZpbGUsIGltYWdlVXJsLCBjYWxsYmFjaywgY3Jvc3NPcmlnaW4sIHJlc2l6ZVRodW1ibmFpbCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiYWRkZWRmaWxlXCIsIG1vY2tGaWxlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgbW9ja0ZpbGUpO1xuICAgICAgICBpZiAoIXJlc2l6ZVRodW1ibmFpbCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidGh1bWJuYWlsXCIsIG1vY2tGaWxlLCBpbWFnZVVybCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb25Eb25lID0gKHRodW1ibmFpbCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ0aHVtYm5haWxcIiwgbW9ja0ZpbGUsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vY2tGaWxlLmRhdGFVUkwgPSBpbWFnZVVybDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGh1bWJuYWlsRnJvbVVybChtb2NrRmlsZSwgdGhpcy5vcHRpb25zLnRodW1ibmFpbFdpZHRoLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsSGVpZ2h0LCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsTWV0aG9kLCB0aGlzLm9wdGlvbnMuZml4T3JpZW50YXRpb24sIG9uRG9uZSwgY3Jvc3NPcmlnaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRodW1ibmFpbEZyb21VcmwoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCBmaXhPcmllbnRhdGlvbiwgY2FsbGJhY2ssIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIC8vIE5vdCB1c2luZyBgbmV3IEltYWdlYCBoZXJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gbGF0ZXN0IENocm9tZSB2ZXJzaW9ucy5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbnlvL2Ryb3B6b25lL3B1bGwvMjI2XG4gICAgICAgIGxldCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBpZiAoY3Jvc3NPcmlnaW4pIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgICAvLyBmaXhPcmllbnRhdGlvbiBpcyBub3QgbmVlZGVkIGFueW1vcmUgd2l0aCBicm93c2VycyBoYW5kbGluZyBpbWFnZU9yaWVudGF0aW9uXG4gICAgICAgIGZpeE9yaWVudGF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KVtcImltYWdlT3JpZW50YXRpb25cIl0gPT0gXCJmcm9tLWltYWdlXCIgPyBmYWxzZSA6IGZpeE9yaWVudGF0aW9uO1xuICAgICAgICBpbWcub25sb2FkID0gKCk9PntcbiAgICAgICAgICAgIGxldCBsb2FkRXhpZiA9IChjYWxsYmFjayk9PmNhbGxiYWNrKDEpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEVYSUYgIT09IFwidW5kZWZpbmVkXCIgJiYgRVhJRiAhPT0gbnVsbCAmJiBmaXhPcmllbnRhdGlvbikgbG9hZEV4aWYgPSAoY2FsbGJhY2spPT5FWElGLmdldERhdGEoaW1nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVYSUYuZ2V0VGFnKHRoaXMsIFwiT3JpZW50YXRpb25cIikpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gbG9hZEV4aWYoKG9yaWVudGF0aW9uKT0+e1xuICAgICAgICAgICAgICAgIGZpbGUud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgZmlsZS5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCByZXNpemVJbmZvID0gdGhpcy5vcHRpb25zLnJlc2l6ZS5jYWxsKHRoaXMsIGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCk7XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmVzaXplSW5mby50cmdXaWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzaXplSW5mby50cmdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlc2l6ZUluZm8udHJnV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaChvcmllbnRhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvcml6b250YWwgZmxpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxODDCsCByb3RhdGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBmbGlwXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA5MMKwIHJvdGF0ZSByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLWNhbnZhcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMuaGVpZ2h0LCAtY2FudmFzLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gOTDCsCByb3RhdGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtMC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jYW52YXMuaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgYnVnZml4IGZvciBpT1MnIHNjYWxpbmcgYnVnLlxuICAgICAgICAgICAgICAgICQzZWQyNjlmMmYwZmIyMjRiJHZhciRkcmF3SW1hZ2VJT1NGaXgoY3R4LCBpbWcsIHJlc2l6ZUluZm8uc3JjWCAhPSBudWxsID8gcmVzaXplSW5mby5zcmNYIDogMCwgcmVzaXplSW5mby5zcmNZICE9IG51bGwgPyByZXNpemVJbmZvLnNyY1kgOiAwLCByZXNpemVJbmZvLnNyY1dpZHRoLCByZXNpemVJbmZvLnNyY0hlaWdodCwgcmVzaXplSW5mby50cmdYICE9IG51bGwgPyByZXNpemVJbmZvLnRyZ1ggOiAwLCByZXNpemVJbmZvLnRyZ1kgIT0gbnVsbCA/IHJlc2l6ZUluZm8udHJnWSA6IDAsIHJlc2l6ZUluZm8udHJnV2lkdGgsIHJlc2l6ZUluZm8udHJnSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsZXQgdGh1bWJuYWlsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgcmV0dXJuIGNhbGxiYWNrKHRodW1ibmFpbCwgY2FudmFzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgaW1nLm9uZXJyb3IgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIGltZy5zcmMgPSBmaWxlLmRhdGFVUkw7XG4gICAgfVxuICAgIC8vIEdvZXMgdGhyb3VnaCB0aGUgcXVldWUgYW5kIHByb2Nlc3NlcyBmaWxlcyBpZiB0aGVyZSBhcmVuJ3QgdG9vIG1hbnkgYWxyZWFkeS5cbiAgICBwcm9jZXNzUXVldWUoKSB7XG4gICAgICAgIGxldCB7IHBhcmFsbGVsVXBsb2FkczogcGFyYWxsZWxVcGxvYWRzICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBsZXQgcHJvY2Vzc2luZ0xlbmd0aCA9IHRoaXMuZ2V0VXBsb2FkaW5nRmlsZXMoKS5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gcHJvY2Vzc2luZ0xlbmd0aDtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGFscmVhZHkgYXQgbGVhc3QgYXMgbWFueSBmaWxlcyB1cGxvYWRpbmcgdGhhbiBzaG91bGQgYmVcbiAgICAgICAgaWYgKHByb2Nlc3NpbmdMZW5ndGggPj0gcGFyYWxsZWxVcGxvYWRzKSByZXR1cm47XG4gICAgICAgIGxldCBxdWV1ZWRGaWxlcyA9IHRoaXMuZ2V0UXVldWVkRmlsZXMoKTtcbiAgICAgICAgaWYgKCEocXVldWVkRmlsZXMubGVuZ3RoID4gMCkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgLy8gVGhlIGZpbGVzIHNob3VsZCBiZSB1cGxvYWRlZCBpbiBvbmUgcmVxdWVzdFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRmlsZXMocXVldWVkRmlsZXMuc2xpY2UoMCwgcGFyYWxsZWxVcGxvYWRzIC0gcHJvY2Vzc2luZ0xlbmd0aCkpO1xuICAgICAgICBlbHNlIHdoaWxlKGkgPCBwYXJhbGxlbFVwbG9hZHMpe1xuICAgICAgICAgICAgaWYgKCFxdWV1ZWRGaWxlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRmlsZShxdWV1ZWRGaWxlcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXcmFwcGVyIGZvciBgcHJvY2Vzc0ZpbGVzYFxuICAgIHByb2Nlc3NGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbGVzKFtcbiAgICAgICAgICAgIGZpbGVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIExvYWRzIHRoZSBmaWxlLCB0aGVuIGNhbGxzIGZpbmlzaGVkTG9hZGluZygpXG4gICAgcHJvY2Vzc0ZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpe1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzaW5nID0gdHJ1ZTsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9jZXNzaW5nXCIsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHRoaXMuZW1pdChcInByb2Nlc3NpbmdtdWx0aXBsZVwiLCBmaWxlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKTtcbiAgICB9XG4gICAgX2dldEZpbGVzV2l0aFhocih4aHIpIHtcbiAgICAgICAgbGV0IGZpbGVzO1xuICAgICAgICByZXR1cm4gZmlsZXMgPSB0aGlzLmZpbGVzLmZpbHRlcigoZmlsZSk9PmZpbGUueGhyID09PSB4aHJcbiAgICAgICAgKS5tYXAoKGZpbGUpPT5maWxlXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgdGhlIGZpbGUgdXBsb2FkIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG8gQ0FOQ0VMRURcbiAgICAvLyAqKmlmKiogdGhlIGZpbGUgaXMgYWN0dWFsbHkgYmVpbmcgdXBsb2FkZWQuXG4gICAgLy8gSWYgaXQncyBzdGlsbCBpbiB0aGUgcXVldWUsIHRoZSBmaWxlIGlzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdCBhbmQgdGhlIHN0YXR1c1xuICAgIC8vIHNldCB0byBDQU5DRUxFRC5cbiAgICBjYW5jZWxVcGxvYWQoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5zdGF0dXMgPT09ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBlZEZpbGVzID0gdGhpcy5fZ2V0RmlsZXNXaXRoWGhyKGZpbGUueGhyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwZWRGaWxlIG9mIGdyb3VwZWRGaWxlcylncm91cGVkRmlsZS5zdGF0dXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkNBTkNFTEVEO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlLnhociAhPT0gXCJ1bmRlZmluZWRcIikgZmlsZS54aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwZWRGaWxlMSBvZiBncm91cGVkRmlsZXMpdGhpcy5lbWl0KFwiY2FuY2VsZWRcIiwgZ3JvdXBlZEZpbGUxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHRoaXMuZW1pdChcImNhbmNlbGVkbXVsdGlwbGVcIiwgZ3JvdXBlZEZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5BRERFRCB8fCBmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5RVUVVRUQpIHtcbiAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5DQU5DRUxFRDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNhbmNlbGVkXCIsIGZpbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgdGhpcy5lbWl0KFwiY2FuY2VsZWRtdWx0aXBsZVwiLCBbXG4gICAgICAgICAgICAgICAgZmlsZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgcmVzb2x2ZU9wdGlvbihvcHRpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9wdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG4gICAgdXBsb2FkRmlsZShmaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKFtcbiAgICAgICAgICAgIGZpbGVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHVwbG9hZEZpbGVzKGZpbGVzKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUZpbGVzKGZpbGVzLCAodHJhbnNmb3JtZWRGaWxlcyk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2h1bmtpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHVua2luZyBpcyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIHdpdGggYHVwbG9hZE11bHRpcGxlYCBzbyB3ZSBrbm93XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGVyZSBpcyBvbmx5IF9fb25lX19maWxlLlxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZEZpbGUgPSB0cmFuc2Zvcm1lZEZpbGVzWzBdO1xuICAgICAgICAgICAgICAgIGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5raW5nICYmICh0aGlzLm9wdGlvbnMuZm9yY2VDaHVua2luZyB8fCB0cmFuc2Zvcm1lZEZpbGUuc2l6ZSA+IHRoaXMub3B0aW9ucy5jaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGZpbGVzWzBdLnVwbG9hZC50b3RhbENodW5rQ291bnQgPSBNYXRoLmNlaWwodHJhbnNmb3JtZWRGaWxlLnNpemUgLyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmlsZSBzaG91bGQgYmUgc2VudCBpbiBjaHVua3MhXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNodW5raW5nIG9wdGlvbiBpcyBzZXQsIHdlICoqa25vdyoqIHRoYXQgdGhlcmUgY2FuIG9ubHkgYmUgKipvbmUqKiBmaWxlLCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVwbG9hZE11bHRpcGxlIGlzIG5vdCBhbGxvd2VkIHdpdGggdGhpcyBvcHRpb24uXG4gICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBmaWxlc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRGaWxlID0gdHJhbnNmb3JtZWRGaWxlc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRlZENodW5rQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLmNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBoYW5kbGVOZXh0Q2h1bmsgPSAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgaXRlbSBpbiBmaWxlLnVwbG9hZC5jaHVua3MgdGhhdCBpcyBub3QgZGVmaW5lZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGZpbGUudXBsb2FkLmNodW5rc1tjaHVua0luZGV4XSAhPT0gdW5kZWZpbmVkKWNodW5rSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucywgdGhhdCBhbGwgY2h1bmtzIGhhdmUgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0luZGV4ID49IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkQ2h1bmtDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjaHVua0luZGV4ICogdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgdHJhbnNmb3JtZWRGaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fZ2V0UGFyYW1OYW1lKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJhbnNmb3JtZWRGaWxlLndlYmtpdFNsaWNlID8gdHJhbnNmb3JtZWRGaWxlLndlYmtpdFNsaWNlKHN0YXJ0LCBlbmQpIDogdHJhbnNmb3JtZWRGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUudXBsb2FkLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtJbmRleDogY2h1bmtJbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5jaHVua3NbY2h1bmtJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNodW5rSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2s6IGRhdGFCbG9jayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXM6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YShmaWxlcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUJsb2NrXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQuZmluaXNoZWRDaHVua1VwbG9hZCA9IChjaHVuaywgcmVzcG9uc2UpPT57XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGxGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuU1VDQ0VTUztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGRhdGEgZnJvbSB0aGUgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuZGF0YUJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucmVzcG9uc2UgPSBjaHVuay54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5yZXNwb25zZUhlYWRlcnMgPSBjaHVuay54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgdGhpcyByZWZlcmVuY2UgdG8geGhyIHdpbGwgY2F1c2UgbWVtb3J5IGxlYWtzLlxuICAgICAgICAgICAgICAgICAgICBjaHVuay54aHIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFuZGxlTmV4dENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS51cGxvYWQuY2h1bmtzW2ldLnN0YXR1cyAhPT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5TVUNDRVNTKSBhbGxGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxGaW5pc2hlZCkgdGhpcy5vcHRpb25zLmNodW5rc1VwbG9hZGVkKGZpbGUsICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hlZChmaWxlcywgcmVzcG9uc2UsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWxsZWxDaHVua1VwbG9hZHMpIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKyloYW5kbGVOZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGhhbmRsZU5leHRDaHVuaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YUJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKylkYXRhQmxvY2tzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9nZXRQYXJhbU5hbWUoaSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRyYW5zZm9ybWVkRmlsZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlc1tpXS51cGxvYWQuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEoZmlsZXMsIGRhdGFCbG9ja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIHJpZ2h0IGNodW5rIGZvciBnaXZlbiBmaWxlIGFuZCB4aHJcbiAgICBfZ2V0Q2h1bmsoZmlsZSwgeGhyKSB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKyl7XG4gICAgICAgICAgICBpZiAoZmlsZS51cGxvYWQuY2h1bmtzW2ldICE9PSB1bmRlZmluZWQgJiYgZmlsZS51cGxvYWQuY2h1bmtzW2ldLnhociA9PT0geGhyKSByZXR1cm4gZmlsZS51cGxvYWQuY2h1bmtzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWN0dWFsbHkgdXBsb2FkcyB0aGUgZmlsZShzKSB0byB0aGUgc2VydmVyLlxuICAgIC8vXG4gICAgLy8gIElmIGRhdGFCbG9ja3MgY29udGFpbnMgdGhlIGFjdHVhbCBkYXRhIHRvIHVwbG9hZCAobWVhbmluZywgdGhhdCB0aGlzIGNvdWxkXG4gICAgLy8gZWl0aGVyIGJlIHRyYW5zZm9ybWVkIGZpbGVzLCBvciBpbmRpdmlkdWFsIGNodW5rcyBmb3IgY2h1bmtlZCB1cGxvYWQpIHRoZW5cbiAgICAvLyB0aGV5IHdpbGwgYmUgdXNlZCBmb3IgdGhlIGFjdHVhbCBkYXRhIHRvIHVwbG9hZC5cbiAgICBfdXBsb2FkRGF0YShmaWxlcywgZGF0YUJsb2Nrcykge1xuICAgICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIC8vIFB1dCB0aGUgeGhyIG9iamVjdCBpbiB0aGUgZmlsZSBvYmplY3RzIHRvIGJlIGFibGUgdG8gcmVmZXJlbmNlIGl0IGxhdGVyLlxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKWZpbGUueGhyID0geGhyO1xuICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIC8vIFB1dCB0aGUgeGhyIG9iamVjdCBpbiB0aGUgcmlnaHQgY2h1bmsgb2JqZWN0LCBzbyBpdCBjYW4gYmUgYXNzb2NpYXRlZFxuICAgICAgICAvLyBsYXRlciwgYW5kIGZvdW5kIHdpdGggX2dldENodW5rLlxuICAgICAgICBmaWxlc1swXS51cGxvYWQuY2h1bmtzW2RhdGFCbG9ja3NbMF0uY2h1bmtJbmRleF0ueGhyID0geGhyO1xuICAgICAgICBsZXQgbWV0aG9kID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy5tZXRob2QsIGZpbGVzLCBkYXRhQmxvY2tzKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMudXJsLCBmaWxlcywgZGF0YUJsb2Nrcyk7XG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgdGltZW91dCBhZnRlciBvcGVuIGJlY2F1c2Ugb2YgSUUxMSBpc3N1ZTogaHR0cHM6Ly9naXRsYWIuY29tL21lbm8vZHJvcHpvbmUvaXNzdWVzLzhcbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnRpbWVvdXQsIGZpbGVzKTtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHhoci50aW1lb3V0ID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy50aW1lb3V0LCBmaWxlcyk7XG4gICAgICAgIC8vIEhhcyB0byBiZSBhZnRlciBgLm9wZW4oKWAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZW55by9kcm9wem9uZS9pc3N1ZXMvMTc5XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIXRoaXMub3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkVXBsb2FkaW5nKGZpbGVzLCB4aHIsIGUpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub250aW1lb3V0ID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIsIGBSZXF1ZXN0IHRpbWVkb3V0IGFmdGVyICR7dGhpcy5vcHRpb25zLnRpbWVvdXQgLyAxMDAwfSBzZWNvbmRzYCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBoYXZlIHRoZSAudXBsb2FkIHByb3BlcnR5XG4gICAgICAgIGxldCBwcm9ncmVzc09iaiA9IHhoci51cGxvYWQgIT0gbnVsbCA/IHhoci51cGxvYWQgOiB4aHI7XG4gICAgICAgIHByb2dyZXNzT2JqLm9ucHJvZ3Jlc3MgPSAoZSk9PnRoaXMuX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZmlsZXMsIHhociwgZSlcbiAgICAgICAgO1xuICAgICAgICBsZXQgaGVhZGVycyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0SGVhZGVycyA/IHtcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZVwiLFxuICAgICAgICAgICAgXCJYLVJlcXVlc3RlZC1XaXRoXCI6IFwiWE1MSHR0cFJlcXVlc3RcIlxuICAgICAgICB9IDoge1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmFyeUJvZHkpIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBmaWxlc1swXS50eXBlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpICRld0JLeSRqdXN0ZXh0ZW5kKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgZm9yKGxldCBoZWFkZXJOYW1lIGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgbGV0IGhlYWRlclZhbHVlID0gaGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJWYWx1ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmluYXJ5Qm9keSkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGZpbGUgaXMgZ29pbmcgdG8gYmUgc2VudCBhcyBiaW5hcnkgYm9keSwgaXQgZG9lc24ndCBtYWtlXG4gICAgICAgICAgICAvLyBhbnkgc2Vuc2UgdG8gZ2VuZXJhdGUgYEZvcm1EYXRhYCBmb3IgaXQuXG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXRoaXMuZW1pdChcInNlbmRpbmdcIiwgZmlsZSwgeGhyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHRoaXMuZW1pdChcInNlbmRpbmdtdWx0aXBsZVwiLCBmaWxlcywgeGhyKTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0UmVxdWVzdCh4aHIsIG51bGwsIGZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgLy8gQWRkaW5nIGFsbCBAb3B0aW9ucyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGRpdGlvbmFsUGFyYW1zID0gdGhpcy5vcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFkZGl0aW9uYWxQYXJhbXMgPT09IFwiZnVuY3Rpb25cIikgYWRkaXRpb25hbFBhcmFtcyA9IGFkZGl0aW9uYWxQYXJhbXMuY2FsbCh0aGlzLCBmaWxlcywgeGhyLCBmaWxlc1swXS51cGxvYWQuY2h1bmtlZCA/IHRoaXMuX2dldENodW5rKGZpbGVzWzBdLCB4aHIpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gYWRkaXRpb25hbFBhcmFtcyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGFkZGl0aW9uYWxQYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSAvLyBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXIgY29udGFpbnMgYW4gYXJyYXksXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGxldHMgaXRlcmF0ZSBvdmVyIGl0IHRvIGF0dGFjaCBlYWNoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKWZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV0IHRoZSB1c2VyIGFkZCBhZGRpdGlvbmFsIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXRoaXMuZW1pdChcInNlbmRpbmdcIiwgZmlsZSwgeGhyLCBmb3JtRGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB0aGlzLmVtaXQoXCJzZW5kaW5nbXVsdGlwbGVcIiwgZmlsZXMsIHhociwgZm9ybURhdGEpO1xuICAgICAgICAgICAgdGhpcy5fYWRkRm9ybUVsZW1lbnREYXRhKGZvcm1EYXRhKTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHkgYWRkIHRoZSBmaWxlc1xuICAgICAgICAgICAgLy8gSGFzIHRvIGJlIGxhc3QgYmVjYXVzZSBzb21lIHNlcnZlcnMgKGVnOiBTMykgZXhwZWN0IHRoZSBmaWxlIHRvIGJlIHRoZSBsYXN0IHBhcmFtZXRlclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGFCbG9ja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGxldCBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChkYXRhQmxvY2submFtZSwgZGF0YUJsb2NrLmRhdGEsIGRhdGFCbG9jay5maWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdFJlcXVlc3QoeGhyLCBmb3JtRGF0YSwgZmlsZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybXMgYWxsIGZpbGVzIHdpdGggdGhpcy5vcHRpb25zLnRyYW5zZm9ybUZpbGUgYW5kIGludm9rZXMgZG9uZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBmaWxlcyB3aGVuIGRvbmUuXG4gICAgX3RyYW5zZm9ybUZpbGVzKGZpbGVzLCBkb25lKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZEZpbGVzID0gW107XG4gICAgICAgIC8vIENsdW1zeSB3YXkgb2YgaGFuZGxpbmcgYXN5bmNocm9ub3VzIGNhbGxzLCB1bnRpbCBJIGdldCB0byBhZGQgYSBwcm9wZXIgRnV0dXJlIGxpYnJhcnkuXG4gICAgICAgIGxldCBkb25lQ291bnRlciA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKyl0aGlzLm9wdGlvbnMudHJhbnNmb3JtRmlsZS5jYWxsKHRoaXMsIGZpbGVzW2ldLCAodHJhbnNmb3JtZWRGaWxlKT0+e1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRGaWxlc1tpXSA9IHRyYW5zZm9ybWVkRmlsZTtcbiAgICAgICAgICAgIGlmICgrK2RvbmVDb3VudGVyID09PSBmaWxlcy5sZW5ndGgpIGRvbmUodHJhbnNmb3JtZWRGaWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUYWtlcyBjYXJlIG9mIGFkZGluZyBvdGhlciBpbnB1dCBlbGVtZW50cyBvZiB0aGUgZm9ybSB0byB0aGUgQUpBWCByZXF1ZXN0XG4gICAgX2FkZEZvcm1FbGVtZW50RGF0YShmb3JtRGF0YSkge1xuICAgICAgICAvLyBUYWtlIGNhcmUgb2Ygb3RoZXIgaW5wdXQgZWxlbWVudHNcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lID09PSBcIkZPUk1cIikgZm9yIChsZXQgaW5wdXQgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCwgYnV0dG9uXCIpKXtcbiAgICAgICAgICAgIGxldCBpbnB1dE5hbWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgbGV0IGlucHV0VHlwZSA9IGlucHV0LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgICAgICBpZiAoaW5wdXRUeXBlKSBpbnB1dFR5cGUgPSBpbnB1dFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBkb2Vzbid0IGhhdmUgYSBuYW1lLCB3ZSBjYW4ndCB1c2UgaXQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0TmFtZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpbnB1dE5hbWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09IFwiU0VMRUNUXCIgJiYgaW5wdXQuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJseSBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgaW5wdXQub3B0aW9ucylpZiAob3B0aW9uLnNlbGVjdGVkKSBmb3JtRGF0YS5hcHBlbmQoaW5wdXROYW1lLCBvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5wdXRUeXBlIHx8IGlucHV0VHlwZSAhPT0gXCJjaGVja2JveFwiICYmIGlucHV0VHlwZSAhPT0gXCJyYWRpb1wiIHx8IGlucHV0LmNoZWNrZWQpIGZvcm1EYXRhLmFwcGVuZChpbnB1dE5hbWUsIGlucHV0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbnZva2VkIHdoZW4gdGhlcmUgaXMgbmV3IHByb2dyZXNzIGluZm9ybWF0aW9uIGFib3V0IGdpdmVuIGZpbGVzLlxuICAgIC8vIElmIGUgaXMgbm90IHByb3ZpZGVkLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHVwbG9hZCBpcyBmaW5pc2hlZC5cbiAgICBfdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzcyhmaWxlcywgeGhyLCBlKSB7XG4gICAgICAgIGlmICghZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIC8vIEhhbmRsZSBmaWxlIHVwbG9hZHMgd2l0aG91dCBjaHVua2luZ1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC50b3RhbCAmJiBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgJiYgZmlsZS51cGxvYWQuYnl0ZXNTZW50ID09IGZpbGUudXBsb2FkLnRvdGFsKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgPSAxMDAgKiBlLmxvYWRlZCAvIGUudG90YWw7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQudG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBldmVudCwgc28gd2UncmUgYXQgMTAwJVxuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLnByb2dyZXNzID0gMTAwO1xuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9IGZpbGUudXBsb2FkLnRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBsb2FkcHJvZ3Jlc3NcIiwgZmlsZSwgZmlsZS51cGxvYWQucHJvZ3Jlc3MsIGZpbGUudXBsb2FkLmJ5dGVzU2VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY2h1bmtlZCBmaWxlIHVwbG9hZHNcbiAgICAgICAgICAgIC8vIENodW5rZWQgdXBsb2FkIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdXBsb2FkaW5nIG11bHRpcGxlIGZpbGVzIGluIG9uZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCwgc28gd2Uga25vdyB0aGVyZSdzIG9ubHkgb25lIGZpbGUuXG4gICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzWzBdO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGNodW5rZWQgdXBsb2FkLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgYXBwcm9wcmlhdGUgY2h1bmtcbiAgICAgICAgICAgIC8vIHByb2dyZXNzLlxuICAgICAgICAgICAgbGV0IGNodW5rID0gdGhpcy5fZ2V0Q2h1bmsoZmlsZSwgeGhyKTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSAxMDAgKiBlLmxvYWRlZCAvIGUudG90YWw7XG4gICAgICAgICAgICAgICAgY2h1bmsudG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICAgIGNodW5rLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBldmVudCwgc28gd2UncmUgYXQgMTAwJVxuICAgICAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gMTAwO1xuICAgICAgICAgICAgICAgIGNodW5rLmJ5dGVzU2VudCA9IGNodW5rLnRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHRhbGx5IHRoZSAqZmlsZSogdXBsb2FkIHByb2dyZXNzIGZyb20gaXRzIGluZGl2aWR1YWwgY2h1bmtzXG4gICAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBmaWxlLnVwbG9hZC50b3RhbCA9IDA7XG4gICAgICAgICAgICBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKWlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0gJiYgdHlwZW9mIGZpbGUudXBsb2FkLmNodW5rc1tpXS5wcm9ncmVzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLnByb2dyZXNzICs9IGZpbGUudXBsb2FkLmNodW5rc1tpXS5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC50b3RhbCArPSBmaWxlLnVwbG9hZC5jaHVua3NbaV0udG90YWw7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQuYnl0ZXNTZW50ICs9IGZpbGUudXBsb2FkLmNodW5rc1tpXS5ieXRlc1NlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgcHJvY2VzcyBpcyBhIHBlcmNlbnRhZ2UsIHdlIG5lZWQgdG8gZGl2aWRlIGJ5IHRoZSBhbW91bnQgb2ZcbiAgICAgICAgICAgIC8vIGNodW5rcyB3ZSd2ZSB1c2VkLlxuICAgICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgPSBmaWxlLnVwbG9hZC5wcm9ncmVzcyAvIGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwbG9hZHByb2dyZXNzXCIsIGZpbGUsIGZpbGUudXBsb2FkLnByb2dyZXNzLCBmaWxlLnVwbG9hZC5ieXRlc1NlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maW5pc2hlZFVwbG9hZGluZyhmaWxlcywgeGhyLCBlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgaWYgKGZpbGVzWzBdLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5DQU5DRUxFRCkgcmV0dXJuO1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgIT09IFwiYXJyYXlidWZmZXJcIiAmJiB4aHIucmVzcG9uc2VUeXBlICE9PSBcImJsb2JcIikge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgaWYgKHhoci5nZXRSZXNwb25zZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiKSAmJiB+eGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gc2VydmVyLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZmlsZXMsIHhocik7XG4gICAgICAgIGlmICghKDIwMCA8PSB4aHIuc3RhdHVzICYmIHhoci5zdGF0dXMgPCAzMDApKSB0aGlzLl9oYW5kbGVVcGxvYWRFcnJvcihmaWxlcywgeGhyLCByZXNwb25zZSk7XG4gICAgICAgIGVsc2UgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkKSBmaWxlc1swXS51cGxvYWQuZmluaXNoZWRDaHVua1VwbG9hZCh0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKSwgcmVzcG9uc2UpO1xuICAgICAgICBlbHNlIHRoaXMuX2ZpbmlzaGVkKGZpbGVzLCByZXNwb25zZSwgZSk7XG4gICAgfVxuICAgIF9oYW5kbGVVcGxvYWRFcnJvcihmaWxlcywgeGhyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAoZmlsZXNbMF0uc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkNBTkNFTEVEKSByZXR1cm47XG4gICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCAmJiB0aGlzLm9wdGlvbnMucmV0cnlDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBjaHVuayA9IHRoaXMuX2dldENodW5rKGZpbGVzWzBdLCB4aHIpO1xuICAgICAgICAgICAgaWYgKChjaHVuay5yZXRyaWVzKyspIDwgdGhpcy5vcHRpb25zLnJldHJ5Q2h1bmtzTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhKGZpbGVzLCBbXG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmRhdGFCbG9ja1xuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBjb25zb2xlLndhcm4oXCJSZXRyaWVkIHRoaXMgY2h1bmsgdG9vIG9mdGVuLiBHaXZpbmcgdXAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yUHJvY2Vzc2luZyhmaWxlcywgcmVzcG9uc2UgfHwgdGhpcy5vcHRpb25zLmRpY3RSZXNwb25zZUVycm9yLnJlcGxhY2UoXCJ7e3N0YXR1c0NvZGV9fVwiLCB4aHIuc3RhdHVzKSwgeGhyKTtcbiAgICB9XG4gICAgc3VibWl0UmVxdWVzdCh4aHIsIGZvcm1EYXRhLCBmaWxlcykge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IHNlbmQgdGhpcyByZXF1ZXN0IGJlY2F1c2UgdGhlIFhNTEh0dHBSZXF1ZXN0LnJlYWR5U3RhdGUgaXMgbm90IE9QRU5FRC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iaW5hcnlCb2R5KSB7XG4gICAgICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2dldENodW5rKGZpbGVzWzBdLCB4aHIpO1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKGNodW5rLmRhdGFCbG9jay5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB4aHIuc2VuZChmaWxlc1swXSk7XG4gICAgICAgIH0gZWxzZSB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZC5cbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXG4gICAgX2ZpbmlzaGVkKGZpbGVzLCByZXNwb25zZVRleHQsIGUpIHtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcyl7XG4gICAgICAgICAgICBmaWxlLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuU1VDQ0VTUztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN1Y2Nlc3NcIiwgZmlsZSwgcmVzcG9uc2VUZXh0LCBlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN1Y2Nlc3NtdWx0aXBsZVwiLCBmaWxlcywgcmVzcG9uc2VUZXh0LCBlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlbXVsdGlwbGVcIiwgZmlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSkgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZC5cbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXG4gICAgX2Vycm9yUHJvY2Vzc2luZyhmaWxlcywgbWVzc2FnZSwgeGhyKSB7XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpe1xuICAgICAgICAgICAgZmlsZS5zdGF0dXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkVSUk9SO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZmlsZSwgbWVzc2FnZSwgeGhyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9ybXVsdGlwbGVcIiwgZmlsZXMsIG1lc3NhZ2UsIHhocik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZW11bHRpcGxlXCIsIGZpbGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHJldHVybiB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgdXVpZHY0KCkge1xuICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09IFwieFwiID8gciA6IHIgJiAzIHwgODtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IGZhbGxiYWNrLCBsZWZ0O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbDtcbiAgICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107IC8vIEFsbCBmaWxlc1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZWxlbWVudCA9PT0gXCJzdHJpbmdcIikgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmVsZW1lbnQpO1xuICAgICAgICAvLyBOb3QgY2hlY2tpbmcgaWYgaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQgb3IgRWxlbWVudCBzaW5jZSBJRTkgaXMgZXh0cmVtZWx5IHdlaXJkLlxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQubm9kZVR5cGUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkcm9wem9uZSBlbGVtZW50LlwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5kcm9wem9uZSkgdGhyb3cgbmV3IEVycm9yKFwiRHJvcHpvbmUgYWxyZWFkeSBhdHRhY2hlZC5cIik7XG4gICAgICAgIC8vIE5vdyBhZGQgdGhpcyBkcm9wem9uZSB0byB0aGUgaW5zdGFuY2VzLlxuICAgICAgICAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICAvLyBQdXQgdGhlIGRyb3B6b25lIGluc2lkZSB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHRoaXMuZWxlbWVudC5kcm9wem9uZSA9IHRoaXM7XG4gICAgICAgIGxldCBlbGVtZW50T3B0aW9ucyA9IChsZWZ0ID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5vcHRpb25zRm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpKSAhPSBudWxsID8gbGVmdCA6IHtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJGV3Qkt5JGp1c3RleHRlbmQodHJ1ZSwge1xuICAgICAgICB9LCAkNGNhMzY3MTgyNzc2ZjgwYiRleHBvcnQkMmUyYmNkODczOWFlMDM5LCBlbGVtZW50T3B0aW9ucywgb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMucHJldmlld1RlbXBsYXRlLnJlcGxhY2UoL1xcbiovZywgXCJcIik7XG4gICAgICAgIC8vIElmIHRoZSBicm93c2VyIGZhaWxlZCwganVzdCBjYWxsIHRoZSBmYWxsYmFjayBhbmQgbGVhdmVcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZUZhbGxiYWNrIHx8ICEkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmlzQnJvd3NlclN1cHBvcnRlZCgpKSByZXR1cm4gdGhpcy5vcHRpb25zLmZhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIEBvcHRpb25zLnVybCA9IEBlbGVtZW50LmdldEF0dHJpYnV0ZSBcImFjdGlvblwiIHVubGVzcyBAb3B0aW9ucy51cmw/XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXJsID09IG51bGwpIHRoaXMub3B0aW9ucy51cmwgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51cmwpIHRocm93IG5ldyBFcnJvcihcIk5vIFVSTCBwcm92aWRlZC5cIik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyAmJiB0aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMpIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCBwcm92aWRlIGJvdGggJ2FjY2VwdGVkRmlsZXMnIGFuZCAnYWNjZXB0ZWRNaW1lVHlwZXMnLiAnYWNjZXB0ZWRNaW1lVHlwZXMnIGlzIGRlcHJlY2F0ZWQuXCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5jaHVua2luZykgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzZXQgYm90aDogdXBsb2FkTXVsdGlwbGUgYW5kIGNodW5raW5nLlwiKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iaW5hcnlCb2R5ICYmIHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzZXQgYm90aDogYmluYXJ5Qm9keSBhbmQgdXBsb2FkTXVsdGlwbGUuXCIpO1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2VwdGVkTWltZVR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyA9IHRoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlbmFtZSAhPSBudWxsKSB0aGlzLm9wdGlvbnMucmVuYW1lRmlsZSA9IChmaWxlKT0+dGhpcy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lLmNhbGwodGhpcywgZmlsZS5uYW1lLCBmaWxlKVxuICAgICAgICA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm1ldGhvZCA9PT0gXCJzdHJpbmdcIikgdGhpcy5vcHRpb25zLm1ldGhvZCA9IHRoaXMub3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKChmYWxsYmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdGYWxsYmFjaygpKSAmJiBmYWxsYmFjay5wYXJlbnROb2RlKSAvLyBSZW1vdmUgdGhlIGZhbGxiYWNrXG4gICAgICAgIGZhbGxiYWNrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmFsbGJhY2spO1xuICAgICAgICAvLyBEaXNwbGF5IHByZXZpZXdzIGluIHRoZSBwcmV2aWV3c0NvbnRhaW5lciBlbGVtZW50IG9yIHRoZSBEcm9wem9uZSBlbGVtZW50IHVubGVzcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZpZXdzQ29udGFpbmVyICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lcikgdGhpcy5wcmV2aWV3c0NvbnRhaW5lciA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZ2V0RWxlbWVudCh0aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIsIFwicHJldmlld3NDb250YWluZXJcIik7XG4gICAgICAgICAgICBlbHNlIHRoaXMucHJldmlld3NDb250YWluZXIgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlID09PSB0cnVlKSB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5jbGlja2FibGVFbGVtZW50cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZ2V0RWxlbWVudHModGhpcy5vcHRpb25zLmNsaWNrYWJsZSwgXCJjbGlja2FibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxufVxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5pbml0Q2xhc3MoKTtcbi8vIFRoaXMgaXMgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgeW91ciBkaWZmZXJlbnQgZHJvcHpvbmVzLiBBZGQgY29uZmlndXJhdGlvbnNcbi8vIHRvIHRoaXMgb2JqZWN0IGZvciB5b3VyIGRpZmZlcmVudCBkcm9wem9uZSBlbGVtZW5zLlxuLy9cbi8vIEV4YW1wbGU6XG4vL1xuLy8gICAgIERyb3B6b25lLm9wdGlvbnMubXlEcm9wem9uZUVsZW1lbnRJZCA9IHsgbWF4RmlsZXNpemU6IDEgfTtcbi8vXG4vLyBBbmQgaW4gaHRtbDpcbi8vXG4vLyAgICAgPGZvcm0gYWN0aW9uPVwiL3VwbG9hZFwiIGlkPVwibXktZHJvcHpvbmUtZWxlbWVudC1pZFwiIGNsYXNzPVwiZHJvcHpvbmVcIj48L2Zvcm0+XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lm9wdGlvbnMgPSB7XG59O1xuLy8gUmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgYW4gZWxlbWVudCBvciB1bmRlZmluZWQgaWYgbm9uZSBhdmFpbGFibGUuXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lm9wdGlvbnNGb3JFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIEdldCB0aGUgYERyb3B6b25lLm9wdGlvbnMuZWxlbWVudElkYCBmb3IgdGhpcyBlbGVtZW50IGlmIGl0IGV4aXN0c1xuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpKSByZXR1cm4gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5vcHRpb25zWyQzZWQyNjlmMmYwZmIyMjRiJHZhciRjYW1lbGl6ZShlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpKV07XG4gICAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8vIEhvbGRzIGEgbGlzdCBvZiBhbGwgZHJvcHpvbmUgaW5zdGFuY2VzXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lmluc3RhbmNlcyA9IFtdO1xuLy8gUmV0dXJucyB0aGUgZHJvcHpvbmUgZm9yIGdpdmVuIGVsZW1lbnQgaWYgYW55XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmZvckVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgICBpZiAoKGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuZHJvcHpvbmUgOiB1bmRlZmluZWQpID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk5vIERyb3B6b25lIGZvdW5kIGZvciBnaXZlbiBlbGVtZW50LiBUaGlzIGlzIHByb2JhYmx5IGJlY2F1c2UgeW91J3JlIHRyeWluZyB0byBhY2Nlc3MgaXQgYmVmb3JlIERyb3B6b25lIGhhZCB0aGUgdGltZSB0byBpbml0aWFsaXplLiBVc2UgdGhlIGBpbml0YCBvcHRpb24gdG8gc2V0dXAgYW55IGFkZGl0aW9uYWwgb2JzZXJ2ZXJzIG9uIHlvdXIgRHJvcHpvbmUuXCIpO1xuICAgIHJldHVybiBlbGVtZW50LmRyb3B6b25lO1xufTtcbi8vIExvb2tzIGZvciBhbGwgLmRyb3B6b25lIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGEgZHJvcHpvbmUgZm9yIHRoZW1cbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZGlzY292ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgZHJvcHpvbmVzO1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSBkcm9wem9uZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmRyb3B6b25lXCIpO1xuICAgIGVsc2Uge1xuICAgICAgICBkcm9wem9uZXMgPSBbXTtcbiAgICAgICAgLy8gSUUgOihcbiAgICAgICAgbGV0IGNoZWNrRWxlbWVudHMgPSAoZWxlbWVudHMpPT4oKCk9PntcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWwgb2YgZWxlbWVudHMpaWYgKC8oXnwgKWRyb3B6b25lKCR8ICkvLnRlc3QoZWwuY2xhc3NOYW1lKSkgcmVzdWx0LnB1c2goZHJvcHpvbmVzLnB1c2goZWwpKTtcbiAgICAgICAgICAgICAgICBlbHNlIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgO1xuICAgICAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpKTtcbiAgICAgICAgY2hlY2tFbGVtZW50cyhkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZvcm1cIikpO1xuICAgIH1cbiAgICByZXR1cm4gKCgpPT57XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZHJvcHpvbmUgb2YgZHJvcHpvbmVzKS8vIENyZWF0ZSBhIGRyb3B6b25lIHVubGVzcyBhdXRvIGRpc2NvdmVyIGhhcyBiZWVuIGRpc2FibGVkIGZvciBzcGVjaWZpYyBlbGVtZW50XG4gICAgICAgIGlmICgkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lm9wdGlvbnNGb3JFbGVtZW50KGRyb3B6b25lKSAhPT0gZmFsc2UpIHJlc3VsdC5wdXNoKG5ldyAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5KGRyb3B6b25lKSk7XG4gICAgICAgIGVsc2UgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSgpO1xufTtcbi8vIFNvbWUgYnJvd3NlcnMgc3VwcG9ydCBkcmFnIGFuZCBkcm9nIGZ1bmN0aW9uYWxpdHksIGJ1dCBub3QgY29ycmVjdGx5LlxuLy9cbi8vIFNvIEkgY3JlYXRlZCBhIGJsb2NrbGlzdCBvZiB1c2VyQWdlbnRzLiBZZXMsIHllcy4gQnJvd3NlciBzbmlmZmluZywgSSBrbm93LlxuLy8gQnV0IHdoYXQgdG8gZG8gd2hlbiBicm93c2VycyAqdGhlb3JldGljYWxseSogc3VwcG9ydCBhbiBBUEksIGJ1dCBjcmFzaFxuLy8gd2hlbiB1c2luZyBpdC5cbi8vXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIHRlc3RlZCBhZ2FpbnN0IG5hdmlnYXRvci51c2VyQWdlbnRcbi8vXG4vLyAqKiBJdCBzaG91bGQgb25seSBiZSB1c2VkIG9uIGJyb3dzZXIgdGhhdCAqZG8qIHN1cHBvcnQgdGhlIEFQSSwgYnV0XG4vLyBpbmNvcnJlY3RseSAqKlxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5ibG9ja2VkQnJvd3NlcnMgPSBbXG4gICAgLy8gVGhlIG1hYyBvcyBhbmQgd2luZG93cyBwaG9uZSB2ZXJzaW9uIG9mIG9wZXJhIDEyIHNlZW1zIHRvIGhhdmUgYSBwcm9ibGVtIHdpdGggdGhlIEZpbGUgZHJhZyduJ2Ryb3AgQVBJLlxuICAgIC9vcGVyYS4qKE1hY2ludG9zaHxXaW5kb3dzIFBob25lKS4qdmVyc2lvblxcLzEyL2ksIFxuXTtcbi8vIENoZWNrcyBpZiB0aGUgYnJvd3NlciBpcyBzdXBwb3J0ZWRcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaXNCcm93c2VyU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNhcGFibGVCcm93c2VyID0gdHJ1ZTtcbiAgICBpZiAod2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5Gb3JtRGF0YSAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpKSBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmJsYWNrbGlzdGVkQnJvd3NlcnMgIT09IHVuZGVmaW5lZCkgLy8gU2luY2UgdGhpcyBoYXMgYmVlbiByZW5hbWVkLCB0aGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3QgYnJlYWsgb2xkZXJcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmJsb2NrZWRCcm93c2VycyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuYmxhY2tsaXN0ZWRCcm93c2VycztcbiAgICAgICAgICAgIC8vIFRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUEksIGJ1dCBtYXkgYmUgYmxvY2tlZC5cbiAgICAgICAgICAgIGZvciAobGV0IHJlZ2V4IG9mICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuYmxvY2tlZEJyb3dzZXJzKWlmIChyZWdleC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgY2FwYWJsZUJyb3dzZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xuICAgIHJldHVybiBjYXBhYmxlQnJvd3Nlcjtcbn07XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmRhdGFVUkl0b0Jsb2IgPSBmdW5jdGlvbihkYXRhVVJJKSB7XG4gICAgLy8gY29udmVydCBiYXNlNjQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBzdHJpbmdcbiAgICAvLyBkb2Vzbid0IGhhbmRsZSBVUkxFbmNvZGVkIERhdGFVUklzIC0gc2VlIFNPIGFuc3dlciAjNjg1MDI3NiBmb3IgY29kZSB0aGF0IGRvZXMgdGhpc1xuICAgIGxldCBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgLy8gc2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudFxuICAgIGxldCBtaW1lU3RyaW5nID0gZGF0YVVSSS5zcGxpdChcIixcIilbMF0uc3BsaXQoXCI6XCIpWzFdLnNwbGl0KFwiO1wiKVswXTtcbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuICAgIGxldCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgbGV0IGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvcihsZXQgaSA9IDAsIGVuZCA9IGJ5dGVTdHJpbmcubGVuZ3RoLCBhc2MgPSAwIDw9IGVuZDsgYXNjID8gaSA8PSBlbmQgOiBpID49IGVuZDsgYXNjID8gaSsrIDogaS0tKWlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIHdyaXRlIHRoZSBBcnJheUJ1ZmZlciB0byBhIGJsb2JcbiAgICByZXR1cm4gbmV3IEJsb2IoW1xuICAgICAgICBhYlxuICAgIF0sIHtcbiAgICAgICAgdHlwZTogbWltZVN0cmluZ1xuICAgIH0pO1xufTtcbi8vIFJldHVybnMgYW4gYXJyYXkgd2l0aG91dCB0aGUgcmVqZWN0ZWQgaXRlbVxuY29uc3QgJDNlZDI2OWYyZjBmYjIyNGIkdmFyJHdpdGhvdXQgPSAobGlzdCwgcmVqZWN0ZWRJdGVtKT0+bGlzdC5maWx0ZXIoKGl0ZW0pPT5pdGVtICE9PSByZWplY3RlZEl0ZW1cbiAgICApLm1hcCgoaXRlbSk9Pml0ZW1cbiAgICApXG47XG4vLyBhYmMtZGVmX2doaSAtPiBhYmNEZWZHaGlcbmNvbnN0ICQzZWQyNjlmMmYwZmIyMjRiJHZhciRjYW1lbGl6ZSA9IChzdHIpPT5zdHIucmVwbGFjZSgvW1xcLV9dKFxcdykvZywgKG1hdGNoKT0+bWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKClcbiAgICApXG47XG4vLyBDcmVhdGVzIGFuIGVsZW1lbnQgZnJvbSBzdHJpbmdcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgcmV0dXJuIGRpdi5jaGlsZE5vZGVzWzBdO1xufTtcbi8vIFRlc3RzIGlmIGdpdmVuIGVsZW1lbnQgaXMgaW5zaWRlIChvciBzaW1wbHkgaXMpIHRoZSBjb250YWluZXJcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZWxlbWVudEluc2lkZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHJldHVybiB0cnVlO1xuICAgICAvLyBDb2ZmZWVzY3JpcHQgZG9lc24ndCBzdXBwb3J0IGRvL3doaWxlIGxvb3BzXG4gICAgd2hpbGUoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSl7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgZWxzZSBpZiAoZWwubm9kZVR5cGUgIT0gbnVsbCkgZWxlbWVudCA9IGVsO1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcXGAke25hbWV9XFxgIG9wdGlvbiBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgYSBDU1Mgc2VsZWN0b3Igb3IgYSBwbGFpbiBIVE1MIGVsZW1lbnQuYCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uKGVscywgbmFtZSkge1xuICAgIGxldCBlbCwgZWxlbWVudHM7XG4gICAgaWYgKGVscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGVsIG9mIGVscyllbGVtZW50cy5wdXNoKHRoaXMuZ2V0RWxlbWVudChlbCwgbmFtZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChlbCBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVscykpZWxlbWVudHMucHVzaChlbCk7XG4gICAgfSBlbHNlIGlmIChlbHMubm9kZVR5cGUgIT0gbnVsbCkgZWxlbWVudHMgPSBbXG4gICAgICAgIGVsc1xuICAgIF07XG4gICAgaWYgKGVsZW1lbnRzID09IG51bGwgfHwgIWVsZW1lbnRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFxcYCR7bmFtZX1cXGAgb3B0aW9uIHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSBhIENTUyBzZWxlY3RvciwgYSBwbGFpbiBIVE1MIGVsZW1lbnQgb3IgYSBsaXN0IG9mIHRob3NlLmApO1xuICAgIHJldHVybiBlbGVtZW50cztcbn07XG4vLyBBc2tzIHRoZSB1c2VyIHRoZSBxdWVzdGlvbiBhbmQgY2FsbHMgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYWNjb3JkaW5nbHlcbi8vXG4vLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHVzZXMgYHdpbmRvdy5jb25maXJtYCBhbmQgdGhlbiBjYWxscyB0aGVcbi8vIGFwcHJvcHJpYXRlIGNhbGxiYWNrLlxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jb25maXJtID0gZnVuY3Rpb24ocXVlc3Rpb24sIGFjY2VwdGVkLCByZWplY3RlZCkge1xuICAgIGlmICh3aW5kb3cuY29uZmlybShxdWVzdGlvbikpIHJldHVybiBhY2NlcHRlZCgpO1xuICAgIGVsc2UgaWYgKHJlamVjdGVkICE9IG51bGwpIHJldHVybiByZWplY3RlZCgpO1xufTtcbi8vIFZhbGlkYXRlcyB0aGUgbWltZSB0eXBlIGxpa2UgdGhpczpcbi8vXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLWFjY2VwdFxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5pc1ZhbGlkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIGFjY2VwdGVkRmlsZXMpIHtcbiAgICBpZiAoIWFjY2VwdGVkRmlsZXMpIHJldHVybiB0cnVlO1xuICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gYWNjZXB0ZWQgbWltZSB0eXBlcywgaXQncyBPS1xuICAgIGFjY2VwdGVkRmlsZXMgPSBhY2NlcHRlZEZpbGVzLnNwbGl0KFwiLFwiKTtcbiAgICBsZXQgbWltZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgbGV0IGJhc2VNaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoL1xcLy4qJC8sIFwiXCIpO1xuICAgIGZvciAobGV0IHZhbGlkVHlwZSBvZiBhY2NlcHRlZEZpbGVzKXtcbiAgICAgICAgdmFsaWRUeXBlID0gdmFsaWRUeXBlLnRyaW0oKTtcbiAgICAgICAgaWYgKHZhbGlkVHlwZS5jaGFyQXQoMCkgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBpZiAoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxpZFR5cGUudG9Mb3dlckNhc2UoKSwgZmlsZS5uYW1lLmxlbmd0aCAtIHZhbGlkVHlwZS5sZW5ndGgpICE9PSAtMSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcL1xcKiQvLnRlc3QodmFsaWRUeXBlKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBzb21ldGhpbmcgbGlrZSBhIGltYWdlLyogbWltZSB0eXBlXG4gICAgICAgICAgICBpZiAoYmFzZU1pbWVUeXBlID09PSB2YWxpZFR5cGUucmVwbGFjZSgvXFwvLiokLywgXCJcIikpIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09PSB2YWxpZFR5cGUpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vLyBBdWdtZW50IGpRdWVyeVxuaWYgKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5ICE9PSBudWxsKSBqUXVlcnkuZm4uZHJvcHpvbmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5KHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xufTtcbi8vIERyb3B6b25lIGZpbGUgc3RhdHVzIGNvZGVzXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFEREVEID0gXCJhZGRlZFwiO1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5RVUVVRUQgPSBcInF1ZXVlZFwiO1xuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBOb3csIGlmIGEgZmlsZSBpcyBhY2NlcHRlZCwgaXQncyBlaXRoZXIgcXVldWVkXG4vLyBvciB1cGxvYWRpbmcuXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFDQ0VQVEVEID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5RVUVVRUQ7XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORyA9IFwidXBsb2FkaW5nXCI7XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlBST0NFU1NJTkcgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORzsgLy8gYWxpYXNcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQ0FOQ0VMRUQgPSBcImNhbmNlbGVkXCI7XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkVSUk9SID0gXCJlcnJvclwiO1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5TVUNDRVNTID0gXCJzdWNjZXNzXCI7XG4vKlxuXG4gQnVnZml4IGZvciBpT1MgNiBhbmQgN1xuIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTkyOTA5OS9odG1sNS1jYW52YXMtZHJhd2ltYWdlLXJhdGlvLWJ1Zy1pb3NcbiBiYXNlZCBvbiB0aGUgd29yayBvZiBodHRwczovL2dpdGh1Yi5jb20vc3RvbWl0YS9pb3MtaW1hZ2VmaWxlLW1lZ2FwaXhlbFxuXG4gKi8gLy8gRGV0ZWN0aW5nIHZlcnRpY2FsIHNxdWFzaCBpbiBsb2FkZWQgaW1hZ2UuXG4vLyBGaXhlcyBhIGJ1ZyB3aGljaCBzcXVhc2ggaW1hZ2UgdmVydGljYWxseSB3aGlsZSBkcmF3aW5nIGludG8gY2FudmFzIGZvciBzb21lIGltYWdlcy5cbi8vIFRoaXMgaXMgYSBidWcgaW4gaU9TNiBkZXZpY2VzLiBUaGlzIGZ1bmN0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3N0b21pdGEvaW9zLWltYWdlZmlsZS1tZWdhcGl4ZWxcbmxldCAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkZGV0ZWN0VmVydGljYWxTcXVhc2ggPSBmdW5jdGlvbihpbWcpIHtcbiAgICBsZXQgaXcgPSBpbWcubmF0dXJhbFdpZHRoO1xuICAgIGxldCBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0O1xuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IGloO1xuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICBsZXQgeyBkYXRhOiBkYXRhICB9ID0gY3R4LmdldEltYWdlRGF0YSgxLCAwLCAxLCBpaCk7XG4gICAgLy8gc2VhcmNoIGltYWdlIGVkZ2UgcGl4ZWwgcG9zaXRpb24gaW4gY2FzZSBpdCBpcyBzcXVhc2hlZCB2ZXJ0aWNhbGx5LlxuICAgIGxldCBzeSA9IDA7XG4gICAgbGV0IGV5ID0gaWg7XG4gICAgbGV0IHB5ID0gaWg7XG4gICAgd2hpbGUocHkgPiBzeSl7XG4gICAgICAgIGxldCBhbHBoYSA9IGRhdGFbKHB5IC0gMSkgKiA0ICsgM107XG4gICAgICAgIGlmIChhbHBoYSA9PT0gMCkgZXkgPSBweTtcbiAgICAgICAgZWxzZSBzeSA9IHB5O1xuICAgICAgICBweSA9IGV5ICsgc3kgPj4gMTtcbiAgICB9XG4gICAgbGV0IHJhdGlvID0gcHkgLyBpaDtcbiAgICBpZiAocmF0aW8gPT09IDApIHJldHVybiAxO1xuICAgIGVsc2UgcmV0dXJuIHJhdGlvO1xufTtcbi8vIEEgcmVwbGFjZW1lbnQgZm9yIGNvbnRleHQuZHJhd0ltYWdlXG4vLyAoYXJncyBhcmUgZm9yIHNvdXJjZSBhbmQgZGVzdGluYXRpb24pLlxudmFyICQzZWQyNjlmMmYwZmIyMjRiJHZhciRkcmF3SW1hZ2VJT1NGaXggPSBmdW5jdGlvbihjdHgsIGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKSB7XG4gICAgbGV0IHZlcnRTcXVhc2hSYXRpbyA9ICQzZWQyNjlmMmYwZmIyMjRiJHZhciRkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcpO1xuICAgIHJldHVybiBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoIC8gdmVydFNxdWFzaFJhdGlvKTtcbn07XG4vLyBCYXNlZCBvbiBNaW5pZnlKcGVnXG4vLyBTb3VyY2U6IGh0dHA6Ly93d3cucGVycnkuY3ovZmlsZXMvRXhpZlJlc3RvcmVyLmpzXG4vLyBodHRwOi8vZWxpY29uLmJsb2c1Ny5mYzIuY29tL2Jsb2ctZW50cnktMjA2Lmh0bWxcbmNsYXNzICQzZWQyNjlmMmYwZmIyMjRiJHZhciRFeGlmUmVzdG9yZSB7XG4gICAgc3RhdGljIGluaXRDbGFzcygpIHtcbiAgICAgICAgdGhpcy5LRVlfU1RSID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlNjQoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGxldCBjaHIxID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hyMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNocjMgPSBcIlwiO1xuICAgICAgICBsZXQgZW5jMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGVuYzIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBlbmMzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZW5jNCA9IFwiXCI7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgICAgICAgICAgY2hyMyA9IGlucHV0W2krK107XG4gICAgICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgICAgICAgZW5jMiA9IChjaHIxICYgMykgPDwgNCB8IGNocjIgPj4gNDtcbiAgICAgICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xuICAgICAgICAgICAgZW5jNCA9IGNocjMgJiA2MztcbiAgICAgICAgICAgIGlmIChpc05hTihjaHIyKSkgZW5jMyA9IGVuYzQgPSA2NDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKGNocjMpKSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzEpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMyKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMykgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzQpO1xuICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCEoaSA8IGlucHV0Lmxlbmd0aCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHN0YXRpYyByZXN0b3JlKG9yaWdGaWxlQmFzZTY0LCByZXNpemVkRmlsZUJhc2U2NCkge1xuICAgICAgICBpZiAoIW9yaWdGaWxlQmFzZTY0Lm1hdGNoKFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIikpIHJldHVybiByZXNpemVkRmlsZUJhc2U2NDtcbiAgICAgICAgbGV0IHJhd0ltYWdlID0gdGhpcy5kZWNvZGU2NChvcmlnRmlsZUJhc2U2NC5yZXBsYWNlKFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIiwgXCJcIikpO1xuICAgICAgICBsZXQgc2VnbWVudHMgPSB0aGlzLnNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlKTtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5leGlmTWFuaXB1bGF0aW9uKHJlc2l6ZWRGaWxlQmFzZTY0LCBzZWdtZW50cyk7XG4gICAgICAgIHJldHVybiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwke3RoaXMuZW5jb2RlNjQoaW1hZ2UpfWA7XG4gICAgfVxuICAgIHN0YXRpYyBleGlmTWFuaXB1bGF0aW9uKHJlc2l6ZWRGaWxlQmFzZTY0LCBzZWdtZW50cykge1xuICAgICAgICBsZXQgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpO1xuICAgICAgICBsZXQgbmV3SW1hZ2VBcnJheSA9IHRoaXMuaW5zZXJ0RXhpZihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KTtcbiAgICAgICAgbGV0IGFCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdJbWFnZUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFCdWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFeGlmQXJyYXkoc2VnbWVudHMpIHtcbiAgICAgICAgbGV0IHNlZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICB3aGlsZSh4IDwgc2VnbWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIHNlZyA9IHNlZ21lbnRzW3hdO1xuICAgICAgICAgICAgaWYgKHNlZ1swXSA9PT0gMjU1ICYgc2VnWzFdID09PSAyMjUpIHJldHVybiBzZWc7XG4gICAgICAgICAgICB4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBzdGF0aWMgaW5zZXJ0RXhpZihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KSB7XG4gICAgICAgIGxldCBpbWFnZURhdGEgPSByZXNpemVkRmlsZUJhc2U2NC5yZXBsYWNlKFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIiwgXCJcIik7XG4gICAgICAgIGxldCBidWYgPSB0aGlzLmRlY29kZTY0KGltYWdlRGF0YSk7XG4gICAgICAgIGxldCBzZXBhcmF0ZVBvaW50ID0gYnVmLmluZGV4T2YoMjU1LCAzKTtcbiAgICAgICAgbGV0IG1hZSA9IGJ1Zi5zbGljZSgwLCBzZXBhcmF0ZVBvaW50KTtcbiAgICAgICAgbGV0IGF0byA9IGJ1Zi5zbGljZShzZXBhcmF0ZVBvaW50KTtcbiAgICAgICAgbGV0IGFycmF5ID0gbWFlO1xuICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChleGlmQXJyYXkpO1xuICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChhdG8pO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHN0YXRpYyBzbGljZTJTZWdtZW50cyhyYXdJbWFnZUFycmF5KSB7XG4gICAgICAgIGxldCBoZWFkID0gMDtcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gW107XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PT0gMjE4KSBicmVhaztcbiAgICAgICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PT0gMjE2KSBoZWFkICs9IDI7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByYXdJbWFnZUFycmF5W2hlYWQgKyAyXSAqIDI1NiArIHJhd0ltYWdlQXJyYXlbaGVhZCArIDNdO1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb2ludCA9IGhlYWQgKyBsZW5ndGggKyAyO1xuICAgICAgICAgICAgICAgIGxldCBzZWcgPSByYXdJbWFnZUFycmF5LnNsaWNlKGhlYWQsIGVuZFBvaW50KTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgaGVhZCA9IGVuZFBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWQgPiByYXdJbWFnZUFycmF5Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlNjQoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGxldCBjaHIxID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hyMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNocjMgPSBcIlwiO1xuICAgICAgICBsZXQgZW5jMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGVuYzIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBlbmMzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZW5jNCA9IFwiXCI7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGJ1ZiA9IFtdO1xuICAgICAgICAvLyByZW1vdmUgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IEEtWiwgYS16LCAwLTksICssIC8sIG9yID1cbiAgICAgICAgbGV0IGJhc2U2NHRlc3QgPSAvW15BLVphLXowLTlcXCtcXC9cXD1dL2c7XG4gICAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSBjb25zb2xlLndhcm4oXCJUaGVyZSB3ZXJlIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQuXFxuVmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgYXJlIEEtWiwgYS16LCAwLTksICcrJywgJy8nLGFuZCAnPSdcXG5FeHBlY3QgZXJyb3JzIGluIGRlY29kaW5nLlwiKTtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgZW5jMSA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgIGVuYzIgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICBlbmMzID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgZW5jNCA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgIGNocjEgPSBlbmMxIDw8IDIgfCBlbmMyID4+IDQ7XG4gICAgICAgICAgICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjtcbiAgICAgICAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xuICAgICAgICAgICAgYnVmLnB1c2goY2hyMSk7XG4gICAgICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgICAgICAgaWYgKGVuYzQgIT09IDY0KSBidWYucHVzaChjaHIzKTtcbiAgICAgICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9IFwiXCI7XG4gICAgICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghKGkgPCBpbnB1dC5sZW5ndGgpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbn1cbiQzZWQyNjlmMmYwZmIyMjRiJHZhciRFeGlmUmVzdG9yZS5pbml0Q2xhc3MoKTtcbi8qXG4gKiBjb250ZW50bG9hZGVkLmpzXG4gKlxuICogQXV0aG9yOiBEaWVnbyBQZXJpbmkgKGRpZWdvLnBlcmluaSBhdCBnbWFpbC5jb20pXG4gKiBTdW1tYXJ5OiBjcm9zcy1icm93c2VyIHdyYXBwZXIgZm9yIERPTUNvbnRlbnRMb2FkZWRcbiAqIFVwZGF0ZWQ6IDIwMTAxMDIwXG4gKiBMaWNlbnNlOiBNSVRcbiAqIFZlcnNpb246IDEuMlxuICpcbiAqIFVSTDpcbiAqIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9Db250ZW50TG9hZGVkL1xuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvTUlULUxJQ0VOU0VcbiAqLyAvLyBAd2luIHdpbmRvdyByZWZlcmVuY2Vcbi8vIEBmbiBmdW5jdGlvbiByZWZlcmVuY2VcbmxldCAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkY29udGVudExvYWRlZCA9IGZ1bmN0aW9uKHdpbiwgZm4pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGxldCB0b3AgPSB0cnVlO1xuICAgIGxldCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIGxldCBhZGQgPSBkb2MuYWRkRXZlbnRMaXN0ZW5lciA/IFwiYWRkRXZlbnRMaXN0ZW5lclwiIDogXCJhdHRhY2hFdmVudFwiO1xuICAgIGxldCByZW0gPSBkb2MuYWRkRXZlbnRMaXN0ZW5lciA/IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIDogXCJkZXRhY2hFdmVudFwiO1xuICAgIGxldCBwcmUgPSBkb2MuYWRkRXZlbnRMaXN0ZW5lciA/IFwiXCIgOiBcIm9uXCI7XG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicmVhZHlzdGF0ZWNoYW5nZVwiICYmIGRvYy5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHJldHVybjtcbiAgICAgICAgKGUudHlwZSA9PT0gXCJsb2FkXCIgPyB3aW4gOiBkb2MpW3JlbV0ocHJlICsgZS50eXBlLCBpbml0LCBmYWxzZSk7XG4gICAgICAgIGlmICghZG9uZSAmJiAoZG9uZSA9IHRydWUpKSByZXR1cm4gZm4uY2FsbCh3aW4sIGUudHlwZSB8fCBlKTtcbiAgICB9O1xuICAgIHZhciBwb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByb290LmRvU2Nyb2xsKFwibGVmdFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChwb2xsLCA1MCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXQoXCJwb2xsXCIpO1xuICAgIH07XG4gICAgaWYgKGRvYy5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgaWYgKGRvYy5jcmVhdGVFdmVudE9iamVjdCAmJiByb290LmRvU2Nyb2xsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRvcCA9ICF3aW4uZnJhbWVFbGVtZW50O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApIHBvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBkb2NbYWRkXShwcmUgKyBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaW5pdCwgZmFsc2UpO1xuICAgICAgICBkb2NbYWRkXShwcmUgKyBcInJlYWR5c3RhdGVjaGFuZ2VcIiwgaW5pdCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gd2luW2FkZF0ocHJlICsgXCJsb2FkXCIsIGluaXQsIGZhbHNlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gJDNlZDI2OWYyZjBmYjIyNGIkdmFyJF9fZ3VhcmRfXyh2YWx1ZSwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gbnVsbCA/IHRyYW5zZm9ybSh2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkX19ndWFyZE1ldGhvZF9fKG9iaiwgbWV0aG9kTmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmpbbWV0aG9kTmFtZV0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRyYW5zZm9ybShvYmosIG1ldGhvZE5hbWUpO1xuICAgIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuXG5leHBvcnQgeyQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkgYXMgZGVmYXVsdCwgJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSBhcyBEcm9wem9uZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wem9uZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=